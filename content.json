{"meta":{"title":"沃德发","subtitle":"相互吹捧，共同进步😍😍😍","description":null,"author":"Yang","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2023-11-23T11:58:42.000Z","updated":"2023-11-23T11:59:22.023Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2023-12-07T14:14:04.000Z","updated":"2023-12-07T14:19:57.552Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"link","date":"2023-12-07T13:41:21.000Z","updated":"2023-12-07T13:41:48.936Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-11-23T12:01:15.000Z","updated":"2023-11-23T12:04:24.284Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"VRRP","slug":"VRRP","date":"2024-05-25T10:43:59.000Z","updated":"2024-05-25T11:11:58.536Z","comments":true,"path":"2024/05/25/VRRP/","permalink":"http://example.com/2024/05/25/VRRP/","excerpt":"","text":"简介虚拟路由冗余协议VRRP（Virtual Router Redundancy Protocol）通过把几台路由设备联合组成一台虚拟的路由设备，将虚拟路由设备的IP地址作为用户的默认网关实现与外部网络通信。当网关设备发生故障时，VRRP机制能够选举新的网关设备承担数据流量，从而保障网络的可靠通信。 随着网络的快速普及和相关应用的日益深入，各种增值业务（如IPTV、视频会议等）已经开始广泛部署，基础网络的可靠性日益成为用户关注的焦点，能够保证网络传输不中断对于终端用户非常重要。 通常，同一网段内的所有主机上都设置一条相同的、以网关为下一跳的缺省路由。主机发往其他网段的报文将通过缺省路由发往网关，再由网关进行转发，从而实现主机与外部网络的通信。当网关发生故障时，本网段内所有以网关为缺省路由的主机将无法与外部网络通信。增加出口网关是提高系统可靠性的常见方法，此时如何在多个出口之间进行选路就成为需要解决的问题。 VRRP的出现很好的解决了这个问题。VRRP能够在不改变组网的情况下，采用将多台路由设备组成一个虚拟路由器，通过配置虚拟路由器的IP地址为默认网关，实现默认网关的备份。当网关设备发生故障时，VRRP机制能够选举新的网关设备承担数据流量，从而保障网络的可靠通信。 VRRP路由器（VRRP Router）：运行VRRP协议的设备，它可能属于一个或多个虚拟路由器，如RouterA和RouterB。 虚拟路由器（Virtual Router）：又称VRRP备份组，由一个Master设备和多个Backup设备组成，被当作一个共享局域网内主机的缺省网关。如RouterA和RouterB共同组成了一个虚拟路由器。 Master路由器（Virtual Router Master）：承担转发报文任务的VRRP设备，如RouterA。 Backup路由器（Virtual Router Backup）：一组没有承担转发任务的VRRP设备，当Master设备出现故障时，它们将通过竞选成为新的Master设备，如RouterB。 VRID：虚拟路由器的标识。如RouterA和RouterB组成的虚拟路由器的VRID为1。 虚拟IP地址(Virtual IP Address)：虚拟路由器的IP地址，一个虚拟路由器可以有一个或多个IP地址，由用户配置。如RouterA和RouterB组成的虚拟路由器的虚拟IP地址为10.1.1.10&#x2F;24。 IP地址拥有者（IP Address Owner）：如果一个VRRP设备将虚拟路由器IP地址作为真实的接口地址，则该设备被称为IP地址拥有者。如果IP地址拥有者是可用的，通常它将成为Master。如RouterA，其接口的IP地址与虚拟路由器的IP地址相同，均为10.1.1.10&#x2F;24，因此它是这个VRRP备份组的IP地址拥有者。 虚拟MAC地址（Virtual MAC Address）：虚拟路由器根据虚拟路由器ID生成的MAC地址。一个虚拟路由器拥有一个虚拟MAC地址，格式为：00-00-5E-00-01-{VRID}(VRRP for IPv4)；00-00-5E-00-02-{VRID}(VRRP for IPv6)。当虚拟路由器回应ARP请求时，使用虚拟MAC地址，而不是接口的真实MAC地址。如RouterA和RouterB组成的虚拟路由器的VRID为1，因此这个VRRP备份组的MAC地址为00-00-5E-00-01-01。 0000-5e00-01xx 其中xx是vrid 报文格式vrrp只有一种报文，Advertisement报文，基于组播方式发送，目的组播地址为224.0.0.18，ip协议号：112 报文字段 含义 VRRPv2 VRRPv3 Version VRRP协议版本号，取值为2。 VRRP协议版本号，取值为3。 Type VRRP通告报文的类型，取值为1，表示Advertisement。 VRRP通告报文的类型，取值为1，表示Advertisement。 Virtual Rtr ID（VRID） 虚拟路由器ID，取值范围是1～255。 虚拟路由器ID，取值范围是1～255。 Priority Master设备在备份组中的优先级，取值范围是0～255。0表示设备停止参与VRRP备份组，用来使备份设备尽快成为Master设备，而不必等到计时器超时；255则保留给IP地址拥有者。缺省值是100。 Master设备在备份组中的优先级，取值范围是0～255。0表示设备停止参与VRRP备份组，用来使备份设备尽快成为Master设备，而不必等到计时器超时；255则保留给IP地址拥有者。缺省值是100。 Count IP Addrs&#x2F;Count IPvX Addr 备份组中虚拟IPv4地址的个数。 备份组中虚拟IPv4或虚拟IPv6地址的个数。 Auth Type VRRP报文的认证类型。协议中指定了3种类型：0：Non Authentication，表示无认证。1：Simple Text Password，表示明文认证方式。2：IP Authentication Header，表示MD5认证方式。 - Adver Int&#x2F;Max Adver Int VRRP通告报文的发送时间间隔，单位是秒，缺省值为1秒。 VRRP通告报文的发送时间间隔，单位是厘秒，缺省值为100厘秒（1秒）。 Checksum 16位校验和，用于检测VRRP报文中的数据破坏情况。 16位校验和，用于检测VRRP报文中的数据破坏情况。 IP Address&#x2F;IPvX Address(es) VRRP备份组的虚拟IPv4地址，所包含的地址数定义在Count IP Addrs字段。 VRRP备份组的虚拟IPv4地址或者虚拟IPv6地址，所包含的地址数定义在Count IPvX Addrs字段。 Authentication Data VRRP报文的认证字。目前只有明文认证和MD5认证才用到该部分，对于其它认证方式，一律填0。 - rsvd - VRRP报文的保留字段，必须设置为0。 支持的网络类型不同。VRRPv3适用于IPv4和IPv6两种网络，而VRRPv2仅适用于IPv4网络。 认证功能不同。VRRPv3不支持认证功能，而VRRPv2支持认证功能。 发送通告报文的时间间隔的单位不同。VRRPv3支持的是厘秒级，而VRRPv2支持的是秒级。 状态机 状态 说明 Initialize 该状态为VRRP不可用状态，在此状态时设备不会对VRRP报文做任何处理。通常刚配置VRRP时或设备检测到故障时会进入Initialize状态。收到接口Up的消息后，如果设备的优先级为255，则直接成为Master设备；如果设备的优先级小于255，则会先切换至Backup状态。 Master 当VRRP设备处于Master状态时，它将会做下列工作：定时（Advertisement Interval）发送VRRP通告报文。以虚拟MAC地址响应对虚拟IP地址的ARP请求。转发目的MAC地址为虚拟MAC地址的IP报文。如果它是这个虚拟IP地址的拥有者，则接收目的IP地址为这个虚拟IP地址的IP报文。否则，丢弃这个IP报文。如果收到比自己优先级大的报文，立即成为Backup。如果收到与自己优先级相等的VRRP报文且本地接口IP地址小于对端接口IP，立即成为Backup。 Backup 当VRRP设备处于Backup状态时，它将会做下列工作：接收Master设备发送的VRRP通告报文，判断Master设备的状态是否正常。对虚拟IP地址的ARP请求，不做响应。丢弃目的IP地址为虚拟IP地址的IP报文。如果收到优先级和自己相同或者比自己大的报文，则重置Master_Down_Interval定时器，不进一步比较IP地址。Master_Down_Interval定时器：Backup设备在该定时器超时后仍未收到通告报文，则会转换为Master状态。计算公式如下：Master_Down_Interval&#x3D;(3 Advertisement_Interval) + Skew_time。其中，Skew_Time&#x3D;(256–Priority)&#x2F;256。*如果收到比自己优先级小的报文且该报文优先级是0时，定时器时间设置为Skew_time（偏移时间），如果该报文优先级不是0，丢弃报文，立刻成为Master。 VRRP工作过程 VRRP备份组中的设备根据优先级选举出Master。Master设备通过发送免费ARP报文，将虚拟MAC地址通知给与它连接的设备或者主机，从而承担报文转发任务。 Master设备周期性向备份组内所有Backup设备发送VRRP通告报文，以公布其配置信息（优先级等）和工作状况。 如果Master设备出现故障，VRRP备份组中的Backup设备将根据优先级重新选举新的Master。 VRRP备份组状态切换时，Master设备由一台设备切换为另外一台设备，新的Master设备会立即发送携带虚拟路由器的虚拟MAC地址和虚拟IP地址信息的免费ARP报文，刷新与它连接的主机或设备中的MAC表项，从而把用户流量引到新的Master设备上来，整个过程对用户完全透明。 原Master设备故障恢复时，若该设备为IP地址拥有者（优先级为255），将直接切换至Master状态。若该设备优先级小于255，将首先切换至Backup状态，且其优先级恢复为故障前配置的优先级。 Backup设备的优先级高于Master设备时，由Backup设备的工作方式（抢占方式和非抢占方式）决定是否重新选举Master。 抢占模式（默认）：在抢占模式下，如果Backup设备的优先级比当前Master设备的优先级高，则主动将自己切换成Master。 非抢占模式：在非抢占模式下，只要Master设备没有出现故障，Backup设备即使随后被配置了更高的优先级也不会成为Master设备。 由此可见，为了保证Master设备和Backup设备能够协调工作，VRRP需要实现以下功能： Master设备的选举。 Master设备状态的通告。 下面将从上述两个方面详细介绍VRRP的工作过程。 Master设备的选举 VRRP根据优先级来确定虚拟路由器中每台设备的角色（Master设备或Backup设备）。优先级越高，则越有可能成为Master设备。 初始创建的VRRP设备工作在Initialize状态，收到接口Up的消息后，如果设备的优先级为255，则直接成为Master设备；如果设备的优先级小于255，则会先切换至Backup状态，待Master_Down_Interval定时器超时后再切换至Master状态。首先切换至Master状态的VRRP设备通过VRRP通告报文的交互获知虚拟设备中其他成员的优先级，进行Master的选举： 如果VRRP报文中Master设备的优先级高于或等于自己的优先级，则Backup设备保持Backup状态。 如果VRRP报文中Master设备的优先级低于自己的优先级，采用抢占方式的Backup设备将切换至Master状态，采用非抢占方式的Backup设备仍保持Backup状态。 如果多个VRRP设备同时切换到Master状态，通过VRRP通告报文的交互进行协商后，优先级较低的VRRP设备将切换成Backup状态，优先级最高的VRRP设备成为最终的Master设备；优先级相同时，VRRP设备上VRRP备份组所在接口主IP地址较大的成为Master设备。 如果创建的VRRP设备为IP地址拥有者，收到接口Up的消息后，将会直接切换至Master状态。 Master设备状态的通告 Master设备周期性地发送VRRP通告报文，在VRRP备份组中公布其配置信息（优先级等）和工作状况。Backup设备通过接收到VRRP报文的情况来判断Master设备是否工作正常。 当Master设备主动放弃Master地位（如Master设备退出备份组）时，会发送优先级为0的通告报文，用来使Backup设备快速切换成Master设备，而不用等到Master_Down_Interval定时器超时。这个切换的时间称为Skew time，计算方式为：（256－Backup设备的优先级）&#x2F;256，单位为秒。 当Master设备发生网络故障而不能发送通告报文的时候，Backup设备并不能立即知道其工作状况。等到Master_Down_Interval定时器超时后，才会认为Master设备无法正常工作，从而将状态切换为Master。其中，Master_Down_Interval定时器取值为：3×Advertisement_Interval＋Skew_time，单位为秒。 VRRP负载分担负载分担是指多个VRRP备份组同时承担业务，VRRP负载分担与VRRP主备备份的基本原理和报文协商过程都是相同的。同样对于每一个VRRP备份组，都包含一个Master设备和若干Backup设备。与主备备份方式不同点在于：负载分担方式需要建立多个VRRP备份组，各备份组的Master设备可以不同；同一台VRRP设备可以加入多个备份组，在不同的备份组中具有不同的优先级。 配置两个VRRP备份组。 VRRP备份组1：RouterA为Master设备，RouterB为Backup设备。 VRRP备份组2：RouterB为Master设备，RouterA为Backup设备。 一部分用户将VRRP备份组1作为网关，另一部分用户将VRRP备份组2作为网关。这样既可实现对业务流量的负载分担，同时，也起到了相互备份的作用。 VRRP监视上行端口 命令：上行接口视图，vrrp vrid 1 track interface g 0&#x2F;0&#x2F;1 increased(或者reduced) 30（增加或减少优先级） VRRP备份组只能感知其所在接口状态的变化，当VRRP设备上行接口或直连链路发生故障时，VRRP无法感知，此时会引起业务流量中断。通过部署VRRP与接口状态联动监视上行接口可以有效地解决上述问题，当Master设备的上行接口或直连链路发生故障时，通过调整自身优先级，触发主备切换，确保流量正常转发。 VRRP可以通过Increased和Reduced方式来监视接口状态： 如果VRRP设备上配置以Increased方式监视一个接口，当被监视的接口状态变成Down后，该VRRP设备的优先级增加指定值。 如果VRRP设备上配置以Reduced方式监视一个接口，当被监视的接口状态变为Down后，该VRRP设备的优先级降低指定值。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"VRRP","slug":"VRRP","permalink":"http://example.com/tags/VRRP/"}]},{"title":"SSH","slug":"SSH","date":"2024-05-22T08:34:38.000Z","updated":"2024-05-22T09:09:45.385Z","comments":true,"path":"2024/05/22/SSH/","permalink":"http://example.com/2024/05/22/SSH/","excerpt":"","text":"1.server配置rsa[server]rsa local-key-pair create[server]dis rsa local-key-pair public（查看）2.全局开启stelnet[server]stelnet server enable3.vty接口配置[server]user-interface vty 0 4 [server-ui-vty0-4]authentication-mode aaa [server-ui-vty0-4]protocol inbound ssh4.创建用户名和密码[server]aaa[server-aaa]local-user client01 password cipher huawei123[server-aaa]local-user client01 service-type ssh [server-aaa]local-user client01 privilege level 3（同理创建client02）5.设置服务端口号[server]ssh server port 10256.客户端上创建rsa本地密钥[client01]rsa local-key-pair create7.将客户端密钥复制到服务器[server]rsa peer-public-key client01[server-rsa-public-key]public-key-code beginEnter “RSA key code” view, return last view with “public-key-code end”.[server-rsa-key-code][server-rsa-key-code]3047[server-rsa-key-code] 0240[server-rsa-key-code] BB44D49F 0A455501 33FC2A58 9EA52FF3 7C3A29A5[server-rsa-key-code] 43A29D63 1D74F975 FAF91466 EF0D2222 A8AE038B[server-rsa-key-code] 2DAA1CE0 5F22B5D9 F6D0F2F0 EB0747B9 4D916AE1[server-rsa-key-code] 5B83DE2D[server-rsa-key-code] 0203[server-rsa-key-code] 010001 [server-rsa-key-code]public-key-code end[server-rsa-public-key]peer-public-key end [server]ssh user client01 assign rsa-key client018.客户端上开启SSH首次登录验证[client01]ssh client first-time enable [client01]stelnet 2.2.2.2 1025（登录）","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"http://example.com/tags/SSH/"}]},{"title":"BGP总结","slug":"BGP总结","date":"2024-05-11T05:13:37.000Z","updated":"2024-05-11T06:42:06.155Z","comments":true,"path":"2024/05/11/BGP总结/","permalink":"http://example.com/2024/05/11/BGP%E6%80%BB%E7%BB%93/","excerpt":"","text":"BGP使用TCP作为其传输层协议（端口号为179），使用触发式路由更新，而不是周期性路由更新。—BGP要想建立邻居关系，必须保证建立邻居关系的两端能够ping通BGP能够承载大批量的路由信息，能够支撑大规模网络。BGP提供了丰富的路由策略，能够灵活的进行路由选路，并能指导对等体按策略发布路由。BGP能够支撑MPLS&#x2F;VPN的应用，传递客户VPN路由。BGP提供了路由聚合和路由衰减功能用于防止路由振荡，通过这两项功能有效地提高了网络稳定性。 AS范围：1-65535 BGP版本：BGP4+ 一台路由器不能配置多个BGP进程 只传递路由信息，不会暴露AS内拓扑信息 BGP对等体EBGP：对等体两端属于不同的AS IBGP：对等体两端属于同一个AS 建立BGP对等体的时候可以使用物理接口建立，也可以使用loopback接口建立 EBGP对等体：建议使用物理接口建立 ①使用物理接口建立：[AR1]bgp 100 [AR1-bgp]router-id 1.1.1.1 [AR1-bgp]peer 10.0.12.2 as-number 200 ②使用loopback接口建立： [Ar4]bgp 200 [Ar4-bgp]peer 5.5.5.5 as-number 300 [Ar4-bgp]peer 5.5.5.5 connect-interface loopback0 如果使用loopback接口建立对等体，必须要指明建立对等体的接口 [Ar4-bgp]router-id 4.4.4.4 指定router id [Ar4-bgp]peer 5.5.5.5 ebgp-max-hop EBGP建立对等体关系默认发出报文TTL值为1，如果用loopback接口建立，到达loopback接口TTL值变成0，此时报文会丢弃，所以需要更改接口的TTL，peer 5.5.5.5 ebgp-max-hop命令可以直接设置TTL，至少设置为2，如果不设置，此时TTL值为255 IBGP对等体：建议使用loopback接口建立（更稳定） IBGP建立对等体关系，发送报文TTL值为255，所以不用考虑TTL不可达问题 ①使用loopback接口建立： [Ar4]bgp 200 [Ar4-bgp]peer 2.2.2.2 as-number 200 [Ar4-bgp]peer 2.2.2.2 connect-interface loopback0 ②使用物理接口建立： [Ar4]bgp 200 [Ar4-bgp]peer 10.0.34.4 as-number 200 BGP对等体关系建立 Open消息：是TCP连接建立后发送的第一个消息，用于建立BGP对等体之间的连接关系。对等体在接收到Open消息并协商成功后，将发送Keepalive消息确认并保持连接的有效性。确认后，对等体间可以进行Update、Notification、Keepalive和Route-refresh消息的交换。 Update消息：用于在对等体之间交换路由信息。Update消息可以发布多条属性相同的可达路由信息，也可以撤销多条不可达路由信息。 一条Update消息可以发布多条具有相同路由属性的可达路由，这些路由可共享一组路由属性。所有包含在一个给定的Update消息里的路由属性适用于该Update消息中的NLRI（Network Layer Reachability Information）字段里的所有目的地（用IP前缀表示）。 一条Update消息可以撤销多条不可达路由。每一个路由通过目的地（用IP前缀表示）清楚的定义了BGP Speaker之间先前通告过的路由。 一条Update消息可以同时发布可达路由，并且撤销另一部分不可达路由。一条Update消息也可以只用于撤销路由，这样就不需要包括路径属性或者NLRI。相反，也可以只用于通告可达路由，就不需要携带撤销路由信息了。 Notification消息：当BGP检测到错误状态时，就向对等体发出Notification消息，之后BGP连接会立即中断。 Keepalive消息：BGP会周期性的向对等体发出Keepalive消息，用来保持连接的有效性。缺省情况下，间隔60s，保持180s Route-refresh消息：Route-refresh消息用来请求对等体重新发送所有的可达路由信息。 在所有BGP设备使能Route-refresh能力的情况下，如果BGP的入口路由策略发生了变化，本地BGP设备会向对等体发布Route-refresh消息，收到此消息的对等体会将其路由信息重新发给本地BGP设备。这样，可以在不中断BGP连接的情况下，对BGP路由表进行动态刷新，并应用新的路由策略。 BGP状态机 Idle状态是BGP初始状态。在Idle状态下，BGP拒绝邻居发送的连接请求。只有在收到本设备的Start事件后，BGP才开始尝试和其他BGP对等体进行TCP连接，并转至Connect状态。 注意： Start事件是由一个操作者配置一个BGP进程，或者重置一个已经存在的进程或者设备软件重置BGP进程引起的。 任何状态中收到Notification报文或TCP拆链通知等Error事件后，BGP都会转至Idle状态。 在Connect状态下，BGP启动连接重传定时器（Connect Retry），等待TCP完成连接。 如果TCP连接成功，那么BGP向对等体发送Open报文，并转至OpenSent状态。 如果TCP连接失败，那么BGP转至Active状态。 如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP继续尝试和对等体进行TCP连接，停留在Connect状态。 在Active状态下，BGP总是在试图建立TCP连接。 如果TCP连接成功，那么BGP向对等体发送Open报文，关闭连接重传定时器，并转至OpenSent状态。 如果TCP连接失败，那么BGP停留在Active状态。 如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP转至Connect状态。 在OpenSent状态下，BGP等待对等体的Open报文，并对收到的Open报文中的AS号、版本号、认证码等进行检查。 如果收到的Open报文正确，那么BGP发送Keepalive报文，并转至OpenConfirm状态。 如果发现收到的Open报文有错误，那么BGP发送Notification报文给对等体，并转至Idle状态。 在OpenConfirm状态下，BGP等待Keepalive或Notification报文。如果收到Keepalive报文，则转至Established状态，如果收到Notification报文，则转至Idle状态。 在Established状态下，BGP可以和对等体交换Update、Keepalive、Route-refresh报文和Notification报文。 如果收到正确的Update或Keepalive报文，那么BGP就认为对端处于正常运行状态，将保持BGP连接。 如果收到错误的Update或Keepalive报文，那么BGP发送Notification报文通知对端，并转至Idle状态。 Route-refresh报文不会改变BGP状态。 如果收到Notification报文，那么BGP转至Idle状态。 如果收到TCP拆链通知，那么BGP断开连接，转至Idle状态。 BGP对等体双方的状态必须都为Established，BGP对等体（也可以称为BGP邻居）关系才能成立，双方通过Update报文交换路由信息。 BGP路由的生成1）network：逐条在BGP协议中注入路由（其中origin属性位“i”） 注意：network注入的路由必须是路由器的路由表存在的路由 2）import-route：将某个协议的路由引入到路由表中，直连路由、静态路由、OSPF路由、IS-IS路由等（origin属性位“incomplete”）3）路由聚合 bgp 200aggregate 10.1.0.0 22 detail-suppressed （detail-suppressed：BGP只会向对等体通告聚合后的路由，而不通告聚合前的明细路由） 自动聚合：summary automatic 自动聚合：对BGP引入的路由进行聚合。配置自动聚合后，对参加聚合的具体路由进行抑制。配置自动聚合后，BGP将按照自然网段聚合路由（如10.1.1.1&#x2F;24和10.2.1.1&#x2F;24将聚合为A类地址10.0.0.0&#x2F;8），并且BGP向对等体只发送聚合后的路由。 （自动聚合只能聚合import引入的路由） 优先级：手动＞自动＞network＞import＞从对等体学到 BGP对等体通告原则 只发布最优路由—下一跳可达、最优路由 从EBGP对等体获取的路由，会发布给所有对等体。 IBGP水平分割：从IBGP对等体获取的路由，不会发送给IBGP对等体。 BGP同步规则指的是：当一台路由器从自己的IBGP对等体学习到一条BGP路由时（这类路由被称为IBGP路由），它将不能使用该条路由或把这条路由通告给自己的EBGP对等体，除非它又从IGP协议（例如OSPF等，此处也包含静态路由）学习到这条路由，也就是要求IBGP路由与IGP路由同步。同步规则主要用于规避BGP路由黑洞问题。 路由黑洞：解决办法： ①BGP–IGP互相引入 该方法不建议 ②IBGP全互联 ③MPLS BGP属性 AS_path属性：该属性为公认必遵属性，是前往目标网络的路由经过的AS号列表；作用：确保路由在EBGP对等体之间传递无环；另外也作为路由优选的衡量标准之一；路由在被通告给EBGP对等体时，路由器会在该路由的AS_Path中追加上本地的AS号；路由被通告给IBGP对等体时，AS_Path不会发生改变。 AS_path防环机制：路由每经过一个AS就会在AS_path中记录经过的AS 号，当路由器收到update报文，检查发现AS_path中含有本AS号，不接收该路由，从而防止了路由环路的产生。 AS_path影响路由优选：收到同一个网段多条路，比较AS_path属性，哪条路由的AS_Path属性值较短，也即AS号的个数更少，就优选哪条路由。 AS-PATH类型： AS_SEQENCE：AS在传递时是有序的，默认就是该类型AS_SET：无序的，在做路由聚合时可以使用该类型。路由聚合解决了两类问题，一是减轻了设备的负担，二是隐藏了明细的路由信息，减少了路由震荡的影响。但是路由聚合后，AS_Path属性丢失，存在产生环路的风险，为此可以通过AS_SET类型的AS_Path属性携带聚合前的AS路径信息。 修改AS_path： ①additive # acl number 2000 rule 5 permit source 10.10.10.10 0 # route-policy aa permit node 10 if-match acl 2000 apply as-path 500 additive # bgp 200 peer 5.5.5.5 route-policy aa export ②overwrite # acl number 2000 rule 5 permit source 10.10.10.10 0 # route-policy aa permit node 10 if-match acl 2000 apply as-path 500 overwrite # bgp 200 peer 5.5.5.5 route-policy aa export Origin属性Origin属性用来定义路径信息的来源，标记一条路由是怎么成为BGP路由的。它有以下3种类型： IGP：具有最高的优先级。通过路由始发AS的IGP得到的路由信息，比如通过network命令注入到BGP路由表的路由，其Origin属性为IGP。 EGP：优先级次之。通过EGP得到的路由信息，其Origin属性为EGP。 Incomplete：优先级最低。通过其他方式学习到的路由信息。比如BGP通过import-route命令引入的路由，其Origin属性为Incomplete。 当去往同一个目的地存在多条不同Origin属性的路由时，在其他条件都相同的情况下，BGP将按如Origin的下顺序优选路由：IGP &gt; EGP &gt; Incomplete。也就是i &gt; e &gt; ? Next-Hop BGP的下一跳属性和IGP的有所不同，不一定就是邻居的IP地址。通常情况下，Next_Hop属性遵循下面的规则： BGP Speaker在向EBGP对等体发布某条路由时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。 BGP Speaker将本地始发路由发布给IBGP对等体时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。 BGP Speaker在向IBGP对等体发布从EBGP对等体学来的路由时，并不改变该路由信息的下一跳属性。 IBGP在进行路由传递时，下一跳地址 不变会造成路由不可达这种情况，可以使用一下命令修改 [AR2-bgp]peer 4.4.4.4 next-hop-local Local_PreferenceLocal_Preference即本地优先级属性，是公认任意属性，可以用于告诉AS中的路由器，哪条路径是离开本AS的首选路径。Local_Preference属性值越大则BGP路由越优。缺省的Local_Preference值为100。该属性只能被传递给IBGP对等体，而不能传递给EBGP对等体。越大越优。 注意事项： Local_Preference属性只能在IBGP对等体间传递（除非做了策略否则Local_Preference值在IBGP对等体间传递过程中不会丢失），而不能在EBGP对等体间传递，如果在EBGP对等体间收到的路由的路径属性中携带了Local_Preference，则会进行错误处理。但是可以在AS边界路由器上使用Import方向的策略来修改Local_Preference属性值。也就是在收到路由之后，在本地为路由赋予Local_Preference。使用bgp default local-preference命令修改缺省Local_Preference值，该值缺省为100。路由器在向其EBGP对等体发送路由更新时，不能携带Local_Preference属性，但是对方接收路由之后，会在本地为这条路由赋一个缺省Local_Preference值（100），然后再将路由传递给自己的IBGP对等体。本地使用network命令及import-route命令引入的路由， Local_Preference为缺省值100，并能在AS内向其他IBGP对等体传递，传递过程中除非受路由策略影响，否则Local_Preference不变 Community（团体）Community属性为可选过渡属性，是一种路由标记，用于简化路由策略的执行。可以将某些路由分配一个特定的Community属性值，之后就可以基于Community值而不是网络前缀&#x2F;掩码信息来匹配路由并执行相应的策略了。 MED（Multi-Exit Discriminator，多出口鉴别器）是可选非过渡属性，是一种度量值，用于向外部对等体指出进入本AS的首选路径，即当进入本AS的入口有多个时，AS可以使用MED动态地影响其他AS选择进入的路径。MED属性值越小则BGP路由越优。MED主要用于在AS之间影响BGP的选路。MED被传递给EBGP对等体后，对等体在其AS内传递路由时，携带该MED值，但将路由再次传递给其EBGP对等体时，缺省不会携带MED属性。0-4294967295 注意事项： 缺省情况下，路由器只比较来自同一相邻AS的BGP路由的MED值，也就是说如果去往同一个目的地的两条路由来自不同的相邻AS，则不进行MED值的比较。一台BGP路由器将路由通告给EBGP对等体时，是否携带MED属性，需要根据以下条件进行判断（不对EBGP对等体使用策略的情况下）：如果该BGP路由是本地始发（本地通过network或import-route命令引入）的，则缺省携带MED属性发送给EBGP对等体。如果该BGP路由为从BGP对等体学习到，那么该路由传递给EBGP对等体时缺省不会携带MED属性。在IBGP对等体之间传递路由时，MED值会被保留并传递，除非部署了策略，否则MED值在传递过程中不发生改变也不会丢失。如果路由器通过IGP学习到一条路由，并通过network或import-route的方式将路由引入BGP，产生的BGP路由的MED值继承路由在IGP中的metric。 可以使用default med命令修改缺省的MED值，default med命令只对本设备上用import-route命令引入的路由和BGP的聚合路由生效。 Preferred-Value（协议首选值）是华为设备的特有属性，该属性仅在本地有效。当BGP路由表中存在到相同目的地的路由时，将优先选择Preferred-Value值高的路由。取值范围：0~65535；该值越大，则路由越优先。Preferred-Value只能在路由器本地配置，而且只影响本设备的路由优选。该属性不会传递给任何BGP对等体。 路由反射器作用：解决IBGP全互联的问题 1、RR从EBGP学习到的，会发送给client和非client 2、RR从非client学习到的路由，会反射给自己的client，但是不会给非client 3、RR从client学习到的路由，会反射非自己的非client和client 非非不传 路由反射器中的防环：Originator_ID，Cluster_ListRR将一条BGP路由进行反射时会在反射出去的路由中增加Originator_ID，其值为本地AS中通告该路由的BGP路由器Router ID。若AS内存在多个RR，则Originator_ID属性由第一个RR创建，并且不被后续的RR（若有）所更改。当BGP路由器收到一条携带Originator_ID属性的IBGP路由，并且Originator_ID属性值与自身的Router ID相同，则它会忽略关于该条路由的更新。 路由反射簇包括反射器RR及其Client。一个AS内允许存在多个路由反射簇（如下图）。每一个簇都有唯一的簇ID（Cluster_ID，缺省时为RR的BGP Router ID ）。当一条路由被反射器反射后，该RR（该簇）的Cluster_ID就会被添加至路由的Cluster_list属性中。当RR收到一条携带Cluster_list属性的BGP路由，且该属性值中包含该簇的Cluster_ID时，RR认为该条路由存在环路，因此将忽略关于该条路由的更新。 配置： 在RR路由器上配置： Bgp 200 peer 6.6.6.6 reflect-client –谁是client，就peer谁 缺省情况下，每个路由反射器使用自己的Router ID作为集群ID。[Huawei-bgp] reflector cluster-id 20.2.2.2 路由优选原则：P L L A O M E N 漂亮老男人 p—Preference Value (越大越优，仅限路由器本地) L— Local Preference，本地优先级 (越大越优，同一AS内的路由器） L— 手动聚合-&gt;自动聚合-&gt;network-&gt;import，为本地始发 A —AS Path (短的优先) O —Origin，起源i(network)&gt;e(EBGP)&gt;? (import-route) M—MED (值越小越优，本AS内或上游AS内所有路由器，EBGP邻居上设置) E— EBGP优于IBGP (前面都一样，比不出最优路径时) N— Next-Hop，下一跳(BGP选择IGP下一跳cost值最小的) 9.优选Cluster-List最短的路由 10.优选Router-ID（Origintor- ID）最小的设备通告的路由 11.优选具有最小的IP地址的对等体通告的路由 前八条全部相同形成路由负载分担","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"BGP","slug":"BGP","permalink":"http://example.com/tags/BGP/"}]},{"title":"组播","slug":"组播","date":"2024-05-10T06:52:53.000Z","updated":"2024-05-11T05:11:37.034Z","comments":true,"path":"2024/05/10/组播/","permalink":"http://example.com/2024/05/10/%E7%BB%84%E6%92%AD/","excerpt":"","text":"组播简介组播（Multicast）是在一台源IP主机和多台（一组）IP主机之间进行，中间的网络设备根 据接收者的需要，有选择性地对数据进行复制和转发。 • 组播技术有效地满足了单点发送、多点接收的需求，实现了IP网络中点到多点业务数据的高 效传送，能够大量节约网络带宽、降低网络负载。 • 组播分发树：组播流量的转发路径 组播地址：224.0.0.0–239.255.255.255 组播MAC： RPF检查： IGMPv1IGMPv1协议主要基于查询和响应机制完成组播组管理。当一个网段内有多个组播设备时，由于它们都可以接收到主机发送的成员报告报文，因此只需要选取其中一台组播设备发送查询报文，该组播设备称为IGMP查询器（Querier）。在IGMPv1中，由组播路由协议PIM选举出唯一的组播信息转发者（Assert Winner或DR）作为IGMP的查询器，负责该网段的组成员关系查询。 （不具备选举查询器，依赖PIM协议选举） IGMPv1报文IGMPv1报文封装在IP报文中，由8个字节组成。IGMPv1包括两种类型的报文： 普遍组查询报文（General Query）：查询器向共享网络上所有主机发送的查询报文，用于了解哪些组播组存在成员。（60s一次） 成员报告报文（Report）：主机向查询器发送的报告报文，用于申请加入某个组播组或者应答查询报文。 字段 说明 Version IGMP版本，值为1。 Type 报文类型。该字段有以下两种取值：0x1：表示普遍组查询报文。0x2：表示成员报告报文。 Unused 在IGMPv1中，该字段在发送时被设为0，并在接收时被忽略。 Checksum 校验和。 Group Address 组播组地址。在普遍组查询报文中，该字段设为0；在成员报告报文中，该字段为成员加入的组播组地址。 查询组播组成员机制 普遍组查询和响应过程如下： IGMP查询器发送目的地址为224.0.0.1（表示同一网段内所有主机和设备）的普遍组查询报文；收到该查询报文的组成员启动定时器。 普遍组查询报文是周期性发送的，发送周期可以通过命令配置。HostA和HostB作为组播组G1的成员，收到普遍组查询报文后，在本地启动定时器Timer-G1。 第一个定时器（10s）超时的组成员发送针对该组的报告报文。 假设HostA上的Timer-G1首先超时，HostA向该网段发送目的地址为G1的报告报文。也想加入组G1的HostB收到此报告报文，则停止定时器Timer-G1，不再发送针对G1的报告报文。这样报告报文被抑制，可以减少网段上的流量。 IGMP查询器接收到HostA的报告报文后，了解到本网段内存在组播组G1的成员，则由组播路由协议生成（，G1）组播转发表项，“”代表任意组播源。网络中一旦有组播组G1的数据到达DeviceA，将向该网段转发。 加组机制 主机HostC不等待普遍组查询报文的到来，主动发送针对G2的报告报文以声明加入组播组G2。 IGMP查询器接收到HostC的报告报文后，了解到本网段内出现了组播组G2的成员，则生成组播转发项（*，G2）。网络中一旦有G2的数据到达DeviceA，将向该网段转发。 离组机制IGMPv1没有专门定义离开组的报文。主机离开组播组后，停止发送成员报告报文。根据主机想要离开的组播组中是否还有其他成员，处理机制有所不同。如图2所示。 假设HostA想要退出组播组G1 HostA收到IGMP查询器发送的普遍组查询报文时，不再发送针对G1的报告报文。由于网段内还存在G1组成员HostB，HostB会向IGMP查询器发送针对G1的报告报文，因此IGMP查询器感知不到HostA的离开。 假设HostC想要退出组播组G2 HostC收到IGMP查询器发送的普遍组查询报文时，不再发送针对G2的报告报文。由于网段内不存在组G2的其他成员，IGMP查询器不会收到G2组成员的报告报文，则在一定时间（缺省值为130秒）后，删除G2所对应的组播转发表项。 130&#x3D;60×2+10 IGMPv2IGMPv2的工作机制与IGMPv1基本相同，最大的不同之处在于IGMPv2增加了查询器选举和离开组机制。IGMPv2可以使IGMP查询器及时了解到网段内哪些组播组已不存在成员，从而及时更新组成员关系，减少网络中冗余的组播流量。 与IGMPv1相比，IGMPv2的变化如下： 除了普遍组查询报文和成员报告报文之外，IGMPv2新增了两种报文： 成员离开报文（Leave）：成员离开组播组时主动向查询器发送的报文，用于宣告自己离开了某个组播组。 特定组查询报文（Group-Specific Query）：查询器向共享网段内指定组播组发送的查询报文，用于查询该组播组是否存在成员。 IGMPv2对普遍组查询报文格式也做了改进，添加了最大响应时间（Max Response Time）字段。此字段取值可以通过命令配置，用于控制成员对于查询报文的响应速度。 IGMPv2报文：图1 IGMPv2报文格式 字段 说明 Type 报文类型。该字段有以下四种取值：0x11：表示查询报文。IGMPv2的查询报文包括普遍组查询报文和特定组查询报文两类。0x12：表示IGMPv1成员报告报文。0x16：表示IGMPv2成员报告报文。0x17：表示成员离开报文。 Max Response Time 最大响应时间。成员主机在收到IGMP查询器发送的普遍组查询报文后，需要在最大响应时间内做出回应。该字段仅在IGMP查询报文中有效。 Checksum 校验和。 Group Address 组播组地址。在普遍组查询报文中，该字段设为0。在特定组查询报文中，该字段为要查询的组播组地址。在成员报告报文和离开报文中，该字段为成员要加入或离开的组播组地址。 v2查询器选举机制在IGMPv2中，查询器的选举过程如下： 初始状态下，所有运行IGMPv2的组播设备（DeviceA和DeviceB）都认为自己是查询器，向本网段内的所有主机和组播设备发送普遍组查询报文。DeviceA和DeviceB在收到对方发送的普遍组查询报文后，将报文的源IP地址与自己的接口地址作比较。通过比较，IP地址最小的组播设备将成为查询器，其他组播设备成为非查询器。如图所示，DeviceA的接口地址小于DeviceB，则DeviceA当选为查询器，DeviceB为非查询器。 确定查询器后，将由IGMP查询器（DeviceA）向本网段内的所有主机和其他组播设备发送普遍组查询报文，而非查询器（DeviceB）则不再发送普遍组查询报文。 非查询器（DeviceB）上都会启动一个定时器（即其他查询器存在时间定时器Other Querier Present Timer）。在该定时器超时前，如果收到了来自查询器的查询报文，则重置该定时器；否则，就认为原查询器失效，并发起新的查询器选举过程。 v2离组机制在IGMPv2中，成员离开组播组时可以主动向查询器发送离开报文，宣告自己离开了某个组播组。 主机HostA离开组播组G1的过程如下： HostA向本地网段内的所有组播设备（目的地址为224.0.0.2）发送针对组G1的离开报文。 查询器收到离开报文，会发送针对组G1的特定组查询报文。发送间隔和发送次数可以通过命令配置，缺省情况下每隔1秒发送一次，共发送两次。同时查询器启动组成员关系定时器（Timer-Membership&#x3D;发送间隔x发送次数）。 如果该网段内还存在组G1的其他成员（如HostB），这些成员在收到查询器发送的特定组查询报文后，会立即发送针对组G1的报告报文。查询器收到针对组G1的报告报文后将继续维护该组成员关系。如果该网段内不存在组G1的其他成员，查询器将不会收到针对组G1的报告报文。在Timer-Membership超时后，查询器将删除（*，G1）对应的IGMP组表项。当有组G1的组播数据到达查询器时，查询器将不会向下游转发。 IGMPv3IGMPv3主要是为了配合SSM（Source-Specific Multicast）模型发展起来的，提供了在报文中携带组播源信息的能力，即主机可以对组播源进行选择。 与IGMPv2相比，IGMPv3报文的变化如下： IGMPv3报文包含两大类：查询报文和成员报告报文。IGMPv3没有定义专门的成员离开报文，成员离开通过特定类型的报告报文来传达。 查询报文中不仅包含普遍组查询报文和特定组查询报文，还新增了特定源组查询报文（Group-and-Source-Specific Query）。该报文由查询器向共享网段内特定组播组成员发送，用于查询该组成员是否愿意接收特定源发送的数据。特定源组查询通过在报文中携带一个或多个组播源地址来达到这一目的。 成员报告报文不仅包含主机想要加入的组播组，而且包含主机想要接收来自哪些组播源的数据。IGMPv3增加了针对组播源的过滤模式（INCLUDE&#x2F;EXCLUDE），将组播组与源列表之间的对应关系简单的表示为（G，INCLUDE，(S1、S2…)），表示只接收来自指定组播源S1、S2……发往组G的数据；或（G，EXCLUDE，(S1、S2…)），表示接收除了组播源S1、S2……之外的组播源发给组G的数据。当组播组与组播源列表的对应关系发生了变化，IGMPv3报告报文会将该关系变化存放于组记录（Group Record）字段，发送给IGMP查询器。 在IGMPv3中一个成员报告报文可以携带多个组播组信息，而之前的版本一个成员报告只能携带一个组播组。这样在IGMPv3中报文数量大大减少。 IGMPv3报文 字段 说明 Type 报文类型，取值为0x11。 Max Response Code 最大响应时间。成员主机在收到IGMP查询器发送的普遍组查询报文后，需要在最大响应时间内做出回应。 Checksum 校验和。 Group Address 组播组地址。在普遍组查询报文中，该字段设为0；在特定组查询报文和特定源组查询报文中，该字段为要查询的组播组地址。 Resv 保留字段。发送报文时该字段设为0；接收报文时，对该字段不做处理。 S 该比特位为1时，所有收到此查询报文的其他设备不启动定时器刷新过程，但是此查询报文并不抑制查询器选举过程和设备的主机侧处理过程。 QRV 如果该字段非0，则表示查询器的健壮系数（Robustness Variable）。如果该字段为0，则表示查询器的健壮系数大于7。设备接收到查询报文时，如果发现该字段非0，则将自己的健壮系数调整为该字段的值；如果发现该字段为0，则不做处理。 QQIC IGMP查询器的查询间隔，单位为秒。非查询器收到查询报文时，如果发现该字段非0，则将自己的查询间隔参数调整为该字段的值；如果发现该字段为0，则不做处理。 Number of Sources 报文中包含的组播源的数量。对于普遍组查询报文和特定组查询报文，该字段为0；对于特定源组查询报文，该字段非0。此参数的大小受到所在网络MTU大小的限制。 Source Address 组播源地址，其数量受到Number of Sources字段值大小的限制。 字段 说明 Type 报文类型，取值为0x22。 Reserved 保留字段。发送报文时该字段设为0；接收报文时，对该字段不做处理。 Checksum IGMP报文的校验和。校验和是IGMP报文长度（即IP报文的整个有效负载）的16位检测，表示IGMP信息补码之和的补码。Checksum字段在进行校验计算时设为0。当发送报文时，必须计算校验和并插入到Checksum字段中去。当接收报文时，校验和必须在处理该报文之前进行检验。 Number of Group Records (M) 报文中包含的组记录的数量。 Group Record 组记录。Group Record字段的格式如图3所示，解释如表3所示。 字段 说明 Record Type 组记录的类型。共分为三大类。当前状态报告。用于对查询报文进行响应，通告自己目前的状态，共两种：MODE_IS_INCLUDE，表示接收源地址列表包含的源发往该组的组播数据。如果指定源地址列表为空，该报文无效。MODE_IS_EXCLUDE，表示不接收源地址列表包含的源发往该组的组播数据。过滤模式改变报告。当组和源的关系在INCLUDE和EXCLUDE之间切换时，会通告过滤模式发生变化，共两种：CHANGE_TO_INCLUDE_MODE，表示过滤模式由EXCLUDE转换到INCLUDE，接收源地址列表包含的新组播源发往该组播组的数据。如果指定源地址列表为空，主机将离开组播组。CHANGE_TO_EXCLUDE_MODE，表示过滤模式由INCLUDE转换到EXCLUDE，拒绝源地址列表包含的新组播源发往该组的组播数据。源列表改变报告。当指定源发生改变时，会通告源列表发生变化，共两种：ALLOW_NEW_SOURCES，表示在现有的基础上，需要接收源地址列表包含的组播源发往该组播组的组播数据。如果当前对应关系为INCLUDE，则向现有源列表中添加这些组播源；如果当前对应关系为EXCLUDE，则从现有阻塞源列表中删除这些组播源。BLOCK_OLD_SOURCES，表示在现有的基础上，不再接收源地址列表包含的组播源发往该组播组的组播数据。如果当前对应关系为INCLUDE，则从现有源列表中删除这些组播源；如果当前对应关系为EXCLUDE，则向现有源列表中添加这些组播源。 Aux Data Len 辅助数据长度。在IGMPv3的报告报文中，不存在辅助数据字段，该字段设为0。 Number of Sources (N) 本记录中包含的源地址数量。 Multicast Address 组播组地址。 Source Address 组播源地址。 Auxiliary Data 辅助数据。预留给IGMP后续扩展或后续版本。在IGMPv3的报告报文中，不存在辅助数据。 IGMPv3工作机制在工作机制上，与IGMPv2相比，IGMPv3增加了主机对组播源的选择能力。 特定源组加入 IGMPv3的成员报告报文的目的地址为224.0.0.22（表示同一网段所有使能IGMPv3的设备）。通过在报告报文中携带组记录，主机在加入组播组的同时，能够明确要求接收或不接收特定组播源发出的组播数据。如图4所示，网络中存在S1和S2两个组播源，均向组播组G发送组播数据，Host仅希望接收从组播源S1发往组播组G的信息。 如果Host和组播设备之间运行的是IGMPv1或IGMPv2，Host加入组播组G时无法对组播源进行选择，无论其是否需要，都会同时接收到来自组播源S1和S2的数据。如果采用IGMPv3，成员主机可以发送IGMPv3报告（G，INCLUDE，(S1)），选择仅接收源S1向组播组G发送的数据。 特定源组查询 当接收到组成员发送的改变组播组与源列表的对应关系的报告时（比如CHANGE_TO_INCLUDE_MODE、CHANGE_TO_EXCLUDE_MODE），IGMP查询器会发送特定源组查询报文。如果组成员希望接收其中任意一个源的组播数据，将反馈报告报文。IGMP查询器根据反馈的组成员报告更新该组对应的源列表。 各个版本比较 IGMP Snooping 当Router将组播报文转发至Switch以后，Switch负责将组播报文转发给组播用户。由于组 播报文的目的地址为组播组地址，在二层设备上是学习不到这一类MAC表项的，因此组播 报文就会在所有接口进行广播，和它在同一广播域内的组播成员和非组播成员都能收到组 播报文。这样不但浪费了网络带宽，而且影响了网络信息安全。 • IGMP Snooping有效地解决了这个问题。配置IGMP Snooping后，二层组播设备可以侦听 和分析组播用户和上游路由器之间的IGMP报文，根据这些信息建立二层组播转发表项，控 制组播数据报文转发。这样就防止了组播数据在二层网络中的广播。 • 路由器端口形成后会启动老化计时器（默认180s）,当路由器端口收到新的普遍组查询后刷 新该计时器。 • 成员端口形成后会启动老化计时器（默认180s）,当成员端口收到新的成员关系报告报文后 刷新该计时器。 • IGMP Snooping不再使用成员关系报告报文抑制机制： ▫ 由于IGMP Snooping需要监听IGMP报文才能决定端口角色，进而指导转发，所以所 有组成员都需要发送IGMP组成员关系报告报文。 ▫ 当IGMP Snooping设备收到成员关系报告报文后，只将成员关系报告报文从路由器接 口发送出去，从而避免其余组成员收到成员关系报告报文，不触发成员关系报告报文 抑制机制。 • 收到IGMP离开报文后，成员端口的老化定时器 &#x3D; 健壮系数（默认2） x 特定组查询间隔 （默认1s）。 IGMP SSM MappingSSM（Source-Specific Multicast）称为指定源组播，要求设备能了解成员主机加入组播组时所指定的组播源。如果成员主机上运行IGMPv3，可以在IGMPv3报告报文中直接指定组播源地址。但是某些情况下，成员主机只能运行IGMPv1或IGMPv2，为了使其也能够使用SSM服务，设备上需要提供IGMP SSM Mapping功能。 IGMP SSM Mapping的机制是：通过在设备上静态配置SSM地址的映射规则，将IGMPv1和IGMPv2报告报文中的（*, G）信息转化为对应的（G, INCLUDE, (S1, S2…)）信息，以提供SSM组播服务。 配置了SSM Mapping规则后，当IGMP查询器收到来自成员主机的IGMPv1或IGMPv2报告报文时，首先检查该报文中所携带的组播组地址G，然后根据检查结果的不同分别进行处理。 如果G在ASM（Any-Source Multicast）范围内，则只提供ASM服务。 如果G在SSM组地址范围内（缺省情况下为232.0.0.0～232.255.255.255）： 如果设备上没有G对应的SSM Mapping规则，则无法提供SSM服务，丢弃该报文。 如果设备上有G对应的SSM Mapping规则，则依据规则将报告报文中所包含的（*, G）信息映射为（G, INCLUDE, (S1, S2…)）信息，提供SSM服务。 SSM网络的用户网段中HostA运行IGMPv3、HostB运行IGMPv2、HostC运行IGMPv1。HostB和HostC无法升级到IGMPv3，如果要为该网段中的所有主机提供SSM服务，需要在IGMP查询器（Device）上使能IGMP SSM Mapping并配置相应的映射规则。 假如在Device上配置如下映射关系： 组播组地址 映射的组播源地址 232.0.0.0&#x2F;8 10.10.1.1 232.1.0.0&#x2F;16 10.10.2.2 232.1.0.0&#x2F;16 10.10.3.3 232.1.1.0&#x2F;24 10.10.4.4 经过映射后，Device收到HostB和HostC的成员报告报文时，首先判断报文携带的组地址是否在SSM范围内，发现在SSM范围内，则根据配置的映射规则生成如下所示的组播表项。如果一个组地址映射了多个源，则生成多个（S，G）表项。 在映射过程中，一个组播组地址只要能在规则中匹配到，都会生成一条相应的表项。因此232.1.1.1有四条表项，232.1.2.2有三条表项。 IGMPv1&#x2F;IGMPv2报告报文中的组地址 生成的组播表项 232.1.1.1 （来自HostC） （10.10.1.1，232.1.1.1）（10.10.2.2，232.1.1.1）（10.10.3.3，232.1.1.1）（10.10.4.4，232.1.1.1） 232.1.2.2 （来自HostB） （10.10.1.1，232.1.2.2）（10.10.2.2，232.1.2.2）（10.10.3.3，232.1.2.2） IGMP Proxy PIM DMPIM-DM：密集模式，采用的是“推”模式，适用于成员比较少，相对密集的场景 PIM-SM：稀疏模式 采用的是“拉”模式，适用于成员多，但是成员不集中的场景 PIM（Protocol Independent Multicast，协议无关组播）是域内组播路由协议，利用单播路由信息，对组播消息进行RPF检查，创建组播路由表项。为IP组播提供路由信息的协议可以是任何单播路由协议，比如静态路由、RIP、OSPF、IS-IS、BGP等。组播路由和单播路由协议无关，只是通过单播路由表产生相应组播路由表项。 目前在实际网络中，PIM协议有三种模式：PIM-DM、使用ASM（Any-Source Multicast）模型的PIM-SM，使用SSM（Source-Specific Multicast）模型的PIM-SM。需要注意的是，同一个PIM域中不能同时运行PIM-DM和PIM-SM。 PIM协议中依据组播分发树转发数据，组播分发树有两种，SPT和RPT 以组播源为根，组播组成员为叶子的组播分发树称为SPT（Shortest Path Tree），在PIM-DM与PIM-SM中均有使用。以RP（Rendezvous Point）为根，组播组成员为叶子的组播分发树称为RPT（RP Tree），在PIM-SM中使用。 PIM-DM域中组播数据转发的实现过程是： 邻居发现Neighbor Discovery）：在PIM-DM域中，PIM设备通过周期性的向所有其他PIM设备发送Hello消息，来发现PIM邻居，维护PIM设备之间的PIM邻居关系。缺省情况下，无论PIM设备是否收到来自邻居的Hello消息，都会接收其他的PIM控制消息或组播报文。但是如果PIM设备配置了邻居检查功能，则只有在PIM设备接收到来自邻居的Hello消息后，才会接收其他的PIM控制消息或组播报文。 扩散Flooding）：PIM-DM假设网络中的每个子网都存在至少一个组播组成员，因此组播数据将被扩散到网络中的所有节点，网络中所有的PIM设备都能接收到组播数据。 剪枝（Prune）：组播数据扩散到网络中后，PIM-DM对没有组播数据接收者的分支进行剪枝，只保留包含接收者的分支，即确保网络中只有需要组播数据的PIM设备能够接收到组播数据，不需要组播数据的PIM设备接收不到组播数据。 状态刷新（State-Refresh）：如果设备处于剪枝状态，其上游PIM设备会维护一个“剪枝定时器”。当剪枝定时器超时，上游PIM设备恢复对不需要数据的下游PIM设备的数据转发，这样会导致不必要的网络资源浪费。采用状态刷新可使离组播源最近的第一跳设备周期性发送State-Refresh消息，刷新所有设备的剪枝定时器状态，对不需要数据的下游设备始终保持剪枝状态。 嫁接Graft）：当被剪枝分支的节点上出现了组播组成员时，为了减少该节点恢复成转发状态所需的时间，PIM-DM使用嫁接机制主动恢复其对组播数据的转发。 断言（Assert）：如果在一个网段内出现多台PIM设备，则相同的组播报文可能会被重复发送到该网段。通过断言可以为网段选定唯一的组播数据转发者，避免冗余的组播数据转发。 邻居发现PIM设备在每个使能了PIM的接口上，都会对外发送Hello消息。封装Hello消息的组播报文有如下特点： 目的地址是224.0.0.13，表示同一网段中所有PIM设备 源地址为接口的IP地址 TTL数值为1，仅发送给邻居接口 Hello消息具有发现邻居、协商各项协议参数、维持邻居关系的作用。 发现PIM邻居 同一网段中的PIM设备都必须接收目的地址为224.0.0.13的组播报文。这样在收到Hello消息以后，直接相连的组播设备之间，就可以知道自己的邻居信息。 协商各项协议参数 Hello消息中携带多项协议参数，邻居之间通过Hello消息来进行协商，这些参数包括： DR_Priority：表示各设备接口竞选DR的优先级，优先级越高越容易获胜。 Holdtime：表示保持邻居为可达状态的超时时间。 LAN_Delay：表示共享网段内传输Prune消息的延迟时间。 Override-Interval：表示Hello消息]中携带的否决剪枝的时间间隔。 维持邻居关系 PIM设备之间周期性地发送Hello消息。如果Holdtime超时还没有收到该PIM邻居发出的新的Hello消息，则认为该邻居不可达，将其从邻居列表中清除。 PIM邻居的变化将导致网络中组播拓扑的变化。如果组播分发树上的某上游邻居或下游邻居不可达，将导致组播路由重新收敛，组播分发树迁移。 维护邻居关系 30s 邻居超时时间105s 扩散机制全网建立（S，G）路由表项 组播源开始发送组播数据，组播数据全网进行转发，生成（S，G ）表项，表项默认老化时间210s，，超过210s没有组播数据转发，将删除表项，有组播 数据的时候重新建立表项 扩散机制会周期性（默认180s）全网扩散组播数据，周期性扩散的主要目的是探测是否有新成员加组，但是由于全网扩散组播数据会浪费大量带宽，所以现在的组播网络一般使用“状态刷新机制”加上“嫁接机制”来实现周期性全网扩散感知新成员加组的目的。 剪枝如果路由器下游没有组成员，将向上游发起剪枝，剪到最后一个不需要发组播报文的路由器 剪枝接口会有一个计时器，210s，计时器超时，接口将加入下游接口，转发组播报文 状态刷新机制状态刷新报文60s发一次 对于剪枝端口而言，收到状态刷新报文，计时器将重置 离组播源最近的第一跳路由器周期性触发State-Refresh消息。State-Refresh消息在全网扩散，刷新所有设备上的剪枝定时器状态，对不需要数据的下游设备始终保持剪枝状态。 嫁接一旦有新成员加入，叶子路由器会基于本地的组播路由表向上游发送Graft报文，请求上游路由器恢复相应出接口转发，将其添加在（S，G）表项下游接口列表中。 下游发送Graft消息，请求上游恢复对应出接口的转发。上游收到Graft消息后，将下游的出接口恢复转发 断言在组播网络中，如果出现如下情况，则说明网段上还存在着其他的组播转发者。 该组播报文不能通过RPF检查。 接收到该组播报文的接口是本设备上（S，G）表项中的一个下游接口。 此时，设备会执行Assert机制。设备从该下游接口发送Assert消息。同时，该下游接口也接收到了来自该网段上其他组播转发者的Assert消息。Assert消息的目的地址为224.0.0.13，源地址为下游接口地址，TTL为1。Assert消息中携带该PIM设备到组播源或RP的开销、所采用的单播路由协议的优先级和组播组地址G。 设备将自身条件与对方报文中携带的信息进行比较，称为Assert竞选。规则如下： 单播路由协议优先级较高者获胜。 如果优先级相同，则到组播源或RP的开销较小者获胜。 如果以上都相同，则下游接口IP地址最大者获胜。 根据Assert竞选结果，设备将执行不同的操作： 如果获胜，则该下游接口保持转发状态，设备负责后续在该网段上的（S，G）转发，该下游接口称为Assert winner。 如果落败，则禁止该下游接口转发组播报文，将其从（S，G）表项下游接口列表中删除。该下游接口称为Assert loser。 Assert竞选结束后，该网段上只存在一个有下游接口的上游设备，只传输一份组播报文。Assert winner周期性发送Assert消息，维持Assert winner的状态。若Assert loser的定时器超时后，Assert loser仍没有收到Assert winner的Assert消息，则重新添加下游接口转发组播数据。 如图6所示，如果DeviceB和DeviceC都能够接收到组播源Source发出的组播报文，并且均能通过RPF检查，创建（S，G）表项。DeviceB、DeviceC的下游接口连接在同一网段，那么DeviceB和DeviceC就会同时向该网段发送组播数据。Assert机制可以保证一个网段只能存在一个组播数据转发者。Assert过程如下： DeviceB从下游接口接收到DeviceC发来的组播报文，RPF检查失败，报文被丢弃。同时，DeviceB向该网段发送Assert消息。 DeviceC将自身的路由信息与对方的Assert消息中携带的路由信息进行比较，由于自身到组播源的开销较大而落败。于是禁止该下游接口转发组播报文，将其从DeviceC的（S，G）表项的下游接口列表中删除。 DeviceC从该网段接收到DeviceB发来的组播报文，RPF检查失败，报文被丢弃。Assert过程结束。 PIM SM RP介绍： 汇聚点RP（Rendezvous Point）为网络中一台重要的PIM路由器，用于处理源端DR注册信息及组成员加入 请求，网络中的所有PIM路由器都必须知道RP的地址，类似于一个供求信息的汇聚中心。 • 目前可以通过以下方式配置RP： ▫ 静态RP：在网络中的所有PIM路由器上配置相同的RP地址，静态指定RP的位置。 ▫ 动态RP：通过选举机制在多个C-RP（Candidate-RP，候选RP）之间选举出RP。 • PIM-SM（ASM）模式首次形成组播分发树主要依赖RPT构建机制，组播源注册机制与DR选举机制。 ▫ RPT构建机制：组播叶子路由器主动建立到RP的组播分发树（RPT） ▫ 组播源注册机制：通过该机制形成组播源到RP的组播分发树（SPT） ▫ DR选举机制：DR负责源端或组成员端组播报文的收发，避免重复组播报文，同时成员端DR还负责发送Join加组消息。 • 当组播分发树（SPT或RPT）稳定后，成员端DR会周期性发送Join&#x2F;Prune报文，用于维护组播分发树。 • 如果组播在一段时间后（默认210s）没有流量则SPT树会消失，成员端DR恢复到RP的RPT树。 PIM（SSM） • PIM-SM（SSM）无需Assert机制","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"IGMP","slug":"IGMP","permalink":"http://example.com/tags/IGMP/"},{"name":"PIM","slug":"PIM","permalink":"http://example.com/tags/PIM/"}]},{"title":"STP拓扑变更机制","slug":"STP拓扑变更机制","date":"2024-05-08T12:28:37.000Z","updated":"2024-05-08T12:57:02.129Z","comments":true,"path":"2024/05/08/STP拓扑变更机制/","permalink":"http://example.com/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/","excerpt":"","text":"为什么要有STP拓扑变化机制网络中发生拓扑变化时，例如链路中断或接口异常Down等情况，由于MAC地址老化时间的存在（缺省为5分钟），如果不及时通知上游设备，则可能会导致上游设备的报文在这段时间内一直向一个不可达的链路发送。 拓扑改变导致MAC地址表错误 本例中，SW3中的MAC地址表项定义了通过端口GigabitEthernet 0&#x2F;0&#x2F;2可以到达主机1，通过端口GigabitEthernet 0&#x2F;0&#x2F;3可以到达主机2。由于SW2的根端口产生故障，导致生成树拓扑重新收敛，在生成树拓扑完成收敛之后，从主机1到主机2的帧仍然不能到达目的地。这是因为MAC地址表项老化时间是300秒，主机2发往主机1的帧到达SW3后，SW3会继续通过端口GigabitEthernet 0&#x2F;0&#x2F;2转发该数据帧。那么该怎么快速恢复转发？ 拓扑变更以及MAC地址表项更新的具体过程如下： SW2感知到网络拓扑发生变化后，会立即向SW3发送TCN BPDU报文。SW3收到SW2发来的TCN BPDU报文后，会把配置BPDU报文中的Flags的TCA位设置1，然后发送给SW2，告知SW2我已经收到你发送的TCN BPDU。SW3向根桥转发TCN BPDU报文。SW1把配置BPDU报文中的Flags的TC位和TCA位设置为1后发送，通知下游设备我已经收到你发送的TCN BPDU，并通知下游交换机把MAC地址表项的老化时间由默认的300 s修改为Forward Delay的时间（默认为15 s），之后会持续不断的发送TC bit &#x3D; 1的BPDU持续35s。最多等待15 s之后，SW3中的错误MAC地址表项会被自动清除。此后，SW3就能重新开始MAC表项的学习及转发操作。 说明： TCN BPDU报文主要用来向上游设备乃至根桥通知拓扑变化。 TCA标记置位的配置BPDU报文主要是上游设备用来告知下游设备已经知道拓扑变化，通知下游设备停止发送TCN BPDU报文。 置位的TC标记的配置BPDU报文主要是上游设备用来告知下游设备拓扑发生变化，请下游设备直接删除桥MAC地址表项，从而达到快速收敛的目的。 感知拓扑改变什么情况下STP会感知到拓扑发生了改变呢？有下面四种！ （1）当DP端口进入到Forwarding状态认为拓扑发生了改变。 如上图当S2的g0&#x2F;0&#x2F;3接口(与主机直接相连的接口都是DP端口)经过大概30s进入到Forwarding状态之后，S2的RP端口会立即向根桥发送一个TCN BPDU告知根桥拓扑发生了改变，根桥也会向S2交换机回复一个TC bit &#x3D; 1和TCA bit &#x3D; 1的BPDU，并且根桥会将TC bit &#x3D; 1的报文泛洪到全网交换机，持续35s。 S3的DP接口从shutdown重新进入到Forwarding状态与此情况类似。 （2）根桥的DP失效直接发送TC BPDU。 如上图，当根桥的DP失效之后，S3交换机的RP也随即失效，DP立即成为RP并向S2的AP持续不断的发送TCN BPDU。当S2的AP经过大概30s进入到Forwarding状态之后会向S3的DP回复一个TCA bit &#x3D; 1的BPDU，告知S3我已收到你发送的TCN BPDU并且通过自己的RP将TCN BPDU发送给根桥，根桥也会向S2交换机回复一个TC bit &#x3D; 1和TCA bit &#x3D; 1的BPDU，并且根桥会将TC bit &#x3D; 1的报文泛洪到全网交换机持续35s。 (3)RP失效或者RP进入到Forwarding状态。 S3的RP失效其实等同于根桥的DP失效导致S3的RP失效。S2的RP失效等同于 1.拓扑改变导致MAC地址表错误。(4)非根桥的DP端口失效不认为拓扑发生了改变。 如上图两种情况，非根桥的DP失效都不会认为拓扑发生了改变。 总结：stp发生拓扑变更的条件：1、处于转发状态或者监听状态的端口过渡到阻塞状态，这个状态通常是链路故障2、处于未启用状态的端口进入转发状态，这个状态通常是增加了新的链路3、交换机从指定端口收到TCNBPDU报文。 stp缺点：1.收敛速度慢，故障切换时间太长（30-50秒）2.网络中大量主机频繁上下线，会导致TCN BPDU大量发送，导致Mac地址表不稳定 RSTP对STP的改进： RSTP对STP的改进： 通过端口角色的增补，简化了生成树协议的理解及部署； 端口状态的重新划分； 配置BPDU格式的改变，充分利用了STP协议报文中的Flag字段，明确了端口角色； 配置BPDU的处理发生变化； 快速收敛； 增加保护功能。 改进点1：端口角色的改进：RSTP的端口角色共有4种：根端口、指定端口、Alternate端口和Backup端口。 根端口和指定端口的作用同STP中定义，Alternate端口和Backup端口的描述如下： 从配置BPDU报文发送角度来看： Alternate端口就是由于学习到其它网桥发送的配置BPDU报文而阻塞的端口 Backup端口就是由于学习到自己发送的配置BPDU报文而阻塞的端口 从用户流量角度来看： Alternate端口提供了从指定桥到根的另一条可切换路径，作为根端口的备份端口 Backup端口作为指定端口的备份，提供了另一条从根桥到相应网段的备份通路 给一个RSTP域内所有端口分配角色的过程就是整个拓扑收敛的过程 改进点2：端口状态的改进RSTP的状态规范缩减为3种，根据端口是否转发用户流量和学习MAC地址来划分: Discarding状态：不转发用户流量也不学习MAC地址 Learning状态：不转发用户流量但是学习MAC地址 Forwarding状：既转发用户流量又学习MAC地址。 STP端口状态 RSTP端口状态 端口在拓扑中的角色 Forwarding Forwarding 包括根端口、指定端口 Learning Learning 包括根端口、指定端口 Listening Discarding 包括根端口、指定端口 Blocking Discarding 包括Alternate端口、Backup端口 Disabled Discarding 包括Disable端口 改进点3：配置BPDU - RST BPDURSTP的配置BPDU充分利用了STP报文中的Flag字段，明确了端口角色 除了保证和STP格式基本一致之外，RSTP作了如下变化： Type字段：配置BPDU类型不再是0而是2，所以运行STP的设备收到RSTP的配置BPDU时会丢弃 Flag字段：使用了原来保留的中间6位，这样改变的配置BPDU叫做RST BPDU RST BPDU报文格式：RST BPDU与STP配置BPDU报文格式不同点 BPDU类型，1 Byte，RST BPDU的类型值为0x02。 标志，1 Byte，包括： bit 7：TCA，表示拓扑变化确认； bit 6：Agreement，表示同意，用于P&#x2F;A机制； bit 5：Forwarding，表示转发状态； bit 4：Learning，表示学习状态； bit 3和bit 2：表示端口角色, 00表示未知端口, 01表示替代或备份端口, 10表示根端口, 11表示指定端口 bit 1：Proposal，表示提议，用于P&#x2F;A机制； bit 0：TC，表示拓扑变化。 改进点4：配置BPDU的处理RSTP对配置BPDU的发送方式进行了改进 在拓扑稳定后，无论非根桥设备是否接收到根桥传来的配置BPDU报文，非根桥设备仍然按照Hello Time规定的时间间隔发送配置BPDU，该行为完全由每台设备自主进行 更短的BPDU超时时间如果一个端口在超时时间（即三个周期，超时时间＝Hello Time×3）内没有收到上游设备发送过来的配置BPDU，那么该设备认为与此邻居之间的协商失败 STP需要先等待一个Max Age 处理次优BPDU当一个端口收到上游的指定桥发来的RST BPDU报文时，该端口会将自身缓存的RST BPDU与收到的RST BPDU进行比较如果该端口缓存的RST BPDU优于收到的RST BPDU，那么该端口会直接丢弃收到的RST BPDU，立即回应自身缓存的RST BPDU，从而加快收敛速度 STP： STP只有指定端口会立即处理次优BPDU，其他端口会忽略次优BPDU，等到Max Age计时器超时后，缓存的次优BPDU才会老化，然后发送自身更优的BPDU，进行新一轮的拓扑收敛。 RSTP： RSTP处理次优BPDU报文不再依赖于任何定时器，解决拓扑收敛，同时RSTP的任何端口角色都会处理次优BPDU，从而加快了拓扑收敛。 改进点5：快速收敛机制快速收敛机制： 如果网络中一个根端口失效，那么网络中最优的Alternate端口将成为根端口，进入Forwarding状态。因为通过这个Alternate端口连接的网段上必然有个指定端口可以通往根桥 如果网络中一指定端口失效，那么网络中最优的Backup端口将成为指定端口，进入Forwarding状态。因为Backup端口作为指定端口的备份，提供了另一条从根桥到相应网段的备份通路 ##### 边缘端口 (Edge Port)机制： 在RSTP里面，如果某一个端口位于整个网络的边缘，即不再与其他交换设备连接，而是直接与终端设备直连，这种端口可以设置为边缘端口 边缘端口不参与RSTP计算，可以由Discarding直接进入Forwarding状态，同时边缘端口的UP和Down，不会引起网络拓扑的变动 但是一旦边缘端口收到配置BPDU，就丧失了边缘端口属性，成为普通STP端口，并重新进行生成树计算，从而引起网络震荡 Proposal&#x2F;Agreement机制：简称P&#x2F;A机制，RSTP通过P&#x2F;A机制加快了上游端口进入Forwarding状态的速度。 当一个端口被选举成为指定端口之后,会先进入Discarding状态，再通过P&#x2F;A机制快速进入Forwarding状态 事实上对于STP，指定端口的选择可以很快完成，主要的速度瓶颈在于：为了避免环路，必须等待足够长的时间，使全网的端口状态全部确定，也就是说必须要等待至少一个Forward Delay所有端口才能进行转发。 而RSTP的主要目的就是消除这个瓶颈，通过阻塞自己的非根端口来保证不会出现环路。而使用P&#x2F;A机制加快了上游端口进入Forwarding状态的速度。 改进点6：拓扑变更机制在RSTP中检测拓扑是否发生变化只有一个标准：一个非边缘端口迁移到Forwarding状态。 一旦检测到拓扑发生变化，将进行如下处理： 为本交换设备的所有非边缘指定端口和根端口启动一个TC While Timer，该计时器值是Hello Time的两倍。在这个时间内，清空状态发生变化的端口上学习到的MAC地址。 同时，由非边缘指定端口和根端口向外发送RST BPDU，其中TC置位。一旦TC While Timer超时，则停止发送RST BPDU。 其他交换设备接收到RST BPDU后，清空所有端口（除了收到RST BPDU的端口和边缘端口）学习到MAC地址，然后也为自己所有的非边缘指定端口和根端口启动TC While Timer，重复上述过程。 如此，网络中就会产生RST BPDU的泛洪。 RSTP与STP的兼容 RSTP可以兼容STP：RSTP可以和STP互操作，但是此时会丧失快速收敛等RSTP优势。 当一个网段里既有运行STP的交换设备又有运行RSTP的交换设备，STP交换设备会忽略RSTP的BPDU 运行RSTP的交换设备在某端口上接收到运行STP的交换设备发出的配置BPDU，在两个Hello Time时间之后，便把自己的端口转换到STP工作模式，发送配置BPDU，从而实现了互操作。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"stp拓扑变更","slug":"stp拓扑变更","permalink":"http://example.com/tags/stp%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4/"}]},{"title":"PPP/PPPoE","slug":"PPP-PPPoE","date":"2024-05-02T07:23:54.000Z","updated":"2024-05-02T07:36:51.780Z","comments":true,"path":"2024/05/02/PPP-PPPoE/","permalink":"http://example.com/2024/05/02/PPP-PPPoE/","excerpt":"","text":"PPP（点到点协议 ），该协议支持认证（PAP、CHAP）、该协议中还包括LCP、NCP协议 PPP链路的建立有三个阶段的协商过程，链路层协商、认证协商（可选）和网络层协商。1）链路层协商：通过LCP报文进行链路参数协商，建立链路层连接。 链路层协议（LCP）协商的参数有MRU（最大接收单元）、认证方式（不认证、PAP、CHAP）、魔术字（检测是否有环路） 2）认证协商（可选）：通过链路建立阶段协商的认证方式进行链路认证。 3）网络层协商 ：通过NCP协商来选择和配置一个网络层协议并进行网络层参数协商。 PPP协商时接口状态的变化： 正常PPP链路建立需要经历链路建立阶段、认证阶段和网络层协商阶段，详细过程如下：通信双方开始建立PPP链路时，先进入到Establish阶段。在Establish阶段，进行LCP协商：协商通信双方的MRU（Maximum Receive Unit，最大接收单元）、认证方式和魔术字（Magic Number）等选项。协商成功后进入Opened状态，表示底层链路已建立。如果配置了认证，将进入Authenticate阶段。否则直接进入Network阶段。在Authenticate阶段，会根据连接建立阶段协商的认证方式进行链路认证。认证方式有两种：PAP和CHAP。如果认证成功，进入Network阶段，否则进入Terminate阶段，拆除链路，LCP状态转为Down。在Network阶段，PPP链路进行NCP协商。通过NCP协商来选择和配置一个网络层协议并进行网络层参数协商。最常见的NCP协议是IPCP，用来协商IP参数。在Terminate阶段，如果所有的资源都被释放，通信双方将回到Dead阶段。PPP运行过程中，可以随时中断连接，物理链路断开、认证失败、超时定时器时间到、管理员通过配置关闭连接等动作都可能导致链路进入Terminate阶段。 网络运营商如何对用户上网行为进行收费和控制 ？ 针对特定的数据包，就必须识别发送方的身份。 在以太网链路上，以太网技术虽然具有简单易用，成本低等特点，但是以太网广播网络的属性，使得其通信双方无法相互验证对方的身份，因而通信是不安全的。 在PPP链路上，由于PPP协议自带认证功能，因此可以完美的解决上述问题。但是，PPP链路又无法实现多用户上网的需求。 为了解决这个矛盾问题，解决用户上网行为管理和收费的问题，提出了将PPP数据帧封装在以太网数据帧里边从而在以太网网络中传输的技术——PPPoE技术。 这里的PPP，就是指的PPP协议数据帧，而o就是over的意思，E就是Ethernet的意思，因此，PPPoE形象的说就是“在以太网上的PPP协议”。 PPPoE技术可以将用户连接到远程接入设备上，并提供良好访问控制功能，提供了一种经济的用户接入技术，并实现了对用户的控制。 PPPoE协议采用Client&#x2F;Server模式，普通用户一般为Client，而运营商为Server。 PPPoE的建立分为Discover阶段和PPP Session阶段。 Discover阶段：主要是选择PPPoE服务器，并确定所要建立的会话标识符Session ID。 当Client要运行PPPoE时，首先以广播的形式发送一个PADI（PPPoE Active Discovery Initiation）报文，该报文中含有Client端要请求的服务信息 PPPoE服务器在收到该报文后，会以单播的方式发送一个PADO（PPPoE Active Discovery Offer）报文，对Client端的PADI报文进行回应。 PPPoE Client端在收到这个报文后，会向PPPoE Server发送PADR（PPPoE Active Discovery Request）报文。在这个报文中，PPPoE Client会创建并携带一个PPPoE Session。 PPPoE Server还会向客户端发送PADS（PPPoE Active Discovery Session-confirmation）报文，表示收到了该Session ID。 发送PADT（PPPOE Active Discovery Terminate）报文，终止连接 PPP Session阶段：即执行标准的PPP过程，包括LCP协商、PAP&#x2F;CHAP认证、NCP协商等阶段。 PPP会话阶段包括LCP协商、PAP&#x2F;CHAP认证、NCP协商等阶段。需结合PPP链路建立过程来分析","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"PPP","slug":"PPP","permalink":"http://example.com/tags/PPP/"},{"name":"PPPoE","slug":"PPPoE","permalink":"http://example.com/tags/PPPoE/"}]},{"title":"IS-IS总结","slug":"IS-IS总结","date":"2024-04-20T11:42:15.000Z","updated":"2024-04-20T11:44:43.093Z","comments":true,"path":"2024/04/20/IS-IS总结/","permalink":"http://example.com/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/","excerpt":"","text":"1、IS-IS的介绍 IS-IS —中间系统到中间系统 Is-is最开始是在osi模型中，适用于CLNP网络，现在的Isis指的是集成Isis 集成IS-IS特点:支持CLNP网络、IP网络采用数据链路层封装 OSPF特点:只支持IP网络采用IP报文封装 应用场景： ospf：园区网络 Isis：ISP骨干网 CLNP协议中不实用IP地址，使用的是NSAP地址 NET（Network Entity Title，网络实体名称）是OSI协议栈中设备的网络层信息，主要用于路由计算，由区域地址（Area ID）和System ID组成，可以看作是特殊的NSAP（SEL为00的NSAP）。NET的长度与NSAP的相同，最长为20Byte，最短为8Byte。在IP网络中运行IS-IS时，只需配置NET，根据NET地址设备可以获取到Area ID以及System ID。System ID必须唯一，类似ospf中的router id 2、IS-IS基本概念 1）IS-IS中路由器的分类 Leverl-1：只能和同区域的L1、L1&#x2F;2路由器建立L1的邻接关系，只能有本区域的L1 LSDB数据库 level-2：可以和同区域的或者不同 区域L2、L1&#x2F;2路由器建立L2的邻接关系，拥有L2的LSDB level1-2：可以 和同区域的L1路由器建立L1的邻接关系，也可以和同区域或者不同区域的L2路由器建立L2的邻接关系 2）Isis支持 的网络类型 广播和点到点 广播（Broadcast）： 如Ethernet。点到点（P2P）： 如PPP、 HDLC等。 3）Isis的开销值 IS-IS有三种方式来确定接口的开销，按照优先级由高到低分别是：接口开销：为单个接口设置开销。全局开销：为所有接口设置开销。自动计算开销：根据接口带宽自动计算开销。 3、IS-IS协议工作原理 工作原理：①建立邻接；②同步LSDB；③计算路由； 1）邻接建立 IS-IS按如下原则建立邻接关系：只有同一层次的相邻路由器才有可能成为邻接。对于Level-1路由器来说，Area ID必须一致。链路两端IS-IS接口的网络类型必须一致。链路两端IS-IS接口的地址必须处于同一网段（默认情况下）。 使用IIH（Isis hello ）：发现邻居；建立邻接关系；维护邻接关系， 广播网络：level-1 LAN IIH、level-2 LAN IIH、 Level-1 IIH和Level-2 IIH发送的组播地址分别为01-80-C2-00-00-14、01-80-C2-00-00-15。 点到点网络中：P2P IIH 广播类型： 点到点类型： 选举DIS： 在广播网络中，IS-IS需要在一个广播网络中的所有的路由器中选举一个路由器作为DIS（Designated Intermediate System）。DIS用来创建和更新伪节点（Pseudonodes），并负责生成伪节点的LSP，用来描述这个网络上有哪些网络设备。伪节点是用来模拟广播网络的一个虚拟节点，并非真实的路由器。在IS-IS中，伪节点用DIS的System ID和Circuit ID（非0值）标识。 Level-1和Level-2的DIS是分别选举的，用户可以为不同级别的DIS选举设置不同的优先级。 DIS选举原则： ①优先级：0-127 默认64，越大越优，优先级0也参与选举 ②MAC地址：越大越优 DIS发送Hello PDU的时间间隔是普通路由器的1&#x2F;3，这样可以确保DIS出现故障时能够被更快速地被发现。 IS-IS中DIS与OSPF协议中DR（Designated Router）的区别：在IS-IS广播网中，优先级为0的路由器也参与DIS的选举，而在OSPF中优先级为0的路由器则不参与DR的选举。在IS-IS广播网中，当有新的路由器加入，并符合成为DIS的条件时，这个路由器会被选中成为新的DIS，原有的伪节点被删除。此更改会引起一组新的LSP泛洪。而在OSPF中，当一台新路由器加入后，即使它的DR优先级值最大，也不会立即成为该网段中的DR。—-ISis中的DIS支持抢占，ospf中的DR和BDR不支持抢占在IS-IS广播网中，同一网段上的同一级别的路由器之间都会形成邻接关系，包括所有的非DIS路由器之间也会形成邻接关系。而在OSPF中，路由器只与DR和BDR建立邻接关系。 —Isis中建立的都是邻接的关系 2）同步链路状态数据库 L1和L2分别有自己的LSDB LSDB中包含的就是LSP，LSP描述路由器的链路状态信息 display isis lsdb Database information for ISIS(1)Level-1 Link State DatabaseLSPID Seq Num Checksum Holdtime Length ATT&#x2F;P&#x2F;OL-——————————————————————————————–0100.0000.1001.00-00* 0x00000005 0x13a8 1187 97 0&#x2F;0&#x2F;00100.0000.1001.01-00* 0x00000001 0xda2e 1185 55 0&#x2F;0&#x2F;00100.0000.2002.00-00 0x00000004 0x94e9 1188 86 1&#x2F;0&#x2F;0Total LSP(s): 5 (In TLV)-Leaking Route, (By LSPID)-Self LSP, +-Self LSP(Extended), ATT-Attached, P-Partition, OL-Overload0100.0000.1001（路由器的系统ID）.00（实节点还是伪节点，00表示实节点，非0表示伪节点）-00（LSP分片）（表示是本路由器产生的） 3）Isis路由计算 ①L1的路由器只能通过L1的LSBD计算学习到L1的路由 —只有L1邻接关系的路由 ②L2的路由器维护L2的LSDB，但是可以学习所有的路由，包括L1和L2的路由—全网路由 ③L1&#x2F;2会向L1区域下发一条L1的缺省路由，L1可以通过该缺省路由到达L2 ④路由渗透：将L2路由在L1&#x2F;2路由器上进行引入，让L1路由器可以学习到L2的明细路由 [R2-isis-1]import-route isis level-2 into level-1 4、IS-IS协议的报文 ospf–Isis报文的对应 Hello —&gt;IIH DD —&gt;CSNP LSR —&gt;PSNP LSU —&gt;LSP LSACK —&gt;PSNP LSA —&gt;LSP 根据报文的种类，认证可以分为以下三类：接口认证：在接口视图下配置，对Level-1和Level-2的Hello报文进行认证。区域认证：在IS-IS进程视图下配置，对Level-1的CSNP、PSNP和LSP报文进行认证。路由域认证：在IS-IS进程视图下配置，对Level-2的CSNP、PSNP和LSP报文进行认证。 根据报文的认证方式，可以分为以下四类：简单认证：将配置的密码直接加入报文中，这种加密方式安全性较其他两种方式低。MD5认证：通过将配置的密码进行MD5算法加密之后再加入报文中，提高密码的安全性。Keychian认证：通过配置随时间变化的密码链表来进一步提升网络的安全性。HMAC-SHA256认证：通过将配置的密码进行HMAC-SHA256算法加密之后再加入报文中，提高密码的安全性。 5、IS-IS协议配置 [r1]isis 进入Isis进程，默认进程1 [r1-isis-1]network-entity 49.0001.0000.0000.0001.00 配置NET地址，其中system id必须唯一 [r1-isis-1]is-level level-1 修改路由的级别，默认为L1&#x2F;2路由器 [R2-GigabitEthernet0&#x2F;0&#x2F;0]isis enable 100 宣告网段进入Isis进程100 [R2-isis-1]is-name R2 将system id用name表示 [R2-GigabitEthernet0&#x2F;0&#x2F;1]isis circuit-level level-2 修改接口的链路级别 [r1-GigabitEthernet0&#x2F;0&#x2F;0]isis circuit-type p2p 修改接口的链路类型 [R2-GigabitEthernet0&#x2F;0&#x2F;2]isis dis-priority 127 level-2 修改接口的优先级，影响DIS的选举，可以只针对某个level进行更改 查看命令 Display isis peer 查看Isis邻居 Display Isis interface 查看DIS的选举、 Display Isis route 查看Isis路由","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"IS-IS","slug":"IS-IS","permalink":"http://example.com/tags/IS-IS/"}]},{"title":"opsf总结","slug":"opsf总结","date":"2024-04-18T12:24:37.000Z","updated":"2024-04-18T13:12:52.653Z","comments":true,"path":"2024/04/18/opsf总结/","permalink":"http://example.com/2024/04/18/opsf%E6%80%BB%E7%BB%93/","excerpt":"","text":"ospf协议工作原理工作过程：①建立邻居关系（hello 2-way状态）每台路由器都会产生lsa，路由器将接收到的lsa放入自己的lsdb中；②同步LSDB（DD、LSR、LSU、LSACK full状态）；③计算路由（本路由器通过自己的LSDB，以自己为根节点，计算最短路径树，最终得到路由）SPF算法； ospf支持的网络类型：广播、NBMA、点到点、点到多点 ospf计算；计算路由+计算拓扑 ospf报文采用IP封装，协议号89， ospfv2（ipv4），ospfv3（ipv6） ospf组播更新 224.0.0.5（所有运行ospf协议的路由器侦听） 224.0.0.6（DR和BDR侦听） Router id在自治系统中唯一标识一台运行ospf的路由器，32位无符号整数 选举规则：手动配置（建议），如果没有手动配置，则路由器使用Loopback接口中最大的IP地址作为Router id，如果没有配置Loopback接口，则使用物理接口中最大的IP地址 Cost值缺省接口cost&#x3D;（100mib&#x2F;s）&#x2F; 接口带宽，修改100mid&#x2F;s改变cost 也可以直接修改 累计cost作为开销值，流量从源网络到目的网络所经过所有路由器的出接口的cost总和 Hello报文 发送间隔10s，失效40s，修改发送，失效也变，失效始终为发送的4倍 命令：接口视图下，ospf timer hello 10 ospf邻居建立失败 ，可能原因：①物理链路故障；②ospf版本不一致；③区域ID不一致；④认证类型不一致；⑤认证数据不一致；⑥掩码不一致；（只出现在广播型网络中，点到点网络不检查掩码信息）⑦hello报文间隔不一致；⑧router id一致；（华为设备遇到router id一致，会重新配置router id） DD报文DD报文部分字段解释I：当发送连续多个DD报文时，如果这是第一个DD报文，则置为1，否则置为0。M (More)：当发送连续多个DD报文时，如果这是最后一个DD报文，则置为0。否则置为1，表示后面还有其他的DD报文。MS (Master&#x2F;Slave)：当两台OSPF路由器交换DD报文时，首先需要确定双方的主从关系，Router ID大的一方会成为Master。当值为1时表示发送方为Master。DD sequence number：DD报文序列号。主从双方利用序列号来保证DD报文传输的可靠性和完整性。 链路状态类型、链路状态ID、通告路由器三元组唯一地标识了一个LSA。链路状态老化时间 、链路状态序列号 、校验和用于判断LSA的新旧 ospf状态机之前的手写笔记😍 DR和BDR既侦听224.0.0.5也侦听224.0.0.6 每个网段选举一个 DR：指定路由器，负责在MA网络中建立和维护邻接关系，并负责lsa同步 DR和其他所有路由器形成邻接关系，其他路由器之间不直接交换链路状态信息 在DR失效时候，BDR接替 DR默认优先级1（0-255）越大越优，非抢占，优先级为0的不参与选举 Router LSA（1类）单区域中会用到1类、2类LSA Router LSA—1类LSA 所有的路由器都会产生，描述本路由器的信息 泛洪区域：本区域 Router LSA使用Link来承载路由器直连接口的信息。每条Link均包含“链路类型”、“链路ID”、“链路数据”以及“度量值”这几个关键信息。路由器可能会采用一个或者多个Link来描述某个接口。 广播型网络中链路类型：TransNet 点到点网络中链路类型：point-to-point （拓扑信息）、stubnet（网络信息） Router LSA中链路状态类型、链路状态ID、通告路由器用谁表示： 链路状态类型：router 链路状态ID：本路由器的router id 通告路由器：本路由 Network LSA（2类）Network LSA–2类LSA DR路由器 泛洪区域：本区域 Network LSA中链路状态类型、链路状态ID、通告路由器用谁表示： 链路状态类型：network 链路状态ID：DR路由器的接口IP地址 通告路由器：DR路由器的router id Network LSA（3类）3类LSA ABR产生，泛洪范围本区域 作用：用于向一个区域通告到达另一个区域的路由 区域间防环： 1）非骨干区必须和骨干区area0相连，非骨干区不能直接进行通信 2）三类LSA传递是 单向的 3）从非骨干区域收到的3类LSA不能用于区域间路由的计算。 AS External LSA（5类）AS-external LSA（5类LSA）：由ASBR产生，描述到达AS外部的路由，该LSA会被通告到所有的区域 LS Type：取值5，代表AS-external-LSA。Link State ID：外部路由的目的网络地址。Advertising Router：生成该LSA的Router ID。Network Mask：网络掩码。 ASBR-Summary LSA（4类）ASBR-Summary LSA（4类LSA）：由ABR产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。 LS Type：取值4，代表ASBR-Summary LSA。Link State ID ：ASBR的Router ID。Advertising Router:生成LSA的Router ID。 ospf外部路由在引入时，开销值类型有两种：默认情况是type-2 配置：[R7-ospf-1]import-route direct type 1 OSPF路由遵循以下优先级顺序，区域内路由&gt;区域间路由&gt;Metric-Type-1外部路由&gt;Metric-Type-2外部路由。 ospf路由汇总OSPF路由汇总的类型：在ABR执行路由汇总：对区域间的路由执行路由汇总。在ASBR执行路由汇总：对引入的外部路由执行路由汇总。 区域间路由汇总在ABR设备上配置： [R6-ospf-1-area-0.0.0.3]abr-summary 172.16.0.0 255.255.252.0 外部路由汇总在ASBR上配置： [R8-ospf-1]asbr-summary 10.1.0.0 255.255.240.0 ospf认证OSPF支持报文认证功能，只有通过认证的OSPF报文才能被接收。路由器支持两种OSPF报文认证方式，当两种认证方式都存在时，优先使用接口认证方式：区域认证方式：一个OSPF区域中所有的路由器在该区域下的认证模式和口令必须一致。 [R6-ospf-1-area-0.0.0.3]authentication-mode md5 1 cipher huawei 该区域中所有路由器都要配置接口认证方式：相邻路由器直连接口下的认证模式和口令必须一致。[R2-GigabitEthernet0&#x2F;0&#x2F;0]ospf authentication-mode md5 1 cipher huawei 在一条链路上的所有接口下配置 stub区域1、2、3、3类缺省LSA（ABR产生的） Stub区域的ABR不向Stub区域内传播它接收到的AS外部路由（也就是4类、5类LSA），Stub区域中路由器的LSDB、路由表规模都会大大减小。为保证Stub区域能够到达AS外部，Stub区域的ABR将生成一条缺省路由（使用3类LSA描述）。 配置Stub区域时需要注意下列几点：骨干区域不能被配置为Stub区域。Stub区域中的所有路由器都必须将该区域配置为Stub。Stub区域内不能引入也不接收AS外部路由。虚连接不能穿越Stub区域。 Totally Stub区域1、2、3类缺省LSA（ABR产生的） Totally Stub区域既不允许AS外部路由在本区域内传播，也不允许区域间路由在本区域内传播。Totally Stub区域内的路由器通过本区域ABR下发的缺省路由（使用3类LSA描述）到达其他区域，以及AS外部配置Totally Stub区域时需要注意：与Stub区域配置的区别在于，在ABR上需要追加no-summary关键字。 NSSA1、2、3、7类、7类缺省LSA（ABR产生的） NSSA区域 相对于stub区别在于，可以引入外部路由，外部路由引入后，会以7类LSA在NSSA区域中泛洪，然后 在ABR设备上将7类LSA转化成5类LSA在其他区域 泛洪 Totally NSSA：1、2、3缺省（ABR产生）、7类、7类缺省LSA（ABR产生的） Silent-InterfaceSilent-Interface有以下特性：Silent-Interface不会接收和发送OSPF报文。Silent-Interface的直连路由仍可以发布出去。 通常我们会 将连接终端或者服务器的接口设置成Silent-Interface [R1]ospf[R1-ospf-1]area 0[R1-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255[R1-ospf-1]silent-interface GigabitEthernet 0&#x2F;0&#x2F;1 路由器对lsa处理流程","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"ospf","slug":"ospf","permalink":"http://example.com/tags/ospf/"}]},{"title":"交换机工作原理","slug":"交换机工作原理","date":"2024-03-29T17:08:49.000Z","updated":"2024-03-29T17:15:35.603Z","comments":true,"path":"2024/03/30/交换机工作原理/","permalink":"http://example.com/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"交换机工作原理","slug":"交换机工作原理","permalink":"http://example.com/tags/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}]},{"title":"子网划分","slug":"子网划分","date":"2024-03-23T16:39:44.000Z","updated":"2024-03-23T17:25:29.504Z","comments":true,"path":"2024/03/24/子网划分/","permalink":"http://example.com/2024/03/24/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/","excerpt":"","text":"子网划分首先为什么要子网划分？ 有类IP地址规划的缺陷：使用默认掩码的问题：地址范围过大或过小，导致IP地址的浪费！ 在一个网络地址中，主机数：2的n次方，可用的主机数：2*n-2（这里n是主机数） 如果这个网段只用于一个小型局域网，例如一个实验室，只有几十台主机，那么大大浪费了ip地址 所以，子网划分给这个网络地址分成若干个，减少浪费 相当于把主机数均匀的分配给若干个（网络号借位，主机号减少） 例如网络地址：192.168.1.0&#x2F;24，网络号24位，主机号8位，如果划成两个子网，网络号借1位 借的1位是1或者是0 192.168.1.00000000（前25位变成网络号）子网1：192.168.1.0&#x2F;25 192.168.1.10000000 子网2：192.168.128.0&#x2F;25 例：192.168.1.0 分配三个部门，每个部门30台主机 要借2位 00 01 10 11 这四种排列组合，分为四个子网 192.168.1.00 000000 –192.168.1.0&#x2F;26 192.168.1.01 000000 –192.168.1.64&#x2F;26 192.168.1.10 000000 –192.168.1.128&#x2F;26 192.168.1.11 000000 –192.168.1.192&#x2F;26 子网划分的原理 IP地址由网络位+主机位组成，子网划分就是借用现有网段的主机位的最左边某几位作为子网位，划分出多个子网。 ①把原来有类网络IPv4地址中的“网络号”部分向“主机号”部分借位 ②把一部分原来属于“主机号”部分的位变成“网络号”的一部分（通常称之为“子网号”）。 因此IP地址进行转变：网络号+主机号 变成 网络号+子网号（m）+主机号（n） 划分后子网数量：2*m 划分后每个子网可用主机数：2*n-2（主机号全为0和全为1（指二进制）的ip地址分别为网络地址与广播地址，是不能分配给某个特定的主机使用的） 子网划分的步骤 ① 确定所需子网数2*m， ② 确定每个子网可用主机数2*n-2 ③ 确定需像主机号部分借多少位（m），才能满足需要求 ④ 根据主机数可得知子网地址空间大小2*n ⑤ 进行地址划分 子网划分示例 某公司有四个部门，每个部门拥有50台主机，分配一个C类地址200.161.30.0&#x2F;24,请问如何进行网络地址规划？ a.确定子网数：四个部门，2*m&gt;&#x3D;4 b.确定主机数：30台主机，2*n-2&gt;&#x3D;30 c.C类地址网络号位24位，主机位8位，向第四段主机位借位，由上可知子网位m&#x3D;2，主机位n&#x3D;6 d.子网空间为64，子网数为4，根据原主机位八位则原网络空间为0-255，共256个，此时我们算出子网空间为64，可得出四个子网范围0-63、64-127、127-192、192-255 e. 第一个子网200.161.30.0&#x2F;26-200.161.30.63&#x2F;26 第二个子网200.161.30.64&#x2F;26-200.161.30.127&#x2F;26 第三个子网200.161.30.128&#x2F;26-200.161.30.191&#x2F;26 第四个子网200.161.39.192&#x2F;26-200.161.30.255&#x2F;26 f.主机位全为0和1的地址分别为网络地址与广播地址，不能分配给主机使用，则 部门1地址范围：200.161.30.1-62&#x2F;26 部门2地址范围：200.161.30.65-12&#x2F;26 部门3地址范围：200.161.30.129-190&#x2F;26 部门4地址范围：200.161.30.193-254&#x2F;26","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"子网划分","slug":"子网划分","permalink":"http://example.com/tags/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/"}]},{"title":"WLAN基础配置（ap上线）","slug":"WLAN基础配置（ap上线）","date":"2023-12-20T10:17:25.000Z","updated":"2023-12-20T10:27:08.822Z","comments":true,"path":"2023/12/20/WLAN基础配置（ap上线）/","permalink":"http://example.com/2023/12/20/WLAN%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%EF%BC%88ap%E4%B8%8A%E7%BA%BF%EF%BC%89/","excerpt":"","text":"概念CAPWAP协议CAPWAP是基于UDP进行传输的应用层协议，CAPWAP协议在传输层运输两种类型的消息： 业务数据流量，封装转发无线数据帧 。——通过CAPWAP数据隧道。 管理流量，管理AP和AC之间交换的管理消息 。——通过CAPWAP控制隧道。 CAPWAP数据和控制报文基于不同的UDP端口发送： 管理流量端口为UDP端口5246。 业务数据流量端口为UDP端口5247。 AC连接方式直连模式下AC部署在用户的转发路径上，采用这种组网方式，对AC的吞吐量以及处理数据能力要求比较高，否则AC会是整个无线网络带宽的瓶颈。但用此种组网，组网架构清晰，组网实施起来简单 在旁挂式组网中，AC只承载对AP的管理功能，管理流封装在CAPWAP隧道中传输。数据业务流可以通过CAPWAP数据隧道经AC转发，也可以不经过AC转发直接转发，后者无线用户业务流经汇聚交换机由汇聚交换机传输至上层网络。 WLAN的基本概念 BSS：一个AP所覆盖的范围，在一个BSS的服务区域内，STA可以相互通信。 BSSID：是无线网络的一个身份标识，用AP的MAC地址表示。 SSID：表示无线网络的标识，用来区分不同的无线网络。例如，当我们在笔记本电脑上搜索可接入无线网络时，显示出来的网络名称就是SSID。 VAP早期的AP只支持1个BSS，如果要在同一空间内部署多个BSS，则需要安放多个AP，这不但增加了成本，还占用了信道资源。为了改善这种状况，现在的AP通常支持创建出多个虚拟AP (Virtual Access Point, VAP)。如图16-13所示，它相当于交换机中的VLAN ESS 为了满足实际业务的需求，需要对BSS的覆盖范围进行扩展。同时用户从一个BSS移动到另一个BSS时，不能感知到SSID的变化，则可以通过扩展服务集ESS (Extend Service Set)实现。如图6-14所示，这是由多个使用相同SSID的BSS组成，是采用相同的SSID的多个BSS组成的更大规模的虚拟BSS。 实验 实验步骤 步骤1：基本配置LSW2的配置system-view[Huawei]undo info-center enable[Huawei]sysname LSW2[LSW2]vlan 100[LSW2-vlan100]quit[LSW2]interface e0&#x2F;0&#x2F;1[LSW2-Ethernet0&#x2F;0&#x2F;1]port link-type trunk[LSW2-Ethernet0&#x2F;0&#x2F;1]port trunk allow-pass vlan 100[LSW2-Ethernet0&#x2F;0&#x2F;1]port trunk pvid vlan 100[LSW2-Ethernet0&#x2F;0&#x2F;1]quit[LSW2]interface e0&#x2F;0&#x2F;2[LSW2-Ethernet0&#x2F;0&#x2F;2]port link-type trunk[LSW2-Ethernet0&#x2F;0&#x2F;2]port trunk allow-pass vlan 100[LSW2-Ethernet0&#x2F;0&#x2F;2]port trunk pvid vlan 100[LSW2-Ethernet0&#x2F;0&#x2F;2]quit[LSW2]interface e0&#x2F;0&#x2F;3[LSW2-Ethernet0&#x2F;0&#x2F;3]port link-type trunk[LSW2-Ethernet0&#x2F;0&#x2F;3]port trunk allow-pass vlan 100[LSW2-Ethernet0&#x2F;0&#x2F;3]quit【思考1】：为什么LSW2只创建VLAN100，不用创建VLAN101？解析：因为我们用的是隧道转发，数据到达AC1后，才会打上101标记然后发给LSW1【思考2】：为什么连接AP的接口要打port trunk pvid vlan 100?解析：交换机收到AP的数据帧打上100的tag发送把带上100tag的数据帧去掉然后发给APLSW1的配置system-view[Huawei]undo info-center enable[Huawei]sysname LSW1[LSW1]vlan batch 100 101[LSW1]interface g0&#x2F;0&#x2F;1[LSW1-GigabitEthernet0&#x2F;0&#x2F;1]port link-type trunk[LSW1-GigabitEthernet0&#x2F;0&#x2F;1]port trunk allow-pass vlan 100[LSW1-GigabitEthernet0&#x2F;0&#x2F;1]quit[LSW1]interface g0&#x2F;0&#x2F;3[LSW1-GigabitEthernet0&#x2F;0&#x2F;3]port link-type trunk[LSW1-GigabitEthernet0&#x2F;0&#x2F;3]port trunk allow-pass vlan 100 101[LSW1-GigabitEthernet0&#x2F;0&#x2F;3]quit[LSW1]interface g0&#x2F;0&#x2F;2[LSW1-GigabitEthernet0&#x2F;0&#x2F;2]port link-type access[LSW1-GigabitEthernet0&#x2F;0&#x2F;2]port default vlan 101[LSW1-GigabitEthernet0&#x2F;0&#x2F;2]quit[LSW1]interface Vlanif 101[LSW1-Vlanif101]ip address 192.168.101.1 24[LSW1-Vlanif101]undo shutdown[LSW1-Vlanif101]quitAC1的配置system-view[AC6005]undo info-center enable[AC6005]sysname AC1[AC1]vlan batch 100 101[AC1]interface g0&#x2F;0&#x2F;1[AC1-GigabitEthernet0&#x2F;0&#x2F;1]port link-type trunk[AC1-GigabitEthernet0&#x2F;0&#x2F;1]port trunk allow-pass vlan 100 101[AC1-GigabitEthernet0&#x2F;0&#x2F;1]quit[AC1]interface Vlanif 100[AC1-Vlanif100]ip address 192.168.100.1 24[AC1-Vlanif100]undo shutdown[AC1-Vlanif100]quitR1的配置system-view[Huawei]undo info-center enable[Huawei]sysname R1[R1]interface g0&#x2F;0&#x2F;0[R1-GigabitEthernet0&#x2F;0&#x2F;0]ip address 192.168.101.2 24[R1-GigabitEthernet0&#x2F;0&#x2F;0]undo shutdown[R1-GigabitEthernet0&#x2F;0&#x2F;0]quit 步骤2：设置DHCP创建VLAN设置TRUNK业务DHCP-让STA获得IP地址[LSW1]dhcp enable[LSW1]interface Vlanif 101[LSW1-Vlanif101]dhcp select interface[LSW1-Vlanif101]quit管理DHCP-让AP获得IP地址system-view[AC1]dhcp enable[AC1]interface Vlanif 100[AC1-Vlanif100]dhcp select interface[AC1-Vlanif100]quit 步骤3：AC的配置 AP上线第一步：创建AP组system-view[AC1]wlan[AC1-wlan-view]ap-group name x &#x2F;&#x2F;创建AP组名字叫x[AC1-wlan-ap-group-x]quit第二步：创建域管理模板并关联到AP组[AC1]wlan[AC1-wlan-view]regulatory-domain-profile name x1 &#x2F;&#x2F;创建域管理模板，名字叫x1[AC1-wlan-regulate-domain-x1]country-code cn &#x2F;&#x2F;国家代码选择中国[AC1-wlan-regulate-domain-x1]quit[AC1-wlan-view]ap-group name x[AC1-wlan-ap-group-x]regulatory-domain-profile x1 &#x2F;&#x2F;AP组的域管理模板是x1Warning: Modifying the country code will clear channel, power and antenna gain configurations of the radio and reset the AP. Continue?[Y&#x2F;N]:y[AC1-wlan-ap-group-x]quit第三步：配置AC的接口源地址[AC1]capwap source interface Vlanif 100 &#x2F;&#x2F;AC的接口源地址为VLAN100第四步：离线导入AP[AC1]wlan[AC1-wlan-view]ap auth-mode mac-auth &#x2F;&#x2F;AP的认证模式为MAC认证[AC1-wlan-view]ap-id 1 ap-mac 00e0-fcd5-1c70 &#x2F;&#x2F;AP的编号和MAC地址[AC1-wlan-ap-1]ap-name ds &#x2F;&#x2F;AP的名字为ds[AC1-wlan-ap-1]ap-group x &#x2F;&#x2F;AP属于AP组x[AC1-wlan-view]ap-id 2 ap-mac 00e0-fc1e-3670 &#x2F;&#x2F;AP的编号和MAC地址[AC1-wlan-ap-2]ap-name xs &#x2F;&#x2F;Ap的名字[AC1-wlan-ap-2]ap-group x &#x2F;&#x2F;AP属于AP组xWarning: This operation may cause AP reset. If the country code changes, it willclear channel, power and antenna gain configurations of the radio, Whether to continue? [Y&#x2F;N]:y思考：AP的MAC地址是怎么知道的？读者可以通过在ap上使用命令“display interface Vlanif 1”查看当前ap的mac地址，然后再将mac地址进行绑定。查看命令：[AC1]display ap allInfo: This operation may take a few seconds. Please wait for a moment.done.Total AP information:nor : normal [2]-—————————————————————————————–ID MAC Name Group IP Type State STA Uptime-—————————————————————————————–1 00e0-fcd5-1c70 ds x 192.168.100.137 AP2050DN nor 0 11M:2S2 00e0-fc1e-3670 xs x 192.168.100.42 AP2050DN nor 0 54S-—————————————————————————————–可以看到两个AP都获取了IP地址，思考：以上过程一共几包？AP获取IP地址4个包：discovery、offer、request、ackCAPWAP的建立2个包：discovery request(udp 目的端口5246广播找AC) discovery response(单播回应AP)AP接入控制2个包：join request(udp 5246端口 单播) join response隧道维持2个包：数据隧道：keepalive(udp 5247) 控制隧道：echo(udp 5246) 配置VLAN业务参数第一步：创建安全模板[AC1]wlan[AC1-wlan-view]security-profile name y1 &#x2F;&#x2F;安全模板的名字叫y1[AC1-wlan-sec-prof-y1]security wpa-wpa2 psk pass-phrase huawei@123 aes &#x2F;&#x2F;密码是huawei@123，用AES加密。[AC1-wlan-sec-prof-y1]quit第二步：创建SSID模板[AC1]wlan[AC1-wlan-view]ssid-profile name y2 &#x2F;&#x2F;ssid的模板名字叫y2[AC1-wlan-ssid-prof-y2]ssid hcia &#x2F;&#x2F;ssid的名称叫hcia[AC1-wlan-ssid-prof-y2]quit[AC1-wlan-view]quit第三步：创建VAP模板[AC1]wlan[AC1-wlan-view]vap-profile name y &#x2F;&#x2F;vap模板的名字叫y[AC1-wlan-vap-prof-y]forward-mode tunnel &#x2F;&#x2F;转发模式为隧道[AC1-wlan-vap-prof-y]service-vlan vlan-id 101 &#x2F;&#x2F;服务的VLAN为101[AC1-wlan-vap-prof-y]security-profile y1 &#x2F;&#x2F;调用安全模板y1[AC1-wlan-vap-prof-y]ssid-profile y2 &#x2F;&#x2F;调用SSID模板y2[AC1-wlan-vap-prof-y]quit第四步：在AP组里面调用VAP模板[AC1-wlan-view]ap-group name x[AC1-wlan-ap-group-x]vap-profile y wlan 1 radio 0 &#x2F;&#x2F;调用VAP模板y[AC1-wlan-ap-group-x]vap-profile y wlan 1 radio 1 &#x2F;&#x2F;思考：radio0 1 2 是什么意思？思考：这相过程要几个包？WLAN业务配置下发2个包：Configuration Update Request Configuration Update Response STA接入，可以看到有两个ssid为hcia的无线网络，在之前的配置中配置了radio 0 、1就是为了释放两个不同的射频信号，选择其中一个，输入之前创建的密码huawei@123","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"ap上线","slug":"ap上线","permalink":"http://example.com/tags/ap%E4%B8%8A%E7%BA%BF/"},{"name":"wlan","slug":"wlan","permalink":"http://example.com/tags/wlan/"}]},{"title":"USG5500防火墙基础实验","slug":"USG5500防火墙基础实验","date":"2023-12-08T09:52:30.000Z","updated":"2023-12-08T10:57:14.753Z","comments":true,"path":"2023/12/08/USG5500防火墙基础实验/","permalink":"http://example.com/2023/12/08/USG5500%E9%98%B2%E7%81%AB%E5%A2%99%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"基础配置 1、本实验中的防火墙为USG5500系列防火墙； 2、 防火墙三个接口的IP地址按照上图所示进行配置；将这三个接口划入相应的安全域； 3、配置防火墙的域间包过滤策略，使得PC1能够主动访问PC2，但是PC2无法主动访问PC1；PC2能够主动访问WebServer的WEB服务。 防火墙配置： [FW] interface GigabitEthernet0&#x2F;0&#x2F;1 [FW-GigabitEthernet0&#x2F;0&#x2F;1] ip address 192.168.1.254 24 [FW] interface GigabitEthernet0&#x2F;0&#x2F;2 [FW-GigabitEthernet0&#x2F;0&#x2F;2] ip address 172.16.1.254 24 [FW] interface GigabitEthernet0&#x2F;0&#x2F;3 [FW-GigabitEthernet0&#x2F;0&#x2F;3] ip address 10.1.1.254 24 将接口添加到相应的安全区域： [FW] firewall zone trust [FW-zone-trust] add interface GigabitEthernet0&#x2F;0&#x2F;1 [FW] firewall zone dmz [FW-zone-dmz] add interface GigabitEthernet0&#x2F;0&#x2F;2 [FW] firewall zone untrust [FW-zone-untrust] add interface GigabitEthernet0&#x2F;0&#x2F;3 配置域间策略，使得trust域的192.168.1.0&#x2F;24网段用户能够访问untrust区域的10.1.1.0&#x2F;24网段 [FW] policy interzone trust untrust outbound [FW-policy-interzone-trust-untrust-outbound] policy 10 [FW-policy-interzone-trust-untrust-outbound-10] policy destination 10.1.1.0 0.0.0.255 [FW-policy-interzone-trust-untrust-outbound-10] policy source 192.168.1.0 0.0.0.255 [FW-policy-interzone-trust-untrust-outbound-10] action permit 配置域间策略，使得untrust可以访问server [FW] policy interzone dmz untrust inbound [FW-policy-interzone-dmz-untrust-inbound] policy 10 [FW-policy-interzone-dmz-untrust-inbound-10] policy source 10.1.1.0 0.0.0.255 [FW-policy-interzone-dmz-untrust-inbound-10] policy destination 172.16.1.1 0 [FW-policy-interzone-dmz-untrust-inbound-10] policy service service-set http [FW-policy-interzone-dmz-untrust-inbound-10] action permit 完成上述配置后，PC1即可主动发起访问PC2，而PC2无法主动访问PC1；另外，PC2能够访问WebServer的HTTP服务 （ping不同，需要再配置一条允许icmp协议通过） 通过命令display zone，可以查看防火墙的安全区域、安全等级，以及每个安全区域下的接口. 使用display firewall packet-filter default 命令，能查看防火墙的缺省安全策略。当数据包经过防火墙且从一个安全域试图访问另一个安全域时，防火墙会根据数据包的流向首先检查用户定义的policy interzone，如果没有自定义的policy interone，则会看根据防火墙的缺省安全策略进行处理。例如从上面的显示中，我们可以看到local-trust的inbound及outbound都是permit，因此即使我们没有显式的配置local及trust安全区域的区域间策略，但是由于默认的策略就是放行，所以 trust区域的用户可以直接ping通防火墙的接口。 如果要让防火墙默认放行所有域间的流量，可以使用：firewall packet-filter default permit all命令，值得注意的是，在网络正式投入现网使用之前，此命令必须关闭（firewall packet-filter default deny all），针对需要放行的流量，需通过policy interzone的配置来放行，而不能鲁莽地将所有流量统统放行。 使用display policy命令，能查看我们定义的区域间安全策略，例如： [FW] display policy interzone trust untrust outbound USG5500 nat实验 防火墙FW的配置如下： [FW] interface GigabitEthernet0&#x2F;0&#x2F;1 [FW-GigabitEthernet0&#x2F;0&#x2F;1] ip address 192.168.1.254 24 [FW] interface GigabitEthernet0&#x2F;0&#x2F;2 [FW-GigabitEthernet0&#x2F;0&#x2F;2] ip address 172.16.1.254 24 [FW] interface GigabitEthernet0&#x2F;0&#x2F;3 [FW-GigabitEthernet0&#x2F;0&#x2F;3] ip address 200.1.1.1 24 向安全域中添加接口 [FW] firewall zone trust [FW-zone-trust] add interface GigabitEthernet0&#x2F;0&#x2F;1 [FW] firewall zone dmz [FW-zone-dmz] add interface GigabitEthernet0&#x2F;0&#x2F;2 [FW] firewall zone untrust [FW-zone-untrust] add interface GigabitEthernet0&#x2F;0&#x2F;3 配置域间包过滤策略，使得trust区域的192.168.1.0&#x2F;24网段用户能够访问Internet： [FW] policy interzone trust untrust outbound [FW-policy-interzone-trust-untrust-outbound] policy 10 [FW-policy-interzone-trust-untrust-outbound-10] policy source 192.168.1.0 0.0.0.255 [FW-policy-interzone-trust-untrust-outbound-10] action permit 上述配置虽然放通了192.168.1.0&#x2F;24访问Internet的流量，但是由于192.168.1.0&#x2F;24是私有IP地址，不能直接进入公网，因此为了让这部分用户能够访问公网，还必须部署NAT源地址转换 [FW] nat address-group 1 200.1.1.10 200.1.1.20 定义NAT地址池，该地址池使用的公网地址区间是200.1.1.10到200.1.1.20 [FW] nat-policy interzone trust untrust outbound 配置NAT策略 [FW-nat-policy-interzone-trust-untrust-outbound] policy 10 [FW-nat-policy-interzone-trust-untrust-outbound-10] policy source 192.168.1.0 0.0.0.255 [FW-nat-policy-interzone-trust-untrust-outbound-10] action source-nat &#x2F;&#x2F;对匹配的流量执行源地址转换 [FW-nat-policy-interzone-trust-untrust-outbound-10] address-group 1 &#x2F;&#x2F;关联nat地址池1 完成上述配置后，内网用户PC1即可访问公网用户PC2。接下来继续配置防火墙，使得公网用户PC2能够访问WebServer。 配置域间包过滤策略，使得untrust区域的Internet用户能够访问DMZ区域的web服务 [FW] policy interzone dmz untrust inbound [FW-policy-interzone-dmz-untrust-inbound] policy 10 [FW-policy-interzone-dmz-untrust-inbound-10] policy destination 172.16.1.1 0 [FW-policy-interzone-dmz-untrust-inbound-10] policy service service-set http [FW-policy-interzone-dmz-untrust-inbound-10] action permit [FW-policy-interzone-dmz-untrust-inbound-10] quit [FW-policy-interzone-dmz-untrust-inbound] quit 完成上述配置后，Internet用户是依然无法访问WebServer的，因为WebServer是私有IP地址，因此还需要配置NAT server，将DMZ域内的WebServer映射到公网。 下面的命令，将内部IP地址172.16.1.1的80端口映射到了公网地址200.1.1.21的80端口，这样一来，当公网用户访问200.1.1.21的80端口服务时，实际上访问的就是内部服务器172.16.1.1的80端口。 [FW] nat server zone untrust protocol tcp global 200.1.1.21 80 inside 172.16.1.1 80 完成上述配置后，PC2即可使用目的地址200.1.1.21来访问WebServer。 当PC1 ping PC2时，能够在FW上能看到如下会话： display firewall session table Current Total Sessions : 5 icmp VPN:public –&gt; public 192.168.1.1:40373[200.1.1.15:2048]–&gt;200.1.1.2:2048 icmp VPN:public –&gt; public 192.168.1.1:40885[200.1.1.15:2049]–&gt;200.1.1.2:2048 留意到中括号内的IP地址，便是被NAT转换后的IP地址。 当PC2访问Server的WEB服务时，在FW上能看到如下会话： [FW]display firewall session table Current Total Sessions : 1 http VPN:public –&gt; public 200.1.1.2:2055–&gt;200.1.1.21:80[172.16.1.1:80]","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"USG5500","slug":"USG5500","permalink":"http://example.com/tags/USG5500/"},{"name":"防火墙nat","slug":"防火墙nat","permalink":"http://example.com/tags/%E9%98%B2%E7%81%AB%E5%A2%99nat/"}]},{"title":"rstp和mstp","slug":"rstp和mstp","date":"2023-12-07T10:08:51.000Z","updated":"2023-12-07T10:53:06.725Z","comments":true,"path":"2023/12/07/rstp和mstp/","permalink":"http://example.com/2023/12/07/rstp%E5%92%8Cmstp/","excerpt":"","text":"概念STP三个版本：STP（802.1d）RSTP（802.1w）MSTP （802.1s）作用：打破二层环路，实现设备或者链路的冗余STP的计算过程①选举根桥BID&#x3D;优先级+MAC，优先级值越小越优，如果优先级相等，MAC小的成为根桥②选举根端口RPC（小的越优）+上行交换机的BID+上行交换机的PID（优先级和接口ID，越小越优）+本地的PID③选举指定接口RPC（小的越优）+本端的BID+本端的PID（小的越优）④非指定接口 端口优先级 端口ID（pid）&#x3D; 端口优先级（Port Priority）4 bit+ 端口编号12 bit 构成； 缺省情况下，端口优先级是128；端口优先级取值范围是0到240，取值必须为16的整数倍。 优先级 默认32768 越小越优 必须是4096倍数 0-65535 接口根路径开销： 1、dot1tG：20000E：200000 PRC&#x3D;根桥到非根桥经过所有的入方向接口的cost累加 STP的收敛时间： ①根桥故障50s②直连链路发生故障30s③非直连链路故障50s 转发延迟计时器：15sBPDU发送时间：2s老化时间：20s 端口状态：disable:未启用blocking：阻塞listening:侦听learning:学习forwarding：转发 RSTP:一、端口角色：根端口指定端口A:根端口的备份端口，提供了指定桥到达根的另一条路径Backup:作为指定接口的备份，提供了另一条从根桥到相应网段的备份链路 二、端口状态Discarding状态：不转发用户流量也不学习MAC地址；Learning状态：不转发用户流量但是学习MAC地址；Forwarding状：既转发用户流量又学习MAC地址三、配置BPDUBPDU类型和flag字段四、配置BPDU的处理拓扑稳定后，运行RSTP协议的非根桥设备会定期的发送配置BPDURSTP的任何端口角色都会处理次优BPDU，从而加快拓扑收敛五、P&#x2F;A作用：保证一个指定接口从discarding—&gt;forwarding触发：只有指定discarding状态下才可以触发P&#x2F;A机制，必须是根端口在forwarding状态下回复一个A&#x3D;1的一个BPDU ① 选举根桥、根接口、指定接口，然后根接口、指定接口处于discarding②根桥的指定接口处于discarsing，触发到P&#x2F;A，根桥会从指定接口发送P&#x3D;1BPDU；③非根桥的根接口收到P&#x3D;1的BPDU，会启动一个同步过程，将非边缘接口全部阻塞，同步完成之后，根接口切换到转发状态，并且从根接口发送A&#x3D;1 BPDU④根桥收到A&#x3D;1 BPDU，立即切换为转发状态，实现指定接口的快速收敛 保护功能：1、BPDU保护存在问题：边缘端口收到BPDU之后，接口会变成普通接口，那么会引起网络中生成树重新计算，对网络造成影响。解决：开启BPDU保护功能，只要边缘端口收到BPDU，交换机立即把接口置位Error-down，同时会产生告警。（接口恢复两种方式：手工恢复、自动恢复） 2、根保护 存在问题：加入在一个稳定的STP网络，此时根桥连接一台交换机，该交换机支持生成树，发送BPDU，STP网络重新计算；如果新加入的交换机比根桥优先级更优，会抢占根桥的位置，从而引起网络震荡解决：根桥的指定接口下激活跟保护功能，如何接口收到了更优的BPDU，会忽略并且切换到discarding。注意：跟保护只能在指定接口下激活。状态恢复：如果接口不再收到更优的BPDU，在一段时间后（2*转发延迟时间）自动恢复转发状态。 3、环路保护存在问题：AP单向故障：假如交换机之间通过光纤（一收一发），链路发生单向故障，AP接口老化时间后没有收到BPDU,接口会成为DP并切换到转发状态，并转发流量，环路产生RP单向故障：假如交换机之间通过光纤（一收一发），链路发生单向故障，导致DP到RP的单向故障，RP在一段时间没有收到BPDU，AP会切换到RP角色，RP切换到DP，收敛完成，DP开始转发业务流量，环路产生。解决：在AP接口下开启环路保护功能，如何接口长时间没有BPDU ,那么AP接口切换成DP，端口状态保持discarding状态，避免环路。 在RP接口下开启环路保护功能，如何接口长时间没有BPDU，那么会重新计算选举根端口，并将原端口调整为DP，接口状态保持discarding状态，避免环路。 4、拓扑变更保护（TC protection）存在问题：假如网络中存在攻击者，会仿冒TC置位为1的BPDU报文发送大量的TC BPDU，交换机收到BPDU之后，会删除mac地址表项，会消耗大量的设备资源。解决：默认情况交换机开启了拓扑变更保护，缺省2s只会处理异常TC BPDU，超出的部分等待一段时间处理 如何生成STP树？主要通过比较4个参数：根桥ID、根路径开销、网桥ID和端口ID，值越小，越优先。而这些参数，都是报文BPDU中的字段。根桥选举：比较根桥ID，最小胜出。根端口选举：依次比较RPC、对端BID、对端PID和本端PID，最小胜出。指定端口选举：依次比较RPC、本端BID和本端PID，最小胜出。 在确定了根端口和指定端口之后，交换机上所有剩余的非根端口和非指定端口被阻塞。 MSTP：一、概念MST Region：Multiple Spanning Tree Region，多生成树域），也可简称MST域MSTI（Multiple Spanning Tree Instance，多生成树实例）：MSTI使用Instance ID标识，为0~4094。Instance0是缺省存在的，而且缺省时，华为交换机上所有的VLAN都映射到了Instance0。通过设置VLAN映射表（即VLAN和MSTI的对应关系表），把VLAN和MSTI联系起来。每个VLAN只能对应一个MSTI，即同一VLAN的数据只能在一个MSTI中传输，而一个MSTI可能对应多个VLAN。CST公共生成树：是连接交换网络内所有MST域的一棵生成树IST（内部生成树）是各MST域内的一棵生成树。CIST（公共和内部生成树）通过生成树协议计算生成的，连接一个交换网络内所有交换设备的单生成树SST（Single Spanning Tree，单生成树）有两种情况：运行生成树协议的交换设备只能属于一个生成树。MST域中只有一个交换设备，这个交换设备构成单生成树。 总根（CIST Root）是CIST的根桥 域根（Regional Root）分为IST域根和MSTI域根。IST域根，在MST域中IST生成树中距离总根最近的交换设备是IST域根，MSTI域根是每个多生成树实例的树根 主桥（Master Bridge）是IST Master，它是域内距离总根最近的交换设备，如果总根在MST域中，则总根为该域的主桥 新增的端口角色：①Master端口 Master端口是MST域和总根相连的所有路径中最短路径上的端口，它是交换设备上连接MST域到总根的端口。Master端口是域中的报文去往总根的必经之路。Master端口是特殊域边缘端口，Master端口在CIST上的角色是Root Port，在其它各实例上的角色都是Master端口。 ②域边缘端口域边缘端口是指位于MST域的边缘并连接其它MST域或SST的端口 MSTP计算优先级向量说明：根交换设备ID：根交换设备ID用于选择CIST中的根交换设备。根交换设备ID &#x3D; Priority(16 bit) + MAC(48 bit)。其中Priority为MSTI0的优先级。外部路径开销（External Root Path Cost，ERPC）：从CIST的域根到达总根的路径开销。MST域内所有交换设备上保存的外部路径开销相同。若CIST根交换设备在域中，则域内所有交换设备上保存的外部路径开销为0。域根ID：域根ID用于选择MSTI中的域根。域根ID &#x3D; Priority(16 bit) + MAC(48 bit)。其中Priority为MSTI0的优先级。内部路径开销（Internal Root Path Cost，IRPC）：本桥到达域根的路径开销。域边缘端口保存的内部路径开销大于非域边缘端口保存的内部路径开销。指定交换设备ID：CIST或MSTI实例的指定交换设备是本桥通往域根的最邻近的上游桥。如果本桥就是总根或域根，则指定交换设备为自己。指定端口ID：指定交换设备上同本设备上根端口相连的端口。Port ID &#x3D; Priority(4 bit) + 端口号（12 bit）。端口优先级必须是16的整数倍。接收端口ID：接收到BPDU报文的端口。Port ID &#x3D; Priority(4 bit) + 端口号（12 bit）。 端口优先级必须是16的整数倍。 优先级向量比较原则：同一向量比较，值最小的向量具有最高优先级。优先级向量比较原则如下首先，比较根交换设备ID。如果根交换设备ID相同，再比较外部路径开销。如果外部路径开销相同，再比较域根ID。如果域根ID仍然相同，再比较内部路径开销。如果内部路径仍然相同，再比较指定交换设备ID。如果指定交换设备ID仍然相同，再比较指定端口ID。如果指定端口ID还相同，再比较接收端口ID。如果端口接收到的BPDU内包含的配置消息优于端口上保存的配置消息，则端口上原来保存的配置消息被新收到的配置消息替代。端口同时更新交换设备保存的全局配置消息。反之，新收到的BPDU被丢弃。 配置 开启STP，修改STP模式为RSTP。 手动指定S1为RSTP根桥、S2为RSTP备份根桥。 通过修改接口开销值，使得S4的GE0&#x2F;0&#x2F;1接口成为根端口。 通过修改S1的GE0&#x2F;0&#x2F;11接口优先级，使得S2的GE0&#x2F;0&#x2F;11接口成为根端口。 修改STP模式为MSTP，创建Instance1、2，指定SW1为MSTI1的根桥、MSTI2的备份根桥，指定SW2为MSTI2的根桥、MSTI1的备份根桥。 RSTP基础配置#S1-s4 上都配置 stp enable stp mode rstp #查看STP的状态和统计信息摘要 dis stp brief 接口都为指定端口的是根桥，本实验中s4是根桥 根桥选举控制 #手动调整STP优先级，指定S1为主根桥、S2为备份根桥 [S1]stp priority 4096 [S2]stp priority 8192 在另外两台交换机保持默认桥优先级（32768）的情况下，S1拥有最小的桥优先级，S2次之。 此时s1变为根桥，s2备份根桥 dis stp可以看到优先级已经改变 #取消S1、S2上手动调整桥优先级的配置，使用stp root命令指定根桥、备份根桥 [S1]undo stp priority [S1]stp root primary [S2]undo stp priority [S2]stp root secondary #S1、S2上查看STP的状态和统计信息，可以看到如下内容 s1： s2: S1的桥优先级为0，而S2的桥优先级为4096，此时S1为根桥，S2为备份根桥。 修改接口开销值控制根端口选举 #在S4上查看STP的状态和统计信息摘要 S4上GE0&#x2F;0&#x2F;2拥有更小的RPC（根路径开销），从而成为根端口。 #在S4上查看GE0&#x2F;0&#x2F;2接口的STP的状态和统计信息 此时路径开销计算方法为Dot1t，接口的STP cost值为20000。 #修改S4的GE0&#x2F;0&#x2F;2接口的STP cost值为40001 [S4]interface GigabitEthernet 0&#x2F;0&#x2F;2 [S4-GigabitEthernet0&#x2F;0&#x2F;2] stp cost 40001 #再次在S4上查看STP的状态和统计信息摘要 此时GE0&#x2F;0&#x2F;1接口的RPC为20000，小于GE0&#x2F;0&#x2F;2接口的RPC 40001，S4的GE0&#x2F;0&#x2F;1接口成为根端口。 修改接口优先级控制根端口选举 #在S2上查看STP的状态和统计信息摘要 S2上GE0&#x2F;0&#x2F;10、GE0&#x2F;0&#x2F;11接口收到的BPDU拥有相同的RPC、上行交换机BID，此时比较上行交换机PID（优先级+接口id），接口优先级一样，接口id小的优，所以g0&#x2F;0&#x2F;10小，所以是根端口 #在S1上修改GE0&#x2F;0&#x2F;11的STP接口优先级，使其发送的BPDU优于 GE0&#x2F;0&#x2F;10发送的BPDU （修改上行交换机的PID） [S1]interface GigabitEthernet 0&#x2F;0&#x2F;11 [S1-GigabitEthernet0&#x2F;0&#x2F;11] stp port priority 64 端口ID&#x3D; 端口优先级（Port Priority）4 bit+ 端口编号12 bit 构成； 缺省情况下，端口优先级是128；端口优先级取值范围是0到240，取值必须为16的整数倍。 #再次查看S2上的STP状态和统计信息摘要 此时S2的GE0&#x2F;0&#x2F;1接口成为根端口。 MSTP基础配置在所有交换机上创建VLAN10、20、30、40、50、60、70、80，配置MSTP域hcip，并创建两个新的实例：Instance 1、Instance 2，将VLAN10、30、50、70映射到Instance 1，将VLAN20、40、60、80映射到Instance 2，同时将SW1规划为MSTI1的主根桥、MSTI2的备份根桥，将SW2规划为MSTI2的主根桥、MSTI1的备份根桥。 #创建VLAN [S1]vlan batch 10 20 30 40 50 60 70 80 [S2]vlan batch 10 20 30 40 50 60 70 80 [S3]vlan batch 10 20 30 40 50 60 70 80 [S4]vlan batch 10 20 30 40 50 60 70 80 #将所有互联接口配置为Trunk接口，放通所有VLAN 略 #修改STP模式为MSTP [S1]stp mode mstp [S2]stp mode mstp [S3]stp mode mstp [S4]stp mode mstp #配置MSTP [S1]stp region-configuration [S1-mst-region] region-name hcip &#x2F;&#x2F;域名为hcip [S1-mst-region] revision-level 1 &#x2F;&#x2F;版本1 [S1-mst-region] instance 1 vlan 10 30 50 70 实例1映射vlan 10 30 50 70 [S1-mst-region] instance 2 vlan 20 40 60 80 [S1-mst-region] active region-configuration &#x2F;&#x2F;生效 Info: This operation may take a few seconds. Please wait for a moment…done. [S1-mst-region] quit （s2，s3，s4同理配置） #在S1检查MSTP实例和VLAN的映射关系 [S1]display stp region-configuration #配置SW1为MSTI1的根桥、MSTI2的备份根桥 [S1]stp instance 1 root primary [S1]stp instance 2 root secondary #配置SW2为MSTI2的根桥、MSTI1的备份根桥 [S2]stp instance 1 root secondary [S2]stp instance 2 root primary #在S1上查看MSTI1的状态和统计信息摘要 [S1]display stp instance 1 brief MSTID Port Role STP State Protection 1 GigabitEthernet0&#x2F;0&#x2F;10 DESI FORWARDING NONE 1 GigabitEthernet0&#x2F;0&#x2F;11 DESI FORWARDING NONE 1 GigabitEthernet0&#x2F;0&#x2F;12 DESI FORWARDING NONE 1 GigabitEthernet0&#x2F;0&#x2F;13 DESI FORWARDING NONE S1上所有接口都是指定接口，S1为MSTI1的根桥。 #在S2上查看MSTI2的状态和统计信息摘要 [S2]display stp instance 2 brief MSTID Port Role STP State Protection 2 GigabitEthernet0&#x2F;0&#x2F;10 DESI FORWARDING NONE 2 GigabitEthernet0&#x2F;0&#x2F;11 DESI FORWARDING NONE 2 GigabitEthernet0&#x2F;0&#x2F;12 DESI FORWARDING NONE 2 GigabitEthernet0&#x2F;0&#x2F;13 DESI FORWARDING NONE S2上所有接口都是指定接口，S2为MSTI2的根桥。","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"rstp","slug":"rstp","permalink":"http://example.com/tags/rstp/"},{"name":"mstp","slug":"mstp","permalink":"http://example.com/tags/mstp/"}]},{"title":"链路聚合","slug":"链路聚合","date":"2023-12-07T07:56:27.000Z","updated":"2023-12-07T08:23:50.207Z","comments":true,"path":"2023/12/07/链路聚合/","permalink":"http://example.com/2023/12/07/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/","excerpt":"","text":"概念什么是链路聚合在现网中，设备间如果通过一条链路连接，如果这条链路故障了，那么设备两端的终端就不能够通信了。有什么办法可以解决该问题呢？答案是——链路聚合。 从端口的角度定义： 链路聚合（Link Aggregation）是指将多个物理端口汇聚在一起，形成一个逻辑端口，以实现出&#x2F;入流量吞吐量在各成员端口的负荷分担，交换机根据用户配置的端口负载分担方式决定数据包从哪个成员端口发送到对端的交换机。 从链路的角度定义： 链路聚合（Link Aggregation）是把两台设备之间的多条物理链路聚合在一起，当做一条逻辑链路来使用。这两台设备可以是一对路由器，一对交换机，或者是一台路由器和一台交换机。一条聚合链路可以包含多条成员链路，默认最多为8条。 链路聚合的作用 链路聚合能够提高链路带宽。理论上，通过聚合几条链路，一个聚合口的带宽可以扩展为所有成员口带宽的总和，这样就有效地增加了逻辑链路的带宽。 链路聚合为网络提供了高可靠性。配置了链路聚合之后，如果一个成员接口发生故障，该成员口的物理链路会把流量切换到另一条成员链路上。 链路聚合在一个聚合口上实现负载均衡。一个聚合口可以把流量分散到多个不同的成员口上，通过成员链路把流量发送到同一个目的地，将网络产生拥塞的可能性降到最低。 三. 链路聚合的工作原理：应用场景： 链路聚合一般部署在核心结点，以便提升整个网络的数据吞吐量。 链路聚合能够提高链路带宽，增强网络可靠、可用性，支持负载分担。 链路聚合模式: 链路聚合包含两种模式：手动负载均衡模式和静态LACP（Link Aggregation Control Protocol）模式。 手工负载分担模式： 手工负载分担模式下，Eth-Trunk的建立、成员接口的加入由手工配置，没有链路聚合控制协议的参与。 该模式下所有活动链路都参与数据的转发，平均分担流量，因此称为负载分担模式。如果某条活动链路故障，链路聚合组自动在剩余的活动链路中平均分担流量。 使用场景： 当需要在两个直连设备间提供一个较大的链路带宽而设备又不支持LACP协议时，可以使用手工负载分担模式。 2. 静态LACP模式： 在静态LACP模式中，链路两端的设备相互发送LACP报文，协商聚合参数。协商完成后，两台设备确定活动接口和非活动接口。 在静态LACP模式中，需要手动创建一个Eth-Trunk口，并添加成员口。 静态LACP模式也叫M:N模式。M代表活动成员链路，用于在负载均衡模式中转发数据。N代表非活动链路，用于冗余备份。 如果一条活动链路发生故障，该链路传输的数据被切换到一条优先级最高的备份链路上，这条备份链路转变为活动状态。 两种链路聚合模式的主要区别： 在静态LACP模式中，一些链路充当备份链路。 在手动负载均衡模式中，所有的成员口都处于转发状态。 维度 手工模式 LACP模式 Eth-Trunk的建立方式 Eth-Trunk接口的创建、成员接口的加入由手工配置，没有链路聚合控制协议的参与。 Eth-Trunk接口的创建、成员接口的加入由手工配置，LACP协议参与链路动态调整，负责链路状态维护。在聚合条件发生变化时，自动调整或解散链路聚合。 设备是否需要支持LACP协议 不需要 需要 数据转发 正常情况下，所有链路都是活动链路。所有活动链路均参与数据转发。如果某条活动链路故障，链路聚合组自动在剩余的活动链路中分担流量。 正常情况下，部分链路是活动链路。所有活动链路均参与数据转发。如果某条活动链路故障，链路聚合组自动在非活动链路中选择一条链路作为活动链路，参与数据转发的链路数目不变。 检测故障 只能检测到同一聚合组内的成员链路有断路等故障，无法检测到链路断连、错连等故障。 不仅能够检测到同一聚合组内的成员链路有断路等故障，还可以检测到链路故障、链路错连等故障。 数据流控制: Eth-trunk链路两端相连的物理接口的数量、速率、双工方式、流控方式必须一致。 优先级0-65535 默认32768 小的优先 优先级一样，看mac，mac小的优先 配置 配置手工链路聚合# 创建Eth-Trunk接口 [S1]interface Eth-Trunk 1 interface eth-trunk命令用来进入已经存在的Eth-Trunk接口，或创建并进入Eth-Trunk接口。数字“1”代表接口编号，编号范围根据设备情况有所不同。 [S2]interface Eth-Trunk 1 # 设置Eth-Trunk接口的聚合模式 [S1-Eth-Trunk1]mode manual load-balance mode命令用来配置Eth-Trunk的工作模式，有LACP模式和手工负载分担模式（手工模式）两种，缺省情况下，Eth-Trunk的工作模式为手工负载分担模式。此处S1上的模式配置仅为示范目的，实际操作时不需要。 # 将成员接口加入聚合组 [S1]interface GigabitEthernet 0&#x2F;0&#x2F;10 [S1-GigabitEthernet0&#x2F;0&#x2F;10]eth-trunk 1 Info: This operation may take a few seconds. Please wait for a moment…done. [S1-GigabitEthernet0&#x2F;0&#x2F;10]quit [S1]interface GigabitEthernet 0&#x2F;0&#x2F;11 [S1-GigabitEthernet0&#x2F;0&#x2F;11]eth-trunk 1 Info: This operation may take a few seconds. Please wait for a moment…done. [S1-GigabitEthernet0&#x2F;0&#x2F;11]quit [S1]interface GigabitEthernet 0&#x2F;0&#x2F;12 [S1-GigabitEthernet0&#x2F;0&#x2F;12]eth-trunk 1 Info: This operation may take a few seconds. Please wait for a moment…done. [S1-GigabitEthernet0&#x2F;0&#x2F;12]quit 可进入到成员接口的接口视图下，逐一添加到Eth-Trunk接口。也可以在Eth-Trunk接口视图下通过trunkport命令批量添加接口。 [S2]interface Eth-Trunk 1 [S2-Eth-Trunk1]trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12 Info: This operation may take a few seconds. Please wait for a moment…done. 将成员接口加入Eth-Trunk时，需要注意以下问题： • 每个Eth-Trunk接口下最多可以包含8个成员接口。 • Eth-Trunk接口不能嵌套，即Eth-Trunk接口的成员接口不能是Eth-Trunk接口。 • 一个以太网接口只能加入到一个Eth-Trunk接口，如果需要加入其它Eth-Trunk接口，必须先退出原来的Eth-Trunk接口。 • 如果本地设备使用了Eth-Trunk，与成员接口直连的对端接口也必须捆绑为Eth-Trunk接口，两端才能正常通信。 Eth-Trunk链路两端相连的物理接口的数量、速率、双工方式等必须一致。 #查看Eth-Trunk接口状态 dis eth-trunk 1 配置LACP模式# 删除现有Eth-Trunk接口下的成员接口 [S1]interface Eth-Trunk 1 [S1-Eth-Trunk1]undo trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12 [S2]interface Eth-Trunk 1 [S2-Eth-Trunk1]undo trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12 在修改Eth-Trunk接口的聚合模式之前，需要确保Eth-Trunk中没有任何成员接口。 # 修改聚合模式 [S1]interface Eth-Trunk 1 [S1-Eth-Trunk1]mode lacp mode lacp 指定Eth-Trunk工作模式为LACP模式。 注：部分版本的设备命令为 mode lacp-static [S2]interface Eth-Trunk 1 [S2-Eth-Trunk1]mode lacp # 将成员接口加入聚合组 [S1]interface Eth-Trunk 1 [S1-Eth-Trunk1]trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12 [S2]interface Eth-Trunk 1 [S2-Eth-Trunk1]trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12 查看 注意此时三个接口都是Select的状态 选择接口​ 考虑到网络流量情况，当网络正常时，只需要GigabitEthernet0&#x2F;0&#x2F;11和GigabitEthernet0&#x2F;0&#x2F;12接口处于转发状态，GigabitEthernet0&#x2F;0&#x2F;10接口作为备份。但当活动接口数量少于2时，直接关闭整个Eth-Trunk接口。 全局配置优先级选举主动方，主动方设备的端口上配置接口优先级选举活动端口 # 配置设备S1的LACP优先级，使其成为主动端设备 [S1]lacp priority 100 # 配置接口优先级，优选GigabitEthernet0&#x2F;0&#x2F;11和GigabitEthernet0&#x2F;0&#x2F;12接口 [S1]interface GigabitEthernet 0&#x2F;0&#x2F;10 [S1-GigabitEthernet0&#x2F;0&#x2F;10]lacp priority 40000 # 配置接口优先级，优选GigabitEthernet0&#x2F;0&#x2F;11和GigabitEthernet0&#x2F;0&#x2F;12接口 [S1]interface GigabitEthernet 0&#x2F;0&#x2F;10 [S1-GigabitEthernet0&#x2F;0&#x2F;10]lacp priority 40000 g0&#x2F;0&#x2F;10配置了大于32768的优先级4000，所以变为备份端口 之后，g0&#x2F;0&#x2F;11和g0&#x2F;0&#x2F;12为活动端口 使能了LACP模式链路聚合的两端设备均会收发的LACPDU报文。 首先选举主动端设备： 比较系统优先级字段，如果对端的系统优先级高于本端的系统优先级（默认为32768，越小越优），则确定对端为LACP主动端。 如果系统优先级相同，比较两端设备的MAC地址，MAC地址小的一端为LACP主动端。 选出主动端后，两端都会以主动端的接口优先级来选择活动接口，接口优先级越小越优，默认为32768。 # 配置Eth-trunk活动接口数上限阈值和下限阈值 [S1]interface Eth-Trunk 1 [S1-Eth-Trunk1]max active-linknumber 2 [S1-Eth-Trunk1]least active-linknumber 2 在一个Eth-Trunk接口内，活动接口数可以影响到Eth-Trunk接口的状态和带宽。Eth-Trunk接口的带宽是所有处于Up状态的成员口带宽之和。为保证Eth-Trunk接口的状态和带宽，可以设置以下两个阈值，以减小成员链路状态的变化带来的影响。 • 活动接口数下限阈值：当活动接口数小于配置的下限阈值时，Eth-Trunk接口的状态转为Down。设置活动接口数下限阈值的目的是为了保证最小带宽。least active-linknumber命令用来配置链路聚合组活动接口数目的下限阈值。 • 活动接口数上限阈值：当活动接口数达到上限阈值后，之后再发生成员链路状态变为Up都不会使Eth-Trunk接口的带宽增加。设置活动接口数上限阈值的目的是在保证了带宽的情况下提高网络的可靠性。max active-linknumber命令用来配置链路聚合组活动接口数目的上限阈值。 # 开启抢占功能 [S1]interface Eth-Trunk 1 [S1-Eth-Trunk1]lacp preempt enable 在LACP模式下，当活动链路中出现故障链路时，系统会从备用链路中选择优先级最高的链路替代故障链路；如果被替代的故障链路恢复了正常，而且该链路的优先级又高于替代自己的链路。这种情况下，如果使能了LACP优先级抢占功能，高优先级链路会抢占低优先级链路，回切到活动状态。lacp preempt enable命令用来使能LACP模式下LACP优先级抢占的功能，缺省情况下，优先级抢占处于禁止状态。 # 查看当前 Eth-Trunk接口状态 shutdown接口g0&#x2F;0&#x2F;11和g0&#x2F;0&#x2F;12 查看状态，发现都变为unselect状态 由于设置了Eth-Trunk的活动链路下限阈值为2，所以聚合组中可用活动接口数量少于2时，整个聚合组对应的接口将会被关闭。尽管此时GigabitEthernet0&#x2F;0&#x2F;10处于UP状态，但是仍处于Unselect状态。 修改负载分担模式# 开启上一步中关闭的接口 [S1]inter GigabitEthernet 0&#x2F;0&#x2F;11 [S1-GigabitEthernet0&#x2F;0&#x2F;11]undo shutdown [S1-GigabitEthernet0&#x2F;0&#x2F;11]quit [S1]inter GigabitEthernet 0&#x2F;0&#x2F;12 [S1-GigabitEthernet0&#x2F;0&#x2F;12]undo shutdown # 大约30秒后，查看当前Eth-Trunk1的接口状态 由于使能了Eth-Trunk接口的抢占功能，所以当GigabitEthernet0&#x2F;0&#x2F;11和GigabitEthernet0&#x2F;0&#x2F;12接口进入UP状态之后，这两个接口的接口的优先级高于GigabitEthernet0&#x2F;0&#x2F;10，所以GigabitEthernet0&#x2F;0&#x2F;10会进入unselect状态。同时因为系统为了保证链路的稳定性，默认的抢占延时为30秒，所以要在30秒后才会发生抢占。 # 修改Eth-Trunk接口的负载分担模式为基于目的IP地址 [S1]interface Eth-Trunk 1 [S1-Eth-Trunk1]load-balance dst-ip 当需要将Eth-Trunk接口的流量分散到不同的链路上，最后能到达统一目的地时，使用load-balance命令配置Eth-Trunk接口负载分担模式，以确保出方向的流量在各物理链路间进行合理的负载分担，避免链路阻塞。由于负载分担只对出方向的流量有效，因此链路两端接口的负载分担模式可以不一致，两端互不影响","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"链路聚合","slug":"链路聚合","permalink":"http://example.com/tags/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/"},{"name":"lacp","slug":"lacp","permalink":"http://example.com/tags/lacp/"},{"name":"eth-trunk","slug":"eth-trunk","permalink":"http://example.com/tags/eth-trunk/"}]},{"title":"mpls实验","slug":"mpls实验","date":"2023-12-05T09:53:41.000Z","updated":"2023-12-05T10:56:53.373Z","comments":true,"path":"2023/12/05/mpls实验/","permalink":"http://example.com/2023/12/05/mpls%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"概念MPLS（Multiprotocol Label Switching）多协议标签转发复习总结首先我们要先知道MPLS是为何出现的？MPLS是基于传统IP网络（RIP，OSPF等）的缺陷由IETF确定的 顺便先复习一下路由器查路由表 转发的过程： 传统的IP转发中，物理层从交换机的一个端口收到一个报文，上送到数据链路层。数据链路层去掉链路层封装，根据报文的协议域上送给相应的网络层。网络层首先看报文是否是送给本机的，若是，去掉网络层封装，上送给它的上层协议。若不是，则根据报文的目的地址查找路由表，若找到路由，将报文送给相应端口的数据链路层，数据链路层封装后，发送报文。若找不到路由，将报文丢弃。传统的IP转发采用的是逐跳转发，数据报文经过每一台交换机，都要执行上述过程（如图中SWA收到目的地址为10.2.0.1的数据包，SWA会依次查找路由表，根据匹配的路由表项的进行转发，SWB、SWC、SWD都会进行类似的处理），所以速度缓慢。并且所有的交换机需要知道全网的路由或者默认路由。另外，由于传统IP转发是面向无连接的，所以无法提供好的Qos保证。 传统IP网络基于IGP Metric计算最优路径，这是远远不够的，往往在现实网络中还需考虑带宽、链路属性等其他因素；基于IP的流量工程是基于IGP面向目的地址的转发，是hop-by-hop（逐跳）的转发，无法实现根据来源来控制流量转发；另外基于IP的流量工程是面向无连接的，不能实现显式路径（Explicit Routing）。上图中，SWB和SWD之间存在两条路径。传统的IP转发中IGP根据Metric选择最优的路由SWB-SWC-SWD转发所有从Network A和Network B到Network C的IP报文，而SWB-SWG-SWH-SWD链路则闲置，当网络中流量过大，有可能导致最优路径拥塞，但次优路径却空载没有被充分利用。 MPLS的出现从A到走到B有三种方法：1.广播（如以太网）：直接把数据发给每一个地方2.逐跳寻径：走到一个地方，问一下路接下来该怎么走（也就是上面说的根据路由协议，查路由表）3.源路由：提前规划好路线，到哪里怎么走，不常用。 而MPLS是第四种走法：跟在“向导”后面走，向导在走过的路上做好标记，你只要沿着标记的指示走就可以了。这也就是“标签交换” MPLS结合了三层路由技术与二层交换技术，所以可以把它看成“2.5层”的其中的MP多协议指的是支持多种网络协议，如ipv4，ipv6，CLNP，IPX等 MPLS是一种标签转发技术，它采用无连接的控制平面和面向连接的数据平面（具体的MPLS架构下面还有介绍），无连接的控制平面实现路由信息的传递和标签的分发，面向连接的数据平面实现报文在建立的标签转发路径上传送。MPLS域内，交换机不需要查看每个报文的目的IP地址，只需要根据封装在IP头外面的标签进行转发即可，这样可以大大提高效率 MPLS转发与IP逐跳转发的关系MPLS是IP的承载层：MPLS转发与IP转发不冲突，它们的关系是如果能够使用MPLS转发，那么IP包会先封装成MPLS数据帧来转发。如果不能MPLS转发，就还是原来的ip逐跳转发。（也就是尽量优先MPLS，因为它会更快） 看上面的图，我们需要理解：整个MPLS域（可以进行MPLS转发的区域）是嵌在IP域上的，也就是MPLS域外部是IP域，它本身也运行IP域。 MPLS中一些基本概念，名词标签（Label）：是一个定长的，比较短的，只具有本地意义的标识。FEC（转发等价类）：一组或一类数据，这组数据分配的标签相同LSP（标签交换通道）：一个FEC的数据流，在不同的节点被赋予确定的标签,数据转发按照这些标签进行。数据流所走的路径就是LSP。LSR（Label Switching Router）： LSR是MPLS的网络的核心交换机，它提供标签交换和标签分发功能。LER（Label Switching Edge Router）：在MPLS的网络边缘，进入到MPLS网络的流量由LER分为不同的FEC，并为这些FEC请求相应的标签。它提供流量分类和标签的映射、标签的移除功能。 从IP域进入MPLS域的时候，LER（标记边缘路由器）要做一个压入（push），出MPLS域的时候做一个弹出（pop），而LSR（标记交换路由器）负责转发。所以LER实际工作量比LSR大很多。LSP（标记交换路径）就是从进入到离开 走的路径。这条路径是在转发报文之前就已经通过各种协议确定并建立的，报文会在特定的LSP上传递。（也可以把LSP看成一个隧道） 标签报文格式： MPLS Header长度为32bits，包括长度为20bits的标签（Label），该标签用于报文转发；长度为3bits的EXP通常用来承载IP报文中的优先级；长度为1bit的栈底标志S用来表明是否是最后一个标签（MPLS标签可以多层嵌套）；长度为8bits的TTL，作用类似IP头部的TTL，用来防止报文环路等。 事实上MPLS封装有两种方式，上面说的是帧模式，Ethernet和PPP都是帧模式封装；还有一个信元封装模式（ATM采用）。MPLS的 LSP 与标签转发表 MPLS转发过程 1.Push：首先从IP数据包从ip域进入MPLS域，入口LER做 push 操作，分析转发等价类，为数据包“打上标签”，绑定LSP通道；图中A的标签转发表内容大概如下： 2.Swap：B，C两个LSR根据标签转发表，用下一跳分配的标签，替换MPLS报文的标签并转发 3.Pop：转发到出口LER D时，进行pop弹出操作，去掉标签 MPLS转发的过程到这里结束。 PHP（倒数第二跳弹出。Penultimate Hop Popping ，和web开发的php可没关系）：上面的过程我们可以发现，C在发给D时，其实带标签的数据已经没有意义，因为下一跳就要弹出标签了，所以完全可以在C就把标签弹出，然后以ip报文形式转发给D。这样可以大大降低最后的出口LER的工作量，是现在MPLS普遍采用的方法。默认情况下，设备支持PHP特性，支持PHP的Egress节点即出口LER 分配给倒数第二跳节点的标签值为3。 MPLS标签转发表与LDP 我们知道，交换机中的MAC地址表是通过逆向学习法产生的；路由器中的路由表是通过路由协议学习或自己配置静态路由产生的。那么MPLS中标签转发表是怎么产生的呢？ 答案是也会有一个类似的路由器学习的协议，这个协议叫做LDP（Label Distribution Protocol 标签分发协议），这个也是MPLS技术的核心协议之一。LDP来完成标签的分配控制和保持 从整个MPLS架构看这个协议的位置： 以上是MPLS架构图MPLS包括两个平面：控制平面和数据平面。控制平面负责产生和维护路由信息以及标签信息。数据平面负责普通IP报文的转发以及带MPLS标签报文的转发。控制平面中路由协议模块（Routing Protocol）用来传递路由信息，生成路由信息表；标签分发协议模块（Label Distribution Protocol）用来完成标签信息的交换，建立标签转发路径。数据平面包括IP转发表和标签转发表，当收到普通IP报文时（Incoming IP Packets），如果是普通IP转发，则查找IP路由表转发，如果需要标签转发，则按照标签转发表转发；当收到带有标签的报文时（Incoming Labeled Packets）时，如果需要按照标签转发，根据标签转发表转发，如果需要转发到IP网络，则去掉标签后根据IP转发表转发。 LDP的标签管理与保留方式主要内容有下面三部分 标签分配模式 DoD：下游按需标记分发DU：下游自主标记分发2. 标签控制模式 有序方式独立方式 标签保持模式 保守模式自由模式最常用的组合是 下游自主（DU） + 有序 + 自由 下面来具体介绍什么意思 这里先要理解上游，下游的概念，MPLS入口出为最上游；出口处为最下游。标签的产生可以理解为是下游为上游产生的，下游产生的IN标签作为上游的OUT标签（比如图中R3左边要接收的IN标签为100，那么R2向右的OUT标签就要是100，因为R3只要为100的标签） 然后具体介绍上面的三个部分：Ⅰ.标签的控制模式（即标签是怎么产生的）：有序（常用）：只有最下游路由器才能产生标签，最下游的上游收到最下游的标签映射消息后，然后才能再往自己的上游发送标签映射关系。独立：中间的路由器也可以直接产生标签 Ⅱ.标签的分发模式：下游按需 ：需要的时候上游再向下游询问标签信息；下游自主：不管有没有问，下游路由器都自主的向上游发送标签映射信息（主动向上汇报）Ⅲ.标签的保留模式：如果有两条路径，也就会有两个标签，那么路由器保留哪个。保守：只保留路由表中的”最佳路径“，跳数比较少的；自由：保留所有的标签，虽然占用了更多的标签空间，但是收敛会快 基础实验 配置步骤： 完成ip和ospf配置： R1的配置如下： [R1] interface GigabitEthernet0&#x2F;0&#x2F;0 [R1-GigabitEthernet0&#x2F;0&#x2F;0] ip address 12.1.1.1 24 [R1] interface loopback0 [R1-Loopback0] ip address 1.1.1.1 32 [R1] ospf 1 router-id 1.1.1.1 [R1-ospf-1] area 0 [R1-ospf-1-0.0.0.0] network 12.1.1.0 0.0.0.255 [R1-ospf-1-0.0.0.0] network 1.1.1.1 0.0.0.0 R2的配置如下： [R2] interface GigabitEthernet0&#x2F;0&#x2F;0 [R2-GigabitEthernet0&#x2F;0&#x2F;0] ip address 12.1.1.2 24 [R2] interface GigabitEthernet0&#x2F;0&#x2F;1 [R2-GigabitEthernet0&#x2F;0&#x2F;1] ip address 23.1.1.2 24 [R2] interface loopback0 [R2-Loopback0] ip address 2.2.2.2 32 [R2] ospf 1 router-id 2.2.2.2 [R2-ospf-1] area 0 [R2-ospf-1-0.0.0.0] network 12.1.1.0 0.0.0.255 [R2-ospf-1-0.0.0.0] network 23.1.1.0 0.0.0.255 [R2-ospf-1-0.0.0.0] network 2.2.2.2 0.0.0.0 R3的配置如下： [R3] interface GigabitEthernet0&#x2F;0&#x2F;0 [R3-GigabitEthernet0&#x2F;0&#x2F;0] ip address 23.1.1.3 24 [R3] interface GigabitEthernet0&#x2F;0&#x2F;1 [R3-GigabitEthernet0&#x2F;0&#x2F;1] ip address 34.1.1.3 24 [R3] interface loopback0 [R3-Loopback0] ip address 3.3.3.3 32 [R3] ospf 1 router-id 3.3.3.3 [R3-ospf-1] area 0 [R3-ospf-1-0.0.0.0] network 23.1.1.0 0.0.0.255 [R3-ospf-1-0.0.0.0] network 34.1.1.0 0.0.0.255 [R3-ospf-1-0.0.0.0] network 1.1.1.1 0.0.0.0 R4的配置如下： [R4] interface GigabitEthernet0&#x2F;0&#x2F;0 [R4-GigabitEthernet0&#x2F;0&#x2F;0] ip address 34.1.1.4 24 [R4] interface loopback0 [R4-Loopback0] ip address 4.4.4.4 32 [R4] ospf 1 router-id 4.4.4.4 [R4-ospf-1] area 0 [R4-ospf-1-0.0.0.0] network 34.1.1.0 0.0.0.255 [R4-ospf-1-0.0.0.0] network 4.4.4.4 0.0.0.0 激活mpls并激活ldp （全局和接口下都需要激活） R1的配置如下： [R1] mpls lsr-id 1.1.1.1 #配置MPLS LSR ID [R1] mpls #全局激活MPLS [R1-mpls] quit [R1] mpls ldp #全局激活LDP [R1-mpls-ldp] quit [R1] Interface GigabitEthernet 0&#x2F;0&#x2F;0 [R1-GigabitEthernet0&#x2F;0&#x2F;0] mpls #在接口上激活MPLS [R1-GigabitEthernet0&#x2F;0&#x2F;0] mpls ldp #在接口上激活LDP R2的配置如下： [R2] mpls lsr-id 2.2.2.2 [R2] mpls [R2-mpls] quit [R2] mpls ldp [R2-mpls-ldp] quit [R2] Interface GigabitEthernet 0&#x2F;0&#x2F;0 [R2-GigabitEthernet0&#x2F;0&#x2F;0] mpls [R2-GigabitEthernet0&#x2F;0&#x2F;0] mpls ldp [R2] Interface GigabitEthernet 0&#x2F;0&#x2F;1 [R2-GigabitEthernet0&#x2F;0&#x2F;1] mpls [R2-GigabitEthernet0&#x2F;0&#x2F;1] mpls ldp R3的配置如下： [R3] mpls lsr-id 3.3.3.3 [R3] mpls [R3-mpls] quit [R3] mpls ldp [R3-mpls-ldp] quit [R3] Interface GigabitEthernet 0&#x2F;0&#x2F;0 [R3-GigabitEthernet0&#x2F;0&#x2F;0] mpls [R3-GigabitEthernet0&#x2F;0&#x2F;0] mpls ldp [R3] Interface GigabitEthernet 0&#x2F;0&#x2F;1 [R3-GigabitEthernet0&#x2F;0&#x2F;1] mpls [R3-GigabitEthernet0&#x2F;0&#x2F;1] mpls ldp R4的配置如下： [R4] mpls lsr-id 4.4.4.4 [R4] mpls [R4-mpls] quit [R4] mpls ldp [R4-mpls-ldp] quit [R4] Interface GigabitEthernet 0&#x2F;0&#x2F;0 [R4-GigabitEthernet0&#x2F;0&#x2F;0] mpls [R4-GigabitEthernet0&#x2F;0&#x2F;0] mpls ldp 验证： display mpls ldp peer LDP Peer Information in Public network A ‘*’ before a peer means the peer is being deleted. -—————————————————————————– PeerID TransportAddress DiscoverySource -—————————————————————————– 2.2.2.2:0 2.2.2.2 GigabitEthernet0&#x2F;0&#x2F;0 -—————————————————————————– TOTAL: 1 Peer(s) Found. 以上输出的是R1的LDP邻居表，从表中可以看出R1已经发现了一个LDP邻居，那就是R2。 disp mpls ldp session verbose LDP Session(s) in Public Network -—————————————————————————– Peer LDP ID : 2.2.2.2:0 Local LDP ID : 1.1.1.1:0 TCP Connection : 1.1.1.1 &lt;- 2.2.2.2 Session State : Operational Session Role : Passive Session FT Flag : Off MD5 Flag : Off Reconnect Timer : — Recovery Timer : — Keychain Name : — Negotiated Keepalive Hold Timer : 45 Sec Configured Keepalive Send Timer : — Keepalive Message Sent&#x2F;Rcvd : 153&#x2F;153 (Message Count) Label Advertisement Mode : Downstream Unsolicited Label Resource Status(Peer&#x2F;Local) : Available&#x2F;Available Session Age : 0000:00:38 (DDDD:HH:MM) Session Deletion Status : No Capability: Capability-Announcement : Off P2MP Capability : Off Outbound&amp;Inbound Policies applied : NULL Addresses received from peer: (Count: 3) 2.2.2.2 12.1.1.2 23.1.1.2 -—————————————————————————– 以上输出的是LDP会话的详细信息，邻居的状态必须为Operational才是最终的稳态，另外从TCP连接1.1.1.1 &lt; 2.2.2.2可以验证一点，LDP的会话建立是由传输地址大的一方发起的。 display mpls ldp lsp LDP LSP Information -—————————————————————————— DestAddress&#x2F;Mask In&#x2F;OutLabel UpstreamPeer NextHop OutInterface -—————————————————————————— 1.1.1.1&#x2F;32 3&#x2F;NULL 2.2.2.2 127.0.0.1 InLoop0 *1.1.1.1&#x2F;32 Liberal&#x2F;1026 DS&#x2F;2.2.2.2 2.2.2.2&#x2F;32 NULL&#x2F;3 - 12.1.1.2 GE0&#x2F;0&#x2F;0 2.2.2.2&#x2F;32 1026&#x2F;3 2.2.2.2 12.1.1.2 GE0&#x2F;0&#x2F;0 3.3.3.3&#x2F;32 NULL&#x2F;1024 - 12.1.1.2 GE0&#x2F;0&#x2F;0 3.3.3.3&#x2F;32 1024&#x2F;1024 2.2.2.2 12.1.1.2 GE0&#x2F;0&#x2F;0 4.4.4.4&#x2F;32 NULL&#x2F;1025 - 12.1.1.2 GE0&#x2F;0&#x2F;0 4.4.4.4&#x2F;32 1025&#x2F;1025 2.2.2.2 12.1.1.2 GE0&#x2F;0&#x2F;0 -—————————————————————————— TOTAL: 7 Normal LSP(s) Found. TOTAL: 1 Liberal LSP(s) Found. TOTAL: 0 Frr LSP(s) Found. A ‘*’ before an LSP means the LSP is not established A ‘*’ before a Label means the USCB or DSCB is stale A ‘*’ before a UpstreamPeer means the session is stale A ‘*’ before a DS means the session is stale A ‘*’ before a NextHop means the LSP is FRR LSP 以上输出的是R1的LFIB（标签转发信息库），可以看到已经建立好的LSP。 实际上，当我们再R1、R2、R3、R4上运行OSPF后，全网的路由已经被打通，也就是每台路由器都拥有全网的路由，其中包括互联网段的路由，以及各设备的Loopback路由。随后我们激活各设备的MPLS和LDP，每台设备会基于自己的路由表中的路由前缀进行标签捆绑，并且将为路由前缀（FEC）所捆绑的标签分发给自己的LDP邻居。默认情况下在我司的设备上，仅为&#x2F;32的主机路由分发标签，并且默认水平分割规则并未打开。 现在，来测试一下，从R1去tracert 4.4.4.4： tracert lsp ip 4.4.4.4 32 LSP Trace Route FEC: IPV4 PREFIX 4.4.4.4&#x2F;32 , press CTRL_C to break. TTL Replier Time Type Downstream 0 Ingress 12.1.1.2&#x2F;[1025 ] 1 12.1.1.2 20 ms Transit 23.1.1.3&#x2F;[1024 ] 2 23.1.1.3 20 ms Transit 34.1.1.4&#x2F;[3 ] 3 4.4.4.4 20 ms Egress 从tracert的结果我们可以看到数据包行走的路径，以及被压入的标签。","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"mpls","slug":"mpls","permalink":"http://example.com/tags/mpls/"}]},{"title":"Hybrid接口","slug":"Hybrid接口","date":"2023-12-05T05:30:11.000Z","updated":"2023-12-05T05:40:22.635Z","comments":true,"path":"2023/12/05/Hybrid接口/","permalink":"http://example.com/2023/12/05/Hybrid%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"接口属性​ 交换机接口的类型，可以是Access、Trunk和Hybrid。Access类型的接口仅属于一个VLAN,,,,只能接收、转发相应VLAN的帧；而Trunk类型接口则默认属于所有VLAN任何Tagged帧都能经过Trunk接收和转发； Hybrid类型接口则介于二者之间，可自主定义端口上能接收和转发那些VLAN Tag帧，并可决定VLAN Tag是否继续携带或者剥离。。Access和Trunk类型接口是Hybrid类型接口的两个特例，，，一个仅支持一个VLAN传递，，一个默认支持所有VLAN的传递，而Access类型和Trunk类型的接口能做到的，Hybrid接口都能做到。 ​ hybrid属性具有trunk和access两种端口属性的特点，tag类似trunk，untag类似access，但是又不同，因为hybrid端口可以接收某个或者多个vlan的数据。 在开始研究之前强调几点： 1、在hybrid端口中，所有端口都默认属于vlan1，除非配置undo port hybrid vlan 1 才能将该hybrid剔除出vlan1，可以使用display vlan 查看端口所属的vlan 2、在hybrid端口中，无论是tag还是untag后面配置的vlan-id就是该hybrid端口所能够收到vlan数据的vlan-id，换句话说就是这些vlan中发出的数据该端口都能收到，可以使用display vlan查看（这里注意虽然可以收到这些vlan的数据但是严格意义上讲hybrid端口并不属于任何一个vlan） 3、所有类型端口的默认pvid都是vlan1，而pvid这个属性只！针对！进入！该端口的！没有标签的！普通数据包有效，作用是将没有标签的普通数据包打上pvid中配置的标签号 4、hybrid属性中，tag是针对于端口的接收方向的（从该端口进来的流量允许带有这些vlan标签的通过），untag是针对端口的发送方向的（从该端口出去的流量去除这些vlan标签） 5、加入一个hybrid端口配置tag vlan 2 3和untag vlan 4 5 ，那么默认情况下这个hybrid属于vlan1、2、3、4、5，在display vlan中可以查看到，只有端口属于了某个vlan，那么该端口才能收到某个vlan的数据包，这一点是理解下列两种配置和hybrid端口属性的关键！！！ 收发过程在数据发送时untag列表的原理，如下图1.带有vlan 3标签的数据从F0&#x2F;0接口出去，通过时查看untag列表，发现有对应的标签，将标签脱掉发送出去2.带有vlan 8标签的数据从F0&#x2F;1接口出去，通过时查看untag列表，发现没有对应的标签，继续查看tag表，发现有对应标签，所以直接带有vlan 8标签的数据发送出去3.带有vlan 5标签的数据从F0&#x2F;2接口出去，通过时查看untag列表，发现没有对应的标签 ，继续查看tag列表，发现也没有对应的标签，所以数据直接被丢弃 tag列表处理数据帧的接收和发送的原理，如下图1.没有标签的数据进入F0&#x2F;0接口，接口查看到数据没有标签，根据接口PVID&#x3D;3，将vlan 3标签打入数据2.带有vlan 9标签的数据进入接口F0&#x2F;1，接口查看到数据带有标签，接着查看tag列表，发现列表中存在对应标签，放通数据3.带有vlan 5标签的数据从接口F0&#x2F;2出去，接口查看到数据带有标签，查看untag列表，发现列表中没有对应vlan 5标签，继续查看tag列表，发现列表中存在对应标签vlan 5，放通数据出去4.带有vlan 3标签的数据从F0&#x2F;2接口出去，查看untag列表，发现列表中存在对应vlan 3标签，将标签脱掉，放通数据出去5.带有vlan 9标签的数据从F0&#x2F;2接口出去，查看untag表，发现列表中不存在对应vlan 9标签，继续查看tag列表，发现列表中不存在vlan 9标签，将数据丢弃 实例分析 1、为了让我们更加简洁的理解hydrid的属性，首先在所有的端口上移除了vlan1这个默认有的vlan，假设为所有端口初始不属于任何vlan，都不能相互之间通信 2、pvid是当普通的主机数据帧进入交换机端口后被打上的vlan-tag的属性，在途中可以看出PC1、PC2、PC3的流量在进入交换机的时候分别会被打上vlan2、vlan3、vlan99的vlan标签 3、untag后面的vlan就是该端口属于的vlan，那么不难看出LSW1的G0&#x2F;0&#x2F;1属于vlan2、3，G0&#x2F;0&#x2F;2属于vlan2、10，G0&#x2F;0&#x2F;3属于vlan3、10，而untag的动作是在流量出端口去往主机的时候把vlan-tag全部去除，那么不难看出LSW1的G0&#x2F;0&#x2F;1将去除vlan2、3的标签，G0&#x2F;0&#x2F;2去除vlan2、10的标签，G0&#x2F;0&#x2F;3去除vlan3、10的标签（还原成普通帧） LSW2的G0&#x2F;0&#x2F;1属于vlan99，G0&#x2F;0&#x2F;2属于vlan99，在流量出端口的时候会去除vlan99的标签（还原成普通帧） 那么PC1与PC2的通信现在分析如下：当PC1发送arp去请求PC2的MAC地址的时候，PC1会将数据包广播发往LSW1的G0&#x2F;0&#x2F;2接口，LSW1收到后发现是个普通的不带标签的数据帧，于是根据接口的pvid给该帧打上vlan2的tag，然后往vlan2中进行泛红，无奈G0&#x2F;0&#x2F;3端口只属于vlan3、10所以无法收到vlan2中的泛红，故PC1与PC2通信失败。 下面再来分析PC1与PC3通信：前面已经分析了PC1要去请求PC3的MAC，被LSW1的G0&#x2F;0&#x2F;2收到，并且打上vlan2的tag，然后在vlan2中泛红，那么在vlan2中的端口就都能收到该泛红了，所以在配置了untag vlan 2 3的G0&#x2F;0&#x2F;1端口自然也能收到vlan2和vlan3的泛红并转发出去，但是LSW1发现G0&#x2F;0&#x2F;1配置untag vlan2 3，所以将从该端口发送出去的所有带有vlan2和vlan3的数据包的tag全部去除（还原成普通帧），然后这个普通的帧就会发往LSW2被G0&#x2F;0&#x2F;1端口接收到，LSW2发现了一个普通的帧，那么就会用到pvid了不是，所以LSW2收到这个帧后打上vlan99的tag进行泛红，那么PC3所在的hybrid因为配置有untag vlan99必然能够收到vlan99的数据包了，然后在G0&#x2F;0&#x2F;2发给PC3的时候将vlan99的tag去除掉，PC3收到的就是一个不带任何tag的普通包（PC3完全不知道在它个PC1之间还有SW这种东西存在），好了PC3收到了PC1发来的arp请求，那么作为有礼貌的人应该回复自己的MAC地址了，与回一个arp响应给PC1， 下面PC3的回包分析：PC3使用PC1的MAC和ip封装好数据包后从网卡发送出去，LSW2的G0&#x2F;0&#x2F;2端口收到了，发现是一个普通帧，OK来pvid打上vlan99的tag，然后查看mac地址表发现PC1的MAC地址在G0&#x2F;0&#x2F;1口，在查看vlan信息，发现G0&#x2F;0&#x2F;1口可以接收vlan99的数据（untag vlan99），两个转发条件都满足了，那么久把数据包发给G0&#x2F;0&#x2F;1转发，G0&#x2F;0&#x2F;1转发的时候根据untag vlan99把数据包vlan-id去除还原成普通帧，被LSW1的G0&#x2F;0&#x2F;1收到，按照pvid的惯例，普通帧被打上了pvid vlan10的tag（用vlan10举例，也可以是任意vlan），然后LSW1根据MAC地址表找到PC1在自己的G0&#x2F;0&#x2F;2口，再查看vlan信息发现G0&#x2F;0&#x2F;2接口配置了untag vlan2 10，可以接收vlan10的数据包，于是就把这个被打上vlan10的PC3发来的arp响应通过G0&#x2F;0&#x2F;2发送给了PC1，当然在从G0&#x2F;0&#x2F;2接口出去的时候根据untag vlan2 10的配置将vlan10的tag去除还原成一个普通的帧，PC1收到的是一个普通的帧，完全不知道它和PC3之间还有交换机这个东西。好了，这就是一次通信过程，PC2与PC3的通信原理也是一样的，于是就实现了PC3与PC1、PC2互通，PC1与PC2之间不通的效果。","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"hybrid","slug":"hybrid","permalink":"http://example.com/tags/hybrid/"},{"name":"tag","slug":"tag","permalink":"http://example.com/tags/tag/"}]},{"title":"telnet","slug":"telnet","date":"2023-12-02T09:19:24.000Z","updated":"2023-12-02T09:35:21.015Z","comments":true,"path":"2023/12/02/telnet/","permalink":"http://example.com/2023/12/02/telnet/","excerpt":"","text":"两种配置方法1.仅密码登录验证代码如下（示例）：system-view —–进入配置模式[Quidway]interface vlan 1 —–进入管理vlan[Quidway-Vlanif1]ip address 192.168.28.49 255.255.255.0 —–配置管理ip地址[Quidway-Vlanif1]quit —–退出[Quidway]telnet server enable —–打开telnet服务 （一般默认开启）[Quidway]user-interface vty 0 4 —–用户指定虚拟用户终端接口[Quidway-ui-vty0-4]authentication-mode password —–配置用户终端接口认证方式 密码验证[Quidway-ui-vty0-4]set authentication password cipher huawei123 —–设置接口验证密码,密码为huawei123[Quidway-ui-vty0-4]user privilege level 15 —–设置用户优先级 （可选）[Quidway-ui-vty0-4]idle-timeout 1 —–设置登陆超时为一分钟 （可选）[Quidway-ui-vty0-4]return —–返回用户视图save —–保存 2.配置AAA登录代码如下（示例）：system-view —–进入配置模式[Quidway]interface vlan 1 —–进入管理vlan[Quidway-Vlanif1]ip address 192.168.28.49 255.255.255.0 —–配置管理ip地址[Quidway-Vlanif1]quit —–退出[Quidway]telnet server enable —–打开telnet服务 （一般默认开启）[Quidway]user-interface vty 0 4 —–用户指定虚拟用户终端接口[Quidway-ui-vty0-4]authentication-mode aaa —–配置用户终端接口认证方式 aaa验证[Quidway-ui-vty0-4]user privilege level 15 —–设置用户优先级[Quidway-ui-vty0-4]idle-timeout 1 —–设置登陆超时为一分钟[Quidway-ui-vty0-4]quit —–退出[Quidway]aaa —–进入aaa[Quidway-aaa]local-user huawei password cipher huawei123 —–创建用户名huawei 密码huawei123[Quidway-aaa]local-user huawei privilege level 15 —–设置用户优先级[Quidway-aaa]local-user huawei service-type telnet —–授权用户使用telnet[Quidway-ui-vty0-4]return —–返回用户视图save —–保存 user-interface vty 0 4 详解Quidway]user-interface vty 0 4 ；进入虚拟终端[S3026-ui-vty0-4]authentication-mode password ；设置口令模式[S3026-ui-vty0-4]set authentication-mode password simple 222 ；设置口令[S3026-ui-vty0-4]user privilege level 3 一、第一句的意思是：进入到vty 终端，在华为的交换机里，vty就是人家用telnet远程进入到你交换机的界面，最多有五个，所以说你可以vty 0 vty 1 vty… vty 4交换机最多可以允许五个人同时在线进到交换机里去配置命令的。vty0 4 就是说把这五个界面一起配置了，这五个界面进去的话，都是使用以下的配置。二、用的认证模式是密码认证，可以使用scheme模式来，也可以用password来，用password的话，是要密码的，就是说你telnet的话，要输入密码才能登陆到包交换机里去的。二、设置密码为明文密码，密码是123 ，如果是密文的话，就是cipher四、用户等级为3，也就是最高的，华为的命令级别很多，分为四级，0 1 2 3 ，0是参观级，只能看，1比0要高，可以使用一些命令，2 是可以配置了，3可以备份与删除IOS啦，呵呵，这个命令就是说用这个123密码，进来就是最高级别的，不用换级别。","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"telnet","slug":"telnet","permalink":"http://example.com/tags/telnet/"},{"name":"aaa","slug":"aaa","permalink":"http://example.com/tags/aaa/"}]},{"title":"FTP实验","slug":"FTP实验","date":"2023-11-30T10:10:45.000Z","updated":"2023-11-30T10:55:14.400Z","comments":true,"path":"2023/11/30/FTP实验/","permalink":"http://example.com/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"File Transfer Protocol 文件传输协议FTP服务器开启21号端口进行控制连接，20号端口与客户端建立数据连接 ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言，它是最通用的信息交换标准。 FTP是用来传送文件的协议。使用FTP实现远程文件传输的同时，还可以保证数据传输的可靠性和高效性。 FTP 是基于客户———服务器（C&#x2F;S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接 传输方式FTP支持两种方式的传输：文本（ASCII）方式和二进制（Binary）方式。通常文本文件的传输采用ASCII方式，而图象、声音文件、加密和压缩文件等非文本文件采用二进制方式传输，如果为了从一个系统上传输文件而使用了与本地系统不同的计算机字节位数，那么就必须使用Tenex模式。FTP以ASCII方式作为缺省的文件传输方式。 传输过程 使用FTP进行文件传输时，会使用两个TCP连接。第一个连接是FTP客户端和FTP服务器间的控制连接。FTP服务器开启21号端口，等待FTP客户端发送连接请求。FTP客户端随机开启端口，向服务器发送建立连接的请求。控制连接用于在服务器和客户端之间传输控制命令。 第二个连接是FTP客户端和FTP服务器间的数据连接。服务器使用TCP的20号端口与客户端建立数据连接。通常情况下，服务器主动建立或中断数据连接。 FTP服务器配置路由器和X7系列交换机均可提供FTP功能。执行ftp server enable命令使能FTP功能。执行set default ftp-directory命令设置FTP用户的默认工作目录。 在配置FTP服务器时，可以使用AAA为每个用户分别配置登录账号和访问权限。 aaa命令用来进入AAA视图。 local-user user-name { access-limit max-number | ftp-directory directory | idle-timeout minutes [ seconds ] | password cipher password [ opt ] | privilege level level | state {active | block } } *命令用来创建本地用户，并配置本地用户的各项参数。 user-name指定用户名。 local-user huawei service-type ftp命令用来配置本地用户的接入类型为ftp。 ftp-directory指定FTP用户可访问的目录。如果不配置FTP用户可访问的目录，则FTP用户无法登录设备。 access-limit指定用户名可建立的最大连接数目。 idle-timeout指定用户的闲置超时时间。 privilege level指定用户的优先级。 命令详解idle-timeoutidle-timeout命令用来设置用户连接的超时时间。 undo idle-timeout命令用来恢复超时时间的缺省值。 缺省情况下，用户连接的超时时间是5分钟。 命令格式 idle-timeout minutes [ seconds ] undo idle-timeout minutes 指定用户界面断连的超时时间的分钟数。 整数形式，取值范围是0～35791，单位是分钟。 seconds 指定用户界面断连的超时时间的秒数。 整数形式，取值范围是0～59，单位是秒 缺省级别 3：管理级 设置执行命令idle-timeout 0 0即关闭用户界面的超时断连功能。 如果用户界面没有设置闲置断连功能，则会导致已登录的用户始终处于连接状态，给设备带来安全风险，同时还有可能导致其他用户无法获得连接。 通常情况下，推荐设置用户界面断连的超时时间在10～15分钟之间。 # 设置超时为1分钟30秒。 1idle-timeout 1 30 local-user privilege level必须配置在3以上，否则ftp连接无法成功 local-user privilege level命令用来配置本地用户的优先级。 undo local-user privilege level命令用来将本地用户的优先级恢复为缺省配置。 缺省情况下，本地用户（如Telnet用户、SSH用户）的优先级由管理模块来决定。 命令格式 local-user user-name privilege level level undo local-user user-name privilege level user-name 用户名。 字符串形式，不支持空格，不区分大小写，长度范围是1~64。 level 用户的优先级。 整数形式，取值范围是0~15，取值越大，用户的优先级越高。缺省级别是0级。不同级别的用户登录后，只能使用等于或低于自己级别的命令 缺省情况下，命令级别分为0~3级： 级别0即参观级，网络诊断工具命令（ping、tracert）、从本设备出发访问外部设备的命令（包括：Telnet 客户端、SSH）等。该级别命令不允许进行配置文件保存的操作。 级别1即监控级，用于系统维护，包括display命令。该级别命令不允许进行配置文件保存的操作。 级别2即配置级，可以使用业务配置命令，包括路由、各个网络层次的命令，向用户提供直接网络服务。 级别3即管理级，用于系统基本运行的命令，对业务提供支撑作用，包括文件系统、FTP、TFTP、配置文件切换命令、备板控制命令、用户管理命令、命令级别设置命令、系统内部参数设置命令；用于业务故障诊断的debugging命令。 access-limitaccess-limit命令用来配置当前域允许接入的用户数。 undo access-limit命令用来恢复缺省配置。 缺省情况下，不限制接入的用户数目。 命令格式 access-limit max-number undo access-limit max-number 指定允许接入的用户数。 整数形式，取值范围是0～283648。 为了更方便地管理用户访问设备，可以限制域下用户的在线数量。 注意事项 执行这条配置命令后，当接入用户数大于允许的用户数时，系统不再允许用户接入系统，提示用户认证失败。 access-limit命令对一个域下所能接入的用户总数进行限制，不区分接入用户的类型。 # 设置当前域最多允许接入100个用户。 1access-limit 100 local-user ftp-directorylocal-user ftp-directory命令用来配置本地用户的FTP目录。 undo local-user ftp-directory命令用来将本地用户的FTP目录恢复为缺省配置。 缺省情况下，本地用户的FTP目录为空。 当需要将设备配置为FTP服务器，从而便于本地用户以FTP方式登录设备，对设备上的文件进行增加、删除、修改等操作时，可以通过本命令配置本地用户以FTP方式登录设备后所处的目录。 不指定该目录时，本地用户无法以FTP方式登录设备。 配置本地用户的FTP目录时，该用户必须已由local-user password命令建立。 local-user passwordlocal-user password命令用来创建一个本地用户并配置该用户的登录密码，或者修改已创建用户的登录密码。 undo local-user命令用来删除一个本地用户。 缺省情况下，系统没有本地用户。 local-user user-name password [ cipher password | irreversible-cipher irreversible-cipher-password ] undo local-user user-name cipher password 指定密文密钥。密钥以明文或密文形式输入，但配置文件中保存为密文形式。 irreversible-cipher irreversible-cipher-password 指定不可逆密文密钥。密钥以明文或不可逆密文形式输入，但配置文件中保存为密文形式。 总结1.FTP服务器需要开启TCP的21号端口来建立控制连接，20号端口来建立数据连接。 2.如果用户无权访问任何工作目录，则需要定义一个默认的FTP目录。执行set default ftp-directory 命令建立默认目录。 FTP实验R1 做为FTP Server 进行配置R2 做为Client 测试 R1：undo ter mosyssysname R1int g0&#x2F;0&#x2F;0ip add 192.168.1.1 24 R2：undo ter mosyssysname R2int g0&#x2F;0&#x2F;0ip add 192.168.1.2 24 R1:ftp server enableset default ftp-directory flash:&#x2F; （设置默认目录为flash:&#x2F;） ftp server enable命令用来开启设备的FTP服务器功能，允许FTP用户登录。缺省情况下，FTP服务器功能处于关闭状态。 其他可选的配置参数还包括：指定FTP服务器端口号、指定FTP服务器的源地址和配置FTP连接空闲时间等。 R1： 通过在AAA中设置用户名和密码（均为huawei）aaalocal-user huawei password cipher huaweilocal-user huawei service-type ftplocal-user huawei ftp-directory flash:&#x2F;local-user huawei access-limit 200local-user huawei idle-timeout 0 0local-user huawei privilege level 3 查看ftp server配置信息 R2登录FTP服务器 在R1和R2上分别保存文件text1.cfg和text2.cfg，用于后续测试 R1：save text1.cfg R2：save text2.cfg R2上通过dir命令查看服务器上的文件 R2从服务器上下载text1.cfg文件，并改名为newtext1.cfg R2本地查看dir put把本地文件text2.cfg上传到服务器，并改名为newtext2.cfg 查看是否上传成功 关闭ftp连接：bye","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"FTP","slug":"FTP","permalink":"http://example.com/tags/FTP/"}]},{"title":"VRRP基础实验","slug":"VRRP基础实验","date":"2023-11-29T13:01:52.000Z","updated":"2023-11-29T13:33:55.792Z","comments":true,"path":"2023/11/29/VRRP基础实验/","permalink":"http://example.com/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"设备连接方式如图所示，网络中存在VLAN10、20，每个VLAN中部署一组VRRP，使用与VLAN ID相同的数值作为VRID，将S1配置为VLAN10的VRRP Master，将S2配置为VLAN20的VRRP Master。 同时在S1、S2、S3上部署MSTP，创建Instance 1、2，将VLAN10映射到MSTI 1、VLAN20映射到MSTI 2，将S1配置为MSTI 1的主根桥、MSTI 2的备份根桥，而将S2配置为MSTI 1的备份根桥、MSTI 2的主根桥。 VLANIF接口地址使用10.0.x.y&#x2F;24，其中x为VRID组号，y为设备编号，VRIP使用10.0.x.254&#x2F;24。 #创建VLAN [S1]vlan batch 10 20 [S2]vlan batch 10 20 [S3]vlan batch 10 20 [S4]vlan batch 10 20 #将所有互联接口配置为Trunk接口，放通对应VLAN 略 #修改STP模式为MSTP [S1]stp mode mstp [S2]stp mode mstp [S3]stp mode mstp #配置MSTP [S1]stp region-configuration [S1-mst-region] region-name hcip [S1-mst-region] revision-level 1 [S1-mst-region] instance 1 vlan 10 [S1-mst-region] instance 2 vlan 20 [S1-mst-region] active region-configuration Info: This operation may take a few seconds. Please wait for a moment…done. [S1-mst-region] quit [S2]stp region-configuration [S2-mst-region] region-name hcip [S2-mst-region] revision-level 1 [S2-mst-region] instance 1 vlan 10 [S2-mst-region] instance 2 vlan 20 [S2-mst-region] active region-configuration Info: This operation may take a few seconds. Please wait for a moment…done. [S2-mst-region] quit [S3]stp region-configuration [S3-mst-region] region-name hcip [S3-mst-region] revision-level 1 [S3-mst-region] instance 1 vlan 10 [S3-mst-region] instance 2 vlan 20 [S3-mst-region] active region-configuration Info: This operation may take a few seconds. Please wait for a moment…done. [S3-mst-region] quit #配置SW1为MSTI1的根桥、MSTI2的备份根桥 [S1]stp instance 1 root primary [S1]stp instance 2 root secondary #配置SW2为MSTI2的根桥、MSTI1的备份根桥 [S2]stp instance 1 root secondary [S2]stp instance 2 root primary #在S1上查看MSTI1的状态和统计信息摘要 S1上所有接口都是指定接口，S1为MSTI1的根桥。 #在S2上查看MSTI2的状态和统计信息摘要 S2上所有接口都是指定接口，S2为MSTI1的根桥。 VRRP基础配置在S1、S2均创建VLANIF 10、20，分别加入VRRP组10、20，手动配置VRRP优先级，使得S1的VLAN10成为VRRP Master、S2的VLAN20成为VRRP Master。 #创建VLANIF [S1]interface Vlanif10 [S1-Vlanif10] ip address 10.0.10.1 255.255.255.0 [S1-Vlanif10] quit [S1]interface Vlanif20 [S1-Vlanif20] ip address 10.0.20.1 255.255.255.0 [S1-Vlanif20] quit [S2]interface Vlanif10 [S2-Vlanif10] ip address 10.0.10.2 255.255.255.0 [S2-Vlanif10] quit [S2]interface Vlanif20 [S2-Vlanif20] ip address 10.0.20.2 255.255.255.0 [S2-Vlanif20] quit #S1上配置VRRP [S1]interface Vlanif 10 [S1-Vlanif10] vrrp vrid 10 virtual-ip 10.0.10.254 [S1-Vlanif10] vrrp vrid 10 priority 120 [S1-Vlanif10] quit [S1]interface Vlanif 20 [S1-Vlanif20] vrrp vrid 20 virtual-ip 10.0.20.254 [S1-Vlanif20] quit 配置VLAN10的VRRP优先级为120，VLAN20保持默认的100。 #S2上配置VRRP [S2]interface Vlanif10 [S2-Vlanif10] vrrp vrid 10 virtual-ip 10.0.10.254 [S2-Vlanif10] quit [S2]interface Vlanif20 [S2-Vlanif20] vrrp vrid 20 virtual-ip 10.0.20.254 [S2-Vlanif20] vrrp vrid 20 priority 120 [S2-Vlanif20] quit 配置VLAN20的VRRP优先级为120，VLAN10保持默认的100。 #查看VRRP组状态 配置VRRP与BFD联动进行快速切换在S1、S2上配置BFD单跳检测，检测VLANIF接口之间的连通性，将VRRP与BFD联动，当BFD会话状态Down时，增加VRRP Backup设备的优先级。 #在S1上配置BFD会话 [S1]bfd [S1-bfd] quit [S1]bfd vlanif10 bind peer-ip 10.0.10.2 interface Vlanif10 [S1-bfd-session-vlanif10] discriminator local 1 [S1-bfd-session-vlanif10] discriminator remote 2 [S1-bfd-session-vlanif10] min-tx-interval 100 [S1-bfd-session-vlanif10] min-rx-interval 100 [S1-bfd-session-vlanif10] commit [S1-bfd-session-vlanif10] quit [S1]bfd vlanif20 bind peer-ip 10.0.20.2 interface Vlanif20 [S1-bfd-session-vlanif20] discriminator local 11 [S1-bfd-session-vlanif20] discriminator remote 22 [S1-bfd-session-vlanif20] min-tx-interval 100 [S1-bfd-session-vlanif20] min-rx-interval 100 [S1-bfd-session-vlanif20] commit [S1-bfd-session-vlanif20] quit #在S2上配置BFD会话 [S2]bfd [S2-bfd] quit [S2]bfd vlanif10 bind peer-ip 10.0.10.1 interface Vlanif10 [S2-bfd-session-vlanif10] discriminator local 2 [S2-bfd-session-vlanif10] discriminator remote 1 [S2-bfd-session-vlanif10] min-tx-interval 100 [S2-bfd-session-vlanif10] min-rx-interval 100 [S2-bfd-session-vlanif10] commit [S2-bfd-session-vlanif10] quit [S2]bfd vlanif20 bind peer-ip 10.0.20.1 interface Vlanif20 [S2-bfd-session-vlanif20] discriminator local 22 [S2-bfd-session-vlanif20] discriminator remote 11 [S2-bfd-session-vlanif20] min-tx-interval 100 [S2-bfd-session-vlanif20] min-rx-interval 100 [S2-bfd-session-vlanif20] commit [S2-bfd-session-vlanif20] quit #检查BFD会话状态 此时S1、S2上BFD会话状态都为Up。 #配置VRRP与BFD联动 [S1]interface Vlanif20 [S1-Vlanif20] vrrp vrid 20 track bfd-session 11 increased 30 [S1-Vlanif20] quit [S2]interface Vlanif10 [S2-Vlanif10] vrrp vrid 10 track bfd-session 2 increased 30 [S2-Vlanif10] quit 注意，此处的bfd-session号为本地的BFD discriminator，只需要在Backup状态的接口上配置联动，BFD会话Down时增加本地的VRRP优先级。 #关闭S1上所有接口，模拟链路故障 [S1]interface GigabitEthernet0&#x2F;0&#x2F;10 [S1-GigabitEthernet0&#x2F;0&#x2F;10] shutdown [S1-GigabitEthernet0&#x2F;0&#x2F;10] quit [S1]interface GigabitEthernet0&#x2F;0&#x2F;11 [S1-GigabitEthernet0&#x2F;0&#x2F;11] shutdown [S1-GigabitEthernet0&#x2F;0&#x2F;11] quit [S1]interface GigabitEthernet0&#x2F;0&#x2F;12 [S1-GigabitEthernet0&#x2F;0&#x2F;12] shutdown [S1-GigabitEthernet0&#x2F;0&#x2F;12] quit #在S2上查看BFD会话状态 此时两个BFD会话状态立马变为Down。 #在S2上查看VRRP组状态 VRRP组10、20的Master此时都是S2。 #在S2上查看VRRP组的状态和配置参数信息","categories":[],"tags":[{"name":"VRRP","slug":"VRRP","permalink":"http://example.com/tags/VRRP/"},{"name":"BFD","slug":"BFD","permalink":"http://example.com/tags/BFD/"}]},{"title":"BGP路由优选","slug":"BGP路由优选","date":"2023-11-28T10:19:34.000Z","updated":"2023-11-28T11:52:29.140Z","comments":true,"path":"2023/11/28/BGP路由优选/","permalink":"http://example.com/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/","excerpt":"BGP路由优选实验背景你是公司的网络管理员。公司的网络采用了BGP协议接入了两个服务运营商。公司自己采用了私有的AS号64512，ISP1的AS号为100，ISP2的AS号为200。通过AS100、AS200都可以到达相同的网络，你通过改变BGP的各种属性达到了调整路由走向的目的。","text":"BGP路由优选实验背景你是公司的网络管理员。公司的网络采用了BGP协议接入了两个服务运营商。公司自己采用了私有的AS号64512，ISP1的AS号为100，ISP2的AS号为200。通过AS100、AS200都可以到达相同的网络，你通过改变BGP的各种属性达到了调整路由走向的目的。 实验介绍： 设备互联方式、互联接口地址如图所示，所有设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号，所有设备都使用Loopback0地址作为BGP Router ID。 R1在AS100，R5在AS200，R2、R3、R4在AS64512。AS64512内运行OSPF，在互联接口（不包括连接外部AS的接口）、Loopback0接口上激活OSPF。 EBGP对等体关系基于直连接口建立，IBGP对等体关系基于Loopback0接口建立。 R1、R5上存在相同的网段172.16.1.0&#x2F;24、172.16.2.0&#x2F;24、172.16.3.0&#x2F;24、172.16.4.0&#x2F;24，在R1、R5上将其发布到BGP，以用于BGP路由优选。 配置ip，配置bgp：略 #在R1、R5上将Loopback1、Loopback2、Loopback3、Loopback4接口路由发布到BGP中 [R1]bgp 100 [R1-bgp] network 172.16.1.0 24 [R1-bgp] network 172.16.2.0 24 [R1-bgp] network 172.16.3.0 24 [R1-bgp] network 172.16.4.0 24 [R5]bgp 200 [R5-bgp] network 172.16.1.0 24 [R5-bgp] network 172.16.2.0 24 [R5-bgp] network 172.16.3.0 24 [R5-bgp] network 172.16.4.0 24 #在R3上查看BGP路由表，检查BGP路由是否成功学习 R3已经成功学习R1、R5发布的路由，此时所有路由都优选由R2通告的。 修改AS_Path属性在R1上通过路由策略修改BGP路由172.16.1.0&#x2F;24的 AS_Path属性值，使得R3优选R5发布的BGP路由172.16.1.0&#x2F;24。 #创建IP前缀列表1，匹配Loopback1接口路由 [R1]ip ip-prefix 1 permit 172.16.1.0 24 greater-equal 24 less-equal 24 #创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1，修改AS_Path属性值 [R1]route-policy hcip permit node 10 [R1-route-policy] if-match ip-prefix 1 [R1-route-policy] apply as-path 300 400 additive [R1-route-policy] quit [R1]route-policy hcip permit node 20 注意创建一个空节点，对于另外3条BGP路由不执行任何操作。 #对向BGP对等体R2通告的BGP路由应用Route-Policy [R1]bgp 100 [R1-bgp] peer 10.0.12.2 route-policy hcip export #在R1上触发出方向的软复位，刷新对外通告的BGP路由 refresh bgp all export #在R3上查看BGP路由172.16.1.0&#x2F;24的明细信息 此时R3优选R4通告的BGP路由172.16.1.0&#x2F;24，R2通告的未被优选的原因是AS_Path长度。 修改Local_Preference属性local_Preference：默认100，越大越优先，只能在ibgp对等体之间传递 在R4上通过路由策略修改BGP路由172.16.2.0&#x2F;24的Local_Preference属性值，使得R3优选R4通告的BGP路由172.16.2.0&#x2F;24。 #创建IP前缀列表1，匹配BGP路由172.16.2.0&#x2F;24 [R4]ip ip-prefix 1 permit 172.16.2.0 24 greater-equal 24 less-equal 24 #创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1，修改Local_Preference属性值 [R4]route-policy hcip permit node 10 [R4-route-policy] if-match ip-prefix 1 [R4-route-policy] apply local-preference 200 [R4-route-policy] quit [R4]route-policy hcip permit node 20 注意创建一个空节点，对于另外3条BGP路由不执行任何操作。 #对向BGP对等体R3通告的BGP路由应用Route-Policy [R4]bgp 64512 [R4-bgp] peer 10.0.3.3 route-policy hcip export #在R4上触发出方向的软复位，刷新对外通告的BGP路由 refresh bgp all export #在R3上查看BGP路由172.16.2.0&#x2F;24的明细信息 此时R3优选R4通告的BGP路由172.16.2.0&#x2F;24，R2通告的BGP路由其Local_Preference值为100，小于R3通告的BGP路由Local_Preference值200，因此R2通告的BGP路由未被优选。 修改MED属性在R2上通过路由策略修改BGP路由172.16.3.0&#x2F;24的MED属性值，使得R3优选R5发布的BGP路由172.16.3.0&#x2F;24。 #创建IP前缀列表1，匹配BGP路由172.16.3.0&#x2F;24 [R2]ip ip-prefix 1 permit 172.16.3.0 24 greater-equal 24 less-equal 24 #创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1，修改MED属性值 [R2]route-policy hcip permit node 10 [R2-route-policy] if-match ip-prefix 1 [R2-route-policy] apply cost 200 [R2-route-policy] quit [R2]route-policy hcip permit node 20 注意创建一个空节点，对于另外3条BGP路由不执行任何操作。 #对来自BGP对等体R1的BGP路由应用Route-Policy [R2]bgp 64512 [R2-bgp] peer 10.0.12.1 route-policy hcip import #在R2上触发入方向的软复位，刷新接收到的BGP路由 refresh bgp all import #在R3上配置允许比较来自不同AS的BGP路由的MED值 [R3]bgp 64512 [R3-bgp] compare-different-as-med 缺省情况下，不比较来自不同AS邻居的BGP的MED属性值。 #在R3上查看BGP路由172.16.3.0&#x2F;24的明细信息 R2通告的BGP路由172.16.3.0&#x2F;24其MED值为200，而R4通告BGP路由MED值为0，R3优选MED值较小的BGP路由，因此R2通告的BGP路由未被优选。 修改preferred-value属性preferred-value：华为特有的属性值，仅在本地有效，当bgp存在到相同的路由时，将优选prefeerred-value大的路由。只能在路由器本地配置，只影响本设备的路由优选，不会传递给任何bgp对等体。 在R3上通过路由策略修改BGP路由172.16.4.0&#x2F;24的preferred-value属性值，使得R3优选R4通告的BGP路由172.16.4.0&#x2F;24。 #创建IP前缀列表1，匹配BGP路由172.16.4.0&#x2F;24 [R3]ip ip-prefix 1 permit 172.16.4.0 24 greater-equal 24 less-equal 24 #创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1，修改preferred-value属性值 [R3]route-policy hcip permit node 10 [R3-route-policy] if-match ip-prefix 1 [R3-route-policy] apply preferred-value 300 [R3-route-policy] quit [R3]route-policy hcip permit node 20 注意创建一个空节点，对于另外3条BGP路由不执行任何操作。 #对来自BGP对等体R4的BGP路由应用Route-Policy [R3]bgp 64512 [R3-bgp] peer 10.0.4.4 route-policy hcip import #在R3上触发入方向的软复位，刷新收到的BGP路由 refresh bgp all import #在R3上查看BGP路由172.16.4.0&#x2F;24的明细信息 R4通告的BGP路由172.16.3.0&#x2F;24其preferred-value值为300，而R2通告的preferred-value值为0，R3优选preferred-value值较大的BGP路由，因此R3优选R4通告的BGP路由。","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"BGP路由优选","slug":"BGP路由优选","permalink":"http://example.com/tags/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/"}]},{"title":"BGP路由反射器","slug":"BGP路由反射器","date":"2023-11-28T08:48:20.000Z","updated":"2023-11-28T10:16:01.185Z","comments":true,"path":"2023/11/28/BGP路由反射器/","permalink":"http://example.com/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/","excerpt":"BGP路由反射器由于水平分割的原因，为了保证AS内所有的BGP路由器都能学习到完整的BGP路由，就必须在AS内实现IBGP全互联。 然而实现IBGP全互联存在诸多短板： 路由器需维护大量的TCP及BGP连接，尤其在路由器数量较多时。 AS内BGP网络的可扩展性较差，因为通过纯手工配置命令。 为了解决该问题，可应用到RR路由反射器技术。 1、Client：RR客户端，在RR设备上通过手动指定。 指定命令：peer 邻居 reflect-client 2、除了指定的设备为客户端，其它设备均为非客户端。 实验： R1、R2、R3、R4都属于AS64511，其连接方式、互联接口地址如图所示。每台设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号。R1、R2上的Loopback1地址分别为10.1.1.1&#x2F;24、10.2.2.2&#x2F;24，用于模拟用户网段。","text":"BGP路由反射器由于水平分割的原因，为了保证AS内所有的BGP路由器都能学习到完整的BGP路由，就必须在AS内实现IBGP全互联。 然而实现IBGP全互联存在诸多短板： 路由器需维护大量的TCP及BGP连接，尤其在路由器数量较多时。 AS内BGP网络的可扩展性较差，因为通过纯手工配置命令。 为了解决该问题，可应用到RR路由反射器技术。 1、Client：RR客户端，在RR设备上通过手动指定。 指定命令：peer 邻居 reflect-client 2、除了指定的设备为客户端，其它设备均为非客户端。 实验： R1、R2、R3、R4都属于AS64511，其连接方式、互联接口地址如图所示。每台设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号。R1、R2上的Loopback1地址分别为10.1.1.1&#x2F;24、10.2.2.2&#x2F;24，用于模拟用户网段。 所有设备都使用Loopback0地址作为BGP Router ID，R1与R2、R2与R3、R3与R4、R4与R2之间基于直连接口建立IBGP对等体关系，其中R1为R2的路由反射器客户端，R2为R3的路由反射器客户端，R3为R4的路由反射器客户端。 配置ip地址：略 建立ibgp对等体：略 配置路由反射器#R2上将R1配置为路由反射器客户端 [R2]bgp 64511 [R2-bgp] peer 10.0.1.1 reflect-client #R3上将R2配置为路由反射器客户端 [R3]bgp 64511 [R3-bgp] peer 10.0.2.2 reflect-client #R4上将R3配置为路由反射器客户端 [R4]bgp 64511 [R4-bgp] peer 10.0.3.3 reflect-client 验证Orginator_ID实现路由防环在本步骤中，我们将在R2上发布BGP路由10.2.2.0&#x2F;24，并观察该路由依次经路由反射器R3、R4反射后，被通告回R2从而引发潜在路由环路风险的情况。 缺省情况下，R2发布BGP路由后，该路由将被R2直接通告给R4，另一方面也会通过R3反射给R4，此时R4将优选R2直接通告过来的路由，从而不会再将R3反射过来的路由再反射回给R2。为此，我们需要在R2上部署路由策略，使R2不直接向R4通告10.2.2.0&#x2F;24路由。 #配置路由策略 [R2]acl number 2000 [R2-acl-basic-2000] rule 5 permit [R2-acl-basic-2000] quit [R2]route-policy bgp deny node 10 [R2-route-policy] if-match acl 2000 #在BGP中调用路由策略 [R2]bgp 64511 [R2-bgp] peer 10.0.24.4 route-policy bgp export #在R2上发布路由 [R2]bgp 64511 [R2-bgp] network 10.2.2.0 24 #R2上查看BGP路由10.2.2.0&#x2F;24的明细信息 R2将该条路由通告给了R3、R1，但是并未通告给R4。 #R3上查看BGP路由10.2.2.0&#x2F;24的明细信息 R3将来自反射器客户端的BGP路由10.2.2.0&#x2F;24反射给了10.0.34.4（R4）。同时该BGP路由的nexthop为10.0.23.2。 # R4上查看BGP路由10.2.2.0&#x2F;24的明细信息 该条路由来自反射器客户端R3，原始路由经由R3反射，路由的nexthop地址并未改变，同时R3为其添加了Orginator_ID属性，值为10.0.2.2。同时R4将该条路由反射给了R2。 #再次在R2上查看BGP路由10.2.2.0&#x2F;24的明细信息 依旧只存在本地通告的BGP路由，没有R4通告的BGP路由。 #在R2上查看BGP对等体10.0.4.4的详细信息 display bgp peer 10.0.4.4 verbose 从输出信息可以看到R2从R4收到了1个Update报文，未向R4发送Update报文（路由策略限制），但是本地BGP路由表中不存在由R4通告的BGP路由10.2.2.0&#x2F;24。 R4通告的BGP路由Orginator_ID属性值与本地的Router ID一致，R2忽略了该路由通告。 验证Cluster_List实现路由防环为了方便观察现象，取消R2上的BGP路由发布，在R1上将Loopback1接口路由发布到BGP，观察Cluster_List如何防止环路。 #取消R2上的BGP路由发布 [R2]bgp 64511 [R2-bgp] undo network 10.2.2.0 255.255.255.0 #在R1上将Loopback1接口路由发布到BGP [R1]bgp 64511 [R1-bgp] network 10.1.1.0 24 #依次在R1、R2、R3、R4上查看BGP路由10.1.1.0 &#x2F;24的明细信息 R1为BGP路由10.1.1.0&#x2F;24的始发者，R1将路由通告给了R2 来自路由反射器客户端R1的BGP路由10.1.1.0&#x2F;24，R2将其反射给了R3 来自路由反射器客户端R2的BGP路由10.1.1.0&#x2F;24，R2反射时添加了Cluster_List属性，值为10.0.2.2，R3将该条路由反射给了R4 来自路由反射器客户端R3的BGP路由10.1.1.0&#x2F;24，R3反射时添加了Cluster_List属性的值，当前值为10.0.3.3，10.0.2.2，R4将该条路由反射给了R2 #再次查看R2的BGP路由表 R2的BGP路由表中依旧只有一条来自r1的BGP路由10.1.1.0&#x2F;24。 4通告的BGP路由其Cluster_List属性值中包含了R2的Cluster-ID，R2忽略了该路由通告。","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"BGP路由反射器","slug":"BGP路由反射器","permalink":"http://example.com/tags/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/"}]},{"title":"BGP实验","slug":"BGP实验","date":"2023-11-28T02:58:58.000Z","updated":"2023-11-28T07:45:03.915Z","comments":true,"path":"2023/11/28/BGP实验/","permalink":"http://example.com/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/","excerpt":"BGP基础实验设备连接方式、IP地址规划、BGP AS号如图所示，所有设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号，所有设备都使用Loopback0接口IP地址作为BGP Router ID。R1、R5上存在Loopback1模拟用户网段。 R2、R3、R4之间运行OSPF，在R2、R3、R4的互联接口、Loopback0接口上激活OSPF。!","text":"BGP基础实验设备连接方式、IP地址规划、BGP AS号如图所示，所有设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号，所有设备都使用Loopback0接口IP地址作为BGP Router ID。R1、R5上存在Loopback1模拟用户网段。 R2、R3、R4之间运行OSPF，在R2、R3、R4的互联接口、Loopback0接口上激活OSPF。! 实验背景你是公司的网络管理员。公司的网络采用了BGP协议作为路由协议。公司的网络由多个自治系统组成，不同的分支机构使用了不同的AS号，现在你需要完成公司网络的搭建工作。在公司总部使用了OSPF作为IGP，公司内部不同分支机构使用的是私有的BGP AS号。 1.配置ip如拓扑图配置各个接口ip，和loopback 0 ：10.0.x.x r1 loopback 1 ：10.1.1.1 24 r5 loopback 1 ：10.1.5.5 24 r2 r3 r4配置ospf：略 2.配置IBGP对等体在R2、R3、R4之间基于Loopback0接口建立全互联的IBGP对等体关系。 #R2上配置BGP [R2]bgp 64512 [R2-bgp] router-id 10.0.2.2 [R2-bgp] peer 10.0.3.3 as-number 64512 [R2-bgp] peer 10.0.3.3 connect-interface LoopBack0 [R2-bgp] peer 10.0.4.4 as-number 64512 [R2-bgp] peer 10.0.4.4 connect-interface LoopBack0 #R3上配置BGP [R3]bgp 64512 [R3-bgp] router-id 10.0.3.3 [R3-bgp] peer 10.0.2.2 as-number 64512 [R3-bgp] peer 10.0.2.2 connect-interface LoopBack0 [R3-bgp] peer 10.0.4.4 as-number 64512 [R3-bgp] peer 10.0.4.4 connect-interface LoopBack0 #R4上配置BGP [R4]bgp 64512 [R4-bgp] peer 10.0.2.2 as-number 64512 [R4-bgp] peer 10.0.2.2 connect-interface LoopBack0 [R4-bgp] peer 10.0.3.3 as-number 64512 [R4-bgp] peer 10.0.3.3 connect-interface LoopBack0 #分别在R2、R3、R4上检查BGP对等体状态 3.配置EBGP对等体（一般情况使用直连接口建立EBGp） 在R1与R2、R4与R5之间基于Loopback0接口建立EBGP对等体关系，为保证能够正常建立，在R1、R2上配置静态路由使Loopback0之间路由可达（R4、R5同样操作）。 #在R1、R2上配置静态路由 [R1]ip route-static 10.0.2.2 32 10.0.12.2 [R2]ip route-static 10.0.1.1 32 10.0.12.1 #在R4、R5上配置静态路由 [R4]ip route-static 10.0.5.5 32 10.0.45.5 [R5]ip route-static 10.0.4.4 32 10.0.45.4 这里配置静态路由，因为要建立TCP会话的前提，需要在数据层面两路由器相通，所以需要需要手工配置静态路由，实现loopback 0 之间互通 #配置R1、R2之间的EBGP对等体 [R1]bgp 64513 [R1-bgp] router-id 10.0.1.1 [R1-bgp] peer 10.0.2.2 as-number 64512 [R1-bgp] peer 10.0.2.2 ebgp-max-hop 2 [R1-bgp] peer 10.0.2.2 connect-interface LoopBack0 [R2]bgp 64512 [R2-bgp] peer 10.0.1.1 as-number 64513 [R2-bgp] peer 10.0.1.1 ebgp-max-hop 2 [R2-bgp] peer 10.0.1.1 connect-interface LoopBack0 默认情况下，EBGP连接允许的最大跳数为1，这导致EBGP对等体之间只能使用直连链路建立EBGP对等体关系，为使用环回口作为更新源需要手动修改EBGP连接允许的最大跳数。 #配置R4、R5之间的EBGP对等体 [R4]bgp 64512 [R4-bgp] peer 10.0.5.5 as-number 64514 [R4-bgp] peer 10.0.5.5 ebgp-max-hop 2 [R4-bgp] peer 10.0.5.5 connect-interface LoopBack0 [R5]bgp 64514 [R5-bgp] router-id 10.0.5.5 [R5-bgp] peer 10.0.4.4 as-number 64512 [R5-bgp] peer 10.0.4.4 ebgp-max-hop 2 [R5-bgp] peer 10.0.4.4 connect-interface LoopBack0 #在R1、R5上检查EBGP对等体状态 4.在BGP中发布路由在R1、R5上将Loopback1接口路由发布到BGP #在R1、R5上通过network命令发布路由 [R1]bgp 64513 [R1-bgp] network 10.1.1.1 24 [R5]bgp 64514 [R5-bgp] network 10.1.5.5 24 在R3上查看BGP路由表 可以看到此时R3上已经学习到R1、R5上发布的BGP路由，但是都是非有效路由，这是因为它们的下一跳在R3上都不可达，为此可以在R2、R4上通过next-hop-local命令修改下一跳地址为R2、R4的更新源地址。 原因：ebgp对等体在发送数据时，下一跳地址为自身更新源地址，ibgp收到ebgp发送的数据，下一跳不变 #在R2、R4上将路由的下一跳地址修改为自身 [R2]bgp 64512 [R2-bgp] peer 10.0.3.3 next-hop-local [R2-bgp] peer 10.0.4.4 next-hop-local [R4]bgp 64512 [R4-bgp] peer 10.0.2.2 next-hop-local [R4-bgp] peer 10.0.3.3 next-hop-local peer next-hop-local命令一般在ASBR上配置。当设备通过EBGP邻居学到路由再转发给其他IBGP邻居时，默认不修改下一跳，但其EBGP邻居发来的路由的下一跳都是其EBGP邻居的Peer地址，本端对等体所属AS域内的IBGP邻居收到这样的路由后，由于下一跳不可达导致路由无法活跃。因此，需要在ASBR上对IBGP邻居配置peer next-hop-local命令，使得发给IBGP邻居的路由的下一跳是其自身的地址，IBGP邻居收到这样的路由后（由于域内都配置了IGP）发现下一跳可达，路由即为活跃路由。 此命令为覆盖式命令。 执行peer next-hop-local命令后，设备向IBGP对等体&#x2F;对等体组通告路由时，把下一跳属性设为自身的IP地址。 peer next-hop-local命令仅应用于IBGP对等体间。 再次r3上查看bgp路由表 此时两条BGP路由都变成了有效、最优的状态。 #在R1、R5上查看BGP路由表 R1、R5之间相互学习到了对端Loopback1接口路由。 BGP路由汇总实验 BGP AS号、互联地址如图所示，所有设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号。 R1、R2、R3使用Loopback0地址作为BGP Router ID，基于直连接口建立EBGP对等体关系。 R1、R3上存在Loopback1、Loopback2接口，用于模拟用户网段。 1.配置ip略 2.配置EBGPd对等体#配置R1 [R1]bgp 64511 [R1-bgp] router-id 10.0.1.1 [R1-bgp] peer 10.0.12.2 as-number 64512 #配置R2 #配置R3 [R3]bgp 64513 [R3-bgp] router-id 10.0.3.3 [R3-bgp] peer 10.0.23.2 as-number 64512 3.BGP路由自动汇总在R1上开启BGP路由自动汇总，将Loopback1、Loopback2接口路由发布到BGP中，并进行自动汇总。 #创建IP前缀列表1，匹配Loopback1、Loopback2接口路由 [R1]ip ip-prefix 1 permit 172.16.0.0 16 greater-equal 24 less-equal 24 #创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1 [R1]route-policy hcip permit node 10 [R1-route-policy] if-match ip-prefix 1 [R1-route-policy] quit [R1]bgp 64511 [R1-bgp] import-route direct route-policy hcip [R1-bgp] summary automatic Info: Automatic summarization is valid only for the routes imported through the import-route command. 自动汇总只对通过import-route命令引入的路由生效。 #在R1上查看BGP路由表 display bgp routing-table Loopback1、Loopback2接口路由已经发布到BGP，由于R1激活了BGP路由自动汇总，因此R1会将这些路由汇总成172.16.0.0&#x2F;16，同时抑制所有的明细路由，通过明细路由前的“s”标记可以看出，该标记的含义为“suppressed”，表示被抑制，最终R1只对外通告汇总路由172.16.0.0&#x2F;16。 #在R2上查看BGP路由表 display bgp routing-table R2上只能看到一条主类路由172.16.0.0&#x2F;16。 #在R2上查看BGP路由172.16.0.0的明细信息 display bgp routing-table 172.16.0.0 该路由的路径属性中存在Aggregator属性，其中携带了汇总路由生成设备所属的AS号以及其Router ID 4.BGP路由手动汇总在R3上将Loopback1、Loopback2接口路由发布到BGP，在R2上通过aggregate命令执行手动汇总，并抑制明细路由的对外发布。 #创建IP前缀列表1，匹配Loopback1、Loopback2接口路由 [R3]ip ip-prefix 1 permit 172.17.0.0 16 greater-equal 24 less-equal 24 #创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1 [R3]route-policy hcip permit node 10 [R3-route-policy] if-match ip-prefix 1 [R3-route-policy] quit #将Loopback1、Loopback2接口路由发布到BGP [R3]bgp 64513 [R3-bgp] import-route direct route-policy hcip #查看R2的BGP路由表 display bgp routing-table ​ 在R2的BGP路由表中已经存在R3通告的BGP路由172.17.1.0&#x2F;24、172.17.2.0&#x2F;24。 #R2上执行手动路由汇总，将172.17.1.0&#x2F;24、172.17.2.0&#x2F;24汇总成172.17.0.0&#x2F;22，并抑制明细路由的对外通告 [R2]bgp 64512 [R2-bgp] aggregate 172.17.0.0 22 detail-suppressed #查看R2的BGP路由表 display bgp routing-table ​ 此时在R2的BGP路由表中可以看到汇总后的路由。 #在R2上查看BGP路由172.16.0.0&#x2F;22的明细信息 display bgp routing-table 172.17.0.0 22 从输出信息可以看到AS_Path值为Nil，代表了AS_Path属性值为空，这意味着丢失了明细的AS_Path属性值，BGP依赖AS_Path实现防环，因此AS_Path属性的丢失可能带来路由环路。从该条路由对外通告的对等体中可以看到10.0.23.3（R3)。 #查看R3的BGP路由表 在R3的BGP路由表中可以看到汇总路由172.17.0.0&#x2F;22。 #为防止路由环路，在R2上执行手动汇总时增加as-set关键字 [R2]bgp 64512 [R2-bgp] aggregate 172.17.0.0 255.255.252.0 detail-suppressed as-set #再次在R2上查看BGP路由172.17.0.0&#x2F;22的明细信息 可以看到此时AS_Path属性值为64513，此时该条路由依旧向10.0.23.3（R3）通告。 R3收到关于172.17.0.0&#x2F;22的通告之后，在AS_Path中将看到自身的AS号（64153），将会忽略该路由通告。此时R3的BGP路由表中无法看到汇总路由172.17.0.0&#x2F;22，因此通过在手动路由汇总的配置中使用as-set关键字顺利地规避了路由环路的产生。 BGP路由反射器","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"BGP","slug":"BGP","permalink":"http://example.com/tags/BGP/"}]},{"title":"路由策略","slug":"路由策略","date":"2023-11-26T12:36:59.000Z","updated":"2023-11-26T13:26:00.594Z","comments":true,"path":"2023/11/26/路由策略/","permalink":"http://example.com/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/","excerpt":"设备互联方式、互联地址如图所示，所有设备均创建Loopback0，其IP地址为10.0.x.x&#x2F;32，其中x为设备编号，R1、R2、R3在互联接口、Loopback0接口上激活OSPF。 R3、R4属于IS-IS Area 49.0001，两者都是Level-1路由器，R3、R4的系统ID采用0000.0000.000x格式，其中x为设备编号。","text":"设备互联方式、互联地址如图所示，所有设备均创建Loopback0，其IP地址为10.0.x.x&#x2F;32，其中x为设备编号，R1、R2、R3在互联接口、Loopback0接口上激活OSPF。 R3、R4属于IS-IS Area 49.0001，两者都是Level-1路由器，R3、R4的系统ID采用0000.0000.000x格式，其中x为设备编号。 R1上存在三个业务网段A、B、C（使用Loopback1、2、3接口路由模拟），在R1上将直连路由引入到OSPF，但是OSPF域内的路由器上不需要C业务的路由，为此在R1上引入直连路由时通过Route-Policy过滤引入的路由。 R2上不需要A业务网段的路由，但是R3上需要A、B业务网段的路由，为此在R2上配置Filter-Policy对OSPF接收的路由进行过滤。 IS-IS域内的路由器需要访问A业务，因此需要在R3上执行路由重分发，将OSPF路由引入到IS-IS，但是IS-IS域内的路由器不需要访问B业务，为此在R1上引入直连路由时为A、B业务网段路由打上不同的路由标记，R3上执行重分发时根据路由标记过滤B业务网段路由。 任务思路 设备基础IP地址配置。 配置R1、R2、R3之间的OSPF，在互联接口、Loopback0接口上激活OSPF。在R3、R4之间配置IS-IS。 在R1上将直连路由引入到OSPF中，同时配置路由策略不引入C业务网段的路由，将A、B业务网段路由分别打上路由标记10、20。 在R2上配置Filter-Policy对接收的OSPF路由进行过滤，只接收B业务网段的路由。 在R3上将OSPF路由引入到IS-IS中，通过Route-Policy匹配路由标记，只引入A业务网段的OSPF外部路由。 1.配置ip#配置R1的GE0&#x2F;0&#x2F;2、Loopback0接口IP地址 [R1]interface GigabitEthernet0&#x2F;0&#x2F;2 [R1-GigabitEthernet0&#x2F;0&#x2F;2] ip address 10.0.12.1 255.255.255.0 [R1-GigabitEthernet0&#x2F;0&#x2F;2] quit [R1]interface LoopBack0 [R1-LoopBack0] ip address 10.0.1.1 255.255.255.255 [R1-LoopBack0] quit #在R1上创建多个环回口，用于模拟业务网段A、B、C [R1]interface LoopBack1 [R1-LoopBack1] ip address 172.16.1.1 255.255.255.0 [R1-LoopBack1] quit [R1]interface LoopBack2 [R1-LoopBack2] ip address 172.16.2.1 255.255.255.0 [R1-LoopBack2] quit [R1]interface LoopBack3 [R1-LoopBack3] ip address 172.16.3.1 255.255.255.0 [R1-LoopBack3] quit #配置R2的GE0&#x2F;0&#x2F;2、GE0&#x2F;0&#x2F;3、Loopback0接口IP地址 [R2]interface LoopBack0 [R2-LoopBack0] ip address 10.0.2.2 255.255.255.255 [R2-LoopBack0] quit [R2]interface GigabitEthernet0&#x2F;0&#x2F;2 [R2-GigabitEthernet0&#x2F;0&#x2F;2] ip address 10.0.23.2 255.255.255.0 [R2-GigabitEthernet0&#x2F;0&#x2F;2] quit [R2]interface GigabitEthernet0&#x2F;0&#x2F;3 [R2-GigabitEthernet0&#x2F;0&#x2F;3] ip address 10.0.12.2 255.255.255.0 [R2-GigabitEthernet0&#x2F;0&#x2F;3] quit #配置R3的GE0&#x2F;0&#x2F;2、GE0&#x2F;0&#x2F;3、Loopback0接口IP地址 [R3]interface LoopBack0 [R3-LoopBack0] ip address 10.0.3.3 255.255.255.255 [R3-LoopBack0] quit [R3]interface GigabitEthernet0&#x2F;0&#x2F;2 [R3-GigabitEthernet0&#x2F;0&#x2F;2] ip address 10.0.34.3 255.255.255.0 [R3-GigabitEthernet0&#x2F;0&#x2F;2] quit [R3]interface GigabitEthernet0&#x2F;0&#x2F;3 [R3-GigabitEthernet0&#x2F;0&#x2F;3] ip address 10.0.23.3 255.255.255.0 [R3-GigabitEthernet0&#x2F;0&#x2F;3] quit #配置R4的GE0&#x2F;0&#x2F;3、Loopback0接口IP地址 [R4]interface GigabitEthernet0&#x2F;0&#x2F;3 [R4-GigabitEthernet0&#x2F;0&#x2F;3] ip address 10.0.34.4 255.255.255.0 [R4-GigabitEthernet0&#x2F;0&#x2F;3] quit [R4]interface LoopBack0 [R4-LoopBack0] ip address 10.0.4.4 255.255.255.255 [R4-LoopBack0] quit #在R2、R4上检查IP地址连通性 2.配置ospf和isis#配置R1 [R1]ospf 1 router-id 10.0.1.1 [R1-ospf-1] area 0 [R1-ospf-1-area-0.0.0.0] network 10.0.1.1 0.0.0.0 [R1-ospf-1-area-0.0.0.0] network 10.0.12.1 0.0.0.0 [R1-ospf-1-area-0.0.0.0] quit [R1-ospf-1] quit #配置R2 [R2]ospf 1 router-id 10.0.2.2 [R2-ospf-1] area 0.0.0.0 [R2-ospf-1-area-0.0.0.0] network 10.0.2.2 0.0.0.0 [R2-ospf-1-area-0.0.0.0] network 10.0.12.2 0.0.0.0 [R2-ospf-1-area-0.0.0.0] network 10.0.23.2 0.0.0.0 [R2-ospf-1-area-0.0.0.0] quit [R2-ospf-1] quit #配置R3 [R3]ospf 1 router-id 10.0.3.3 [R3-ospf-1] area 0.0.0.0 [R3-ospf-1-area-0.0.0.0] network 10.0.3.3 0.0.0.0 [R3-ospf-1-area-0.0.0.0] network 10.0.23.3 0.0.0.0 [R3-ospf-1-area-0.0.0.0] quit [R3-ospf-1] quit #在R2上检查OSPF邻居的概要信息 R3、R4上配置IS-IS，区域为49.0001，系统ID采用0000.0000.000x格式（x为设备编号），两台设备都为Level-1路由器，在互联接口、R4的Loopback0接口上激活IS-IS。 #配置R3 [R3]isis 1 [R3-isis-1] is-level level-1 [R3-isis-1] network-entity 49.0001.0000.0000.0003.00 [R3-isis-1] quit [R3]interface GigabitEthernet0&#x2F;0&#x2F;2 [R3-GigabitEthernet0&#x2F;0&#x2F;2] isis enable 1 [R3-GigabitEthernet0&#x2F;0&#x2F;2] quit #配置R4 [R4]isis 1 [R4-isis-1] is-level level-1 [R4-isis-1] network-entity 49.0001.0000.0000.0004.00 [R4-isis-1] quit [R4]interface GigabitEthernet0&#x2F;0&#x2F;3 [R4-GigabitEthernet0&#x2F;0&#x2F;3] isis enable 1 [R4-GigabitEthernet0&#x2F;0&#x2F;3] quit [R4]interface LoopBack 0 [R4-LoopBack0] isis enable 1 [R4-LoopBack0] quit #在R3上检查IS-IS邻居状态 3.在R1上引入直连路由在R1上将直连路由引入到OSPF中，同时配置路由策略过滤C业务网段，将A、B业务网段路由分别打上路由标记10、20。 #创建IP前缀列表1，匹配Loopback1接口路由（A业务网段） [R1]ip ip-prefix 1 index 10 permit 172.16.1.0 24 greater-equal 24 less-equal 24 #创建IP前缀列表2，匹配Loopback2接口路由（B业务网段） [R1]ip ip-prefix 2 index 10 permit 172.16.2.0 24 greater-equal 24 less-equal 24 #创建Route-Policy hcip，并创建节点10、20，分别调用IP前缀列表1、2，打上路由标记 [R1]route-policy hcip permit node 10 [R1-route-policy] if-match ip-prefix 1 [R1-route-policy] apply tag 10 [R1-route-policy] quit [R1]route-policy hcip permit node 20 [R1-route-policy] if-match ip-prefix 2 [R1-route-policy] apply tag 20 [R1-route-policy] quit #在R1的OSPF中引入直连路由，调用Route-Policy hcip [R1]ospf 1 [R1-ospf-1] import-route direct route-policy hcip r1上查看ospf lsdb，Loopback1、2接口路由已经被成功引入OSPF中。 #在R1上查看OSPF LSDB中AS-external LSA 172.16.1.0的相关信息 [R1]display ospf lsdb ase 172.16.1.0 ​ OSPF Process 1 with Router ID 10.0.1.1 ​ Link State Database Type : External Ls id : 172.16.1.0 Adv rtr : 10.0.1.1 Ls age : 165 Len : 36 Options : E seq# : 80000001 chksum : 0xa954 Net mask : 255.255.255.0 TOS 0 Metric: 1 E type : 2 Forwarding Address : 0.0.0.0 Tag : 10 Priority : Low 外部路由172.16.1.0&#x2F;24已经被打上Tag 10。 #在R1上查看OSPF LSDB中AS-external LSA 172.16.2.0的相关信息 [R1]display ospf lsdb ase 172.16.2.0 ​ OSPF Process 1 with Router ID 10.0.1.1 ​ Link State Database Type : External Ls id : 172.16.2.0 Adv rtr : 10.0.1.1 Ls age : 355 Len : 36 Options : E seq# : 80000001 chksum : 0x539f Net mask : 255.255.255.0 TOS 0 Metric: 1 E type : 2 Forwarding Address : 0.0.0.0 Tag : 20 Priority : Low 外部路由172.16.2.0&#x2F;24已经被打上Tag 20。 4.在R2上配置过滤策略在R2上配置Filter-Policy对接收的OSPF路由进行过滤，只接收B业务网段的路由。 #查看配置Filter-Policy前的OSPF路由表 display ospf routing #查看配置Filter-Policy前的IP路由表中的OSPF路由 display ip routing-table protocol ospf 在OSPF路由表以及IP路由表中都可以看到OSPF外部路由172.16.1.0&#x2F;24、172.16.2.0&#x2F;24。 #配置基础ACL [R2]acl number 2000 [R2-acl-basic-2000] rule 5 deny source 172.16.1.0 0.0.0.255 [R2-acl-basic-2000] rule 10 permit #在OSPF中部署入方向的Filter-Policy，调用ACL 2000 [R2]ospf 1 [R2-ospf-1] filter-policy 2000 import #查看配置Filter-Policy后的OSPF路由表 dis ospf routing 发现两条外部路由都还存在 #查看配置Filter-Policy后的IP路由表中的OSPF路由 display ip routing-table protocol ospf 在IP路由表中路由172.16.2.0&#x2F;24已经不存在，但是在OSPF路由表中依旧存在。这验证了对于OSPF，Filter-Policy只是限制路由加入IP路由表，不影响本地的LSDB以及LSA的传递。 #在R3上查看IP路由表中的OSPF路由 display ip routing-table protocol ospf R3的IP路由表中OSPF外部路由172.16.1.0&#x2F;24、172.16.2.0&#x2F;24依旧存在。 5.在R3上将OSPF路由引入到IS-IS在R3上将OSPF路由引入到IS-IS中，通过Route-Policy匹配路由标记，只引入A业务网段的OSPF外部路由。 #创建Route-Policy hcip [R3]route-policy hcip permit node 10 [R3-route-policy] if-match tag 10 [R3-route-policy] quit #在IS-IS中引入OSPF路由，调用Route-Policy hcip只引入A业务网段的OSPF外部路由 [R3]isis 1 [R3-isis-1] import-route ospf 1 level-1 route-policy hcip （注意指定level） #查看R3的IS-IS路由表 display isis route Level-1的路由重分发表中只有172.16.1.0&#x2F;24。","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"路由策略","slug":"路由策略","permalink":"http://example.com/tags/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/"}]},{"title":"nat实验","slug":"nat实验","date":"2023-11-25T12:41:12.000Z","updated":"2023-11-25T13:54:42.229Z","comments":true,"path":"2023/11/25/nat实验/","permalink":"http://example.com/2023/11/25/nat%E5%AE%9E%E9%AA%8C/","excerpt":"静态nat静态NAT实现了私有地址和公有地址的一对一映射。如果希望一台主机优先使用某个关联地址，或者想要外部网络使用一个指定的公网地址访问内部服务器时，可以使用静态NAT。但是在大型网络中，这种一对一的IP地址映射无法缓解公用地址短缺的问题。","text":"静态nat静态NAT实现了私有地址和公有地址的一对一映射。如果希望一台主机优先使用某个关联地址，或者想要外部网络使用一个指定的公网地址访问内部服务器时，可以使用静态NAT。但是在大型网络中，这种一对一的IP地址映射无法缓解公用地址短缺的问题。 静态NAT实现了私有地址和共有地址一对一的映射（一个私有地址对应一个共有地址），并没有做到缓解地址短缺的问题，只是做到了地址转换。 一个公网地址只会分配给唯一且固定的内网地址 如图配置ip地址和网关 r1上配置静态nat（注意是在公网的接口上，出接口） 注意配置一条静态路由，不然没有路由的下一跳会被丢弃 在r1上查看nat映射关系：dis nat static 验证一下： 发现去往2.2.2.2的源地址变为2.2.2.3，说明nat完成转换。 静态nat两种配置方式： 1.接口下（上述实验采用这种方式）：进入到连接外网路由器的出接口下，然后在接口视图下配置nat映射关系 2.全局：在全局视图下，配置好nat映射关系，再进入到出接口，执行：nat static enable 动态nat动态NAT通过使用地址池来实现。 如上图，当内部主机A和主机B需要与公网中的目的主机通信时，网关RTA会从配置的公网地址池中选择一个未使用的公网地址与之做映射。每台主机都会分配到地址池中的一个唯一地址。当不需要此连接时，对应的地址映射将会被删除，公网地址也会被恢复到地址池中待用。当网关收到回复报文后，会根据之前的映射再次进行转换之后转发给对应主机。 注意： 动态NAT实际上实现的还是私有地址和公有地址一对一的关系，但是共有地址不再绑定给特定的内网地址。实现了一定程度的缓解地址短缺问题。动态NAT地址池中的地址用尽以后，只能等待被占用的公用IP被释放后，其他主机才能使用它来访问公网。 动态NAT转换流程：1）路由器上配置一个内部地址池（公司内部所有主机用到的私有IP）动态映射一个外部地址池（所购买的公有IP）。2）当有一个内网主机访问外网时，路由器首先查看NAT地址转换表；3）若无，则再查看是否配置了动态NAT映射，若配置，则将IP包头中的源IP与内部地址池进行匹配，若有匹配项，则将该内网IP从内部地址池中取出，同时取出外部地址池中的一个IP地址，动态形成NAT地址转换表。注意，外部地址池的公网IP地址取出后，外部地址池中将没有该公网IP了。4）默认当该主机24小时没有联系外网时，该动态NAT条目会自动消失，所被取出的公私有地址重新回到地址池中。 ip如图，pc的网关192.168.1.254 r1上配置默认路由，ip route-static 0.0.0.0 0 172.16.1.2 r1上配置动态地址池： 地址池验证： 配置acl策略： 在r1的外网出接口上调用： 验证： 其中源IP为3、4、5不定，说明是在动态分配外网地址。动态NAT配置完成。 在动态NAT实验中，最后利用PC1测试连通性时，间歇性会丢包 可能的原因：ping的时候默认按地址池中可用地址顺序从1~254进行地址转换，放大nat地址池可解决。 NAPT 如上图，RTA收到一个私网主机发送的报文，源IP地址是192.168.1.1，源端口号是1025，目的IP地址是100.1.1.1，目的端口是80。RTA会从配置的公网地址池中选择一个空闲的公网IP地址和端口号，并建立相应的NAPT表项。这些NAPT表项指定了报文的私网IP地址和端口号与公网IP地址和端口号的映射关系。之后，RTA将报文的源IP地址和端口号转换成公网地址200.10.10.1和端口号2843，并转发报文到公网。当网关RTA收到回复报文后，会根据之前的映射表再次进行转换之后转发给主机A。主机B同理。 注意： NAPT技术允许多个内部地址映射到同一个公有地址的不同端口。NAPT实现了私有地址对共有地址多对一 相当于一种特殊的动态nat 1、端口NAT和动态NAT的配置过程基本一致，只是在应用到接口时，配置命令少no-pat2、端口NAT一个地址可以给多个源地址转换，不是单对单的转换，所以节省了nat地址！3、端口NAT实际应用较多，静态NAT和动态NAT因为地址不能节约，所以实际应用少 Easy IP Easy IP本质上是NAPT（所以原理与NAPT大致相似）由于网关设备出接口IP地址为公网地址，所以可以利用该出接口地址来作为地址转换的公有地址。Easy IP适用于小规模局域网中的主机访问Internet的场景。小规模局域网通常部署在小型的网吧或者办公室中，这些地方内部主机不多，出接口可以通过拨号方式获取一个临时公网IP地址。Easy IP可以实现内部主机使用这个临时公网IP地址访问Internet。 Easy IP适用于小规模局域网中的主机访问Internet的场景。小规模局域网通常部署在小型的网吧或者办公室中，这些地方内部主机不多，出接口可以通过拨号方式获取一个临时公网IP地址。Easy IP可以实现内部主机使用这个临时公网IP地址访问Internet。 Easy IP的配置：1.创建ACL：acl 2000 2.允许1.0的数据进行转换：rule 5 permit source 192.168.1.0 0 .0.0.255 3.进入公网出接口 4.应用acl：nat outbound 2000 （相较于napt少了地址池） 验证： 源地址为出接口地址172.16.1.1，只是端口不同","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"nat","slug":"nat","permalink":"http://example.com/tags/nat/"}]},{"title":"DHCP基础配置","slug":"DHCP基础配置","date":"2023-11-25T06:34:51.000Z","updated":"2023-12-03T13:57:57.899Z","comments":true,"path":"2023/11/25/DHCP基础配置/","permalink":"http://example.com/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/","excerpt":"DHCP是一种终端自动配置协议，客户端通过DHCP协议可获取一个合法的动态IP地址。","text":"DHCP是一种终端自动配置协议，客户端通过DHCP协议可获取一个合法的动态IP地址。 概述随着网络规模的扩大和网络复杂度的提高，网络配置越来越复杂，经常出现计算机位置变化（如便携机或无线网络）和计算机数量超过可分配的IP地址的情况。动态主机配置协议DHCP（Dynamic Host Configuration Protocol）就是为满足这些需求而发展起来的。DHCP协议以服务器&#x2F;客户端（Server&#x2F;Client）模式工作，DHCP客户端向DHCP服务器动态地请求配置信息，DHCP服务器可以很方便地为客户端动态发送配置信息。 DHCP服务器DHCP Server即DHCP服务器，负责客户端IP地址的分配。客户端向服务器发送配置申请报文（包括IP地址、子网掩码、缺省网关等参数），服务器根据策略返回携带相应配置信息的报文，请求报文和回应报文都采用UDP进行封装。 DHCP中继DHCP Relay即DHCP中继，它是为解决服务器和客户端不在同一个网段而提出来的，它提供了对DHCP广播报文的透明传输功能，能够把DHCP客户端的广播报文透明地传送到其它网段的DHCP服务器上，同样能够把DHCP服务器端的广播报文透明地传送到其它网段的DHCP客户端。 基本命令基本命令pc： ipconfig &#x2F;release—释放ip地址ipconfig &#x2F;renew—重新获取ip 将DHCP转化为固定的地址： ip pool 名字—进入地址池staic-bind ip-address 要分配的固定ip mac-address 目标的mac地址—添加固定地址到pc端lease day &lt;0-999&gt;—修改租期（不建议修改） 将部分ip地址排除地址池，用于静态路由配置 ip pool 名字—进入地址池excluded-ip-address 192.168.1.1 192.168.1.50—把1.1到1.50的地址排除出地址池不使用 重置与查看地址池 reset ip pool name 名字—重置ip配置dis ip pool name 名字—查看指定地址池dis ip pool—查看地址池dis ip pool 名字 used—查看使用情况 配置global全局模式 先配置物理接口 interface 接口号—进入物理接口ip address ip地址—配置物理接口IP DHCP enable—开启DHCP功能ip pool 名字—创建一个ip地址池（有几个网段就建几个池）network 192.168.1.0 mask 24—给ip地址池添加一个网段gateway-list 192.168.1.1—设置192.168.1.1这个ip地址为网关dns-list 8.8.8.8 192.168.1.1—配置DNS为8.8.8.8（前面的优先）interface ip地址—进入物理接口dhcp select global—给接口配置全局模式 将pc更改为DHCP获取IP方式，就可以自动分配ip地址了 interface配置方式基于接口的DHCP的配置方式：配置物理接口的ip网关： interface 接口号—进入接口ip address IP网关—配置网关 dhcp enable—开启服务dhcp select interface—选择interface这个配置方式dhcp server dns-list 8.8.8.8-–配置DNS服务 注意：这种配置方式分配的ip地址网段，是该接口所在的网段的ip地址，网关就是这个接口的ip地址 relay（中继）配置方式 用于在服务器上做配置，路由器进行转发，减少负载量，可以对整个网络体系进行配置首先要实现服务器与个网段互通在服务器的配置： 服务器物理接口配置ipip route-static 0.0.0.0 0 下一跳的ip—服务器配置缺省路由保证互通dhcp enable—在服务器开启dhcp功能ip pool 名字—创建ip地址池（需要几个网段就创建几个地址池）network 192.168.1.0 mask 24—创建网段gateway-list 192.168.1.1—创建网关dns-list 8.8.8.8—创建dnsinterface 物理接口—进入物理接口dhcp select global—选择全局配置模式 在路由器&#x2F;核心交换机上的配置 dhcp enable—开启dhcp功能interface 接口号—进入接口 （需要几个网段就分别进入配置）dhcp select relay—开启中继模式dhcp relay server-ip 服务器物理ip—选择中继分配的接口 基本实验 R1和R3模拟客户端，作为DHCP Client。 R2作为DHCP Server为R1和R3分配IP地址。 动态主机配置协议DHCP（Dynamic Host Configuration Protocol）是一种用于集中对用户IP地址进行动态管理和配置的技术。即使规模较小的网络，通过DHCP也可以使后续增加网络设备变得简单快捷。 DHCP协议由RFC 2131定义，采用客户端&#x2F;服务器通信模式，由客户端（DHCP Client）向服务器（DHCP Server）提出配置申请，服务器返回为客户端分配的配置信息。 DHCP可以提供两种地址分配机制，网络管理员可以根据网络需求为不同的主机选择不同的分配策略。 • 动态分配机制：通过DHCP为主机分配一个有使用期限（这个使用期限通常叫做租期）的IP地址。这种分配机制适用于主机需要临时接入网络或者空闲地址数小于网络主机总数且主机不需要永久连接网络的场景。 • 静态分配机制：网络管理员通过DHCP为指定的主机分配固定的IP地址。相比手工静态配置IP地址，通过DHCP方式静态分配机制避免人工配置发生错误，方便管理员统一维护管理。 配置R2 ip：略 开启DHCP功能[R1]dhcp enable Info: The operation may take a few seconds. Please wait for a moment.done. dhcp enable命令是DHCP相关功能的总开关，DHCP Client和DHCP Server等功能都要在执行dhcp enable命令使能DHCP功能后才会生效。 [R2]dhcp enable Info: The operation may take a few seconds. Please wait for a moment.done. [R3]dhcp enable Info: The operation may take a few seconds. Please wait for a moment.done. 配置地址池# 配置R2的GigabitEthernet 0&#x2F;0&#x2F;0的接口地址池，为R1分配IP地址 [R2]interface GigabitEthernet 0&#x2F;0&#x2F;0 [R2-GigabitEthernet0&#x2F;0&#x2F;0]dhcp select interface dhcp select interface命令用来开启接口采用接口地址池的DHCP Server功能。若不执行此命令，则无法配置接口地址池的相关参数。 [R2-GigabitEthernet0&#x2F;0&#x2F;0]dhcp server dns-list 10.0.12.2 dhcp server dns-list命令用来指定接口地址池下的DNS服务器地址。最多可以配置8个DNS Server的IP地址，用空格分隔。 # 配置全局地址池 [R2]ip pool GlobalPool Info: It’s successful to create an IP address pool. 创建名为G**lobalPool的地址池 [R2-ip-pool-GlobalPool]network 10.0.23.0 mask 24 network命令用来配置全局地址池下可分配的网段地址。 [R2-ip-pool-GlobalPool]dns-list 10.0.23.2 [R2-ip-pool-GlobalPool]gateway-list 10.0.23.2 gateway-list命令用来为DHCP Client配置出口网关地址。R3在获取地址之后，会生成一条默认路由，下一跳地址为10.0.23.2。 [R2-ip-pool-GlobalPool]lease day 2 hour 2 lease命令用来配置地址池下的地址租期。当租约被设置为unlimited时，代表租期无限制。缺省情况下，IP地址租期是1天。 [R2-ip-pool-GlobalPool]static-bind ip-address 10.0.23.3 mac-address 00e0-fc6f-6d1f static-bind命令用来将DHCP Server全局地址池下的IP地址与MAC地址进行绑定。00e0-fc6f-6d1f为当前实验环境下R3的GigabitEthernet0&#x2F;0&#x2F;0接口的MAC地址，可以在R3上通过命令“display interface GigabitEthernet0&#x2F;0&#x2F;0”来查看接口的MAC地址。配置完这条命令之后，R3会获得固定的IP–10.0.23.3。 [R2-ip-pool-GlobalPool]quit #开启R2 GigabitEthernet 0&#x2F;0&#x2F;1接口的DHCP Server功能，为R3分配IP地址 [R2]interface GigabitEthernet 0&#x2F;0&#x2F;1 [R2-GigabitEthernet0&#x2F;0&#x2F;1]dhcp select global dhcp select global命令用来开启接口采用全局地址池的DHCP Server功能。当接口收到DHCP Client请求之后，会到所有全局地址池中查找对应的地址池，然后分配可用的地址给DHCP Client。 配置DHCP Client[R1]interface GigabitEthernet 0&#x2F;0&#x2F;0 [R1-GigabitEthernet0&#x2F;0&#x2F;0] ip address dhcp-alloc [R3]interface GigabitEthernet 0&#x2F;0&#x2F;0 [R3-GigabitEthernet0&#x2F;0&#x2F;0] ip address dhcp-alloc 结果验证查看R1和R3的地址及路由等信息[R1]display ip interface brief Interface IP Address&#x2F;Mask Physical Protocol GigabitEthernet0&#x2F;0&#x2F;0 10.0.12.254&#x2F;24 up up 仅保留关键信息，可以看到R1已经获取到了IP地址**。 [R1]display dns server Type: D:Dynamic S:Static No. Type IP Address 1 D 10.0.12.2 仅保留关键信息，可以看到R1已经获取到了DNS地址**。 [R1]display ip routing-table Destination&#x2F;Mask Proto Pre Cost Flags NextHop Interface 0.0.0.0&#x2F;0 Unr 60 0 D 10.0.12.2 GigabitEthernet0&#x2F;0&#x2F;0 仅保留关键信息，可以看到R1已经获取到了默认路由**。 [R3]display ip interface brief Interface IP Address&#x2F;Mask Physical Protocol GigabitEthernet0&#x2F;0&#x2F;0 10.0.23.3&#x2F;24 up up 仅保留关键信息，可以看到R3已经获取到了固定的IP地址**。 [R3]display dns server Type: D:Dynamic S:Static No. Type IP Address 1 D 2.23.0.10 仅保留关键信息，可以看到R3已经获取到了DNS地址**。 [R3]display ip routing-table Route Flags: R - relay, D - download to fib -—————————————————————————– Routing Tables: Public ​ Destinations : 8 Routes : 8 Destination&#x2F;Mask Proto Pre Cost Flags NextHop Interface 0.0.0.0&#x2F;0 Unr 60 0 D 10.0.23.2 GigabitEthernet0&#x2F;0&#x2F;0 仅保留关键信息，可以看到R3已经获取到了默认路由**。 2、查看R2上的地址分配情况[R2]display ip pool name GlobalPool Pool-name : GlobalPool Pool-No : 1 Lease : 2 Days 2 Hours 0 Minutes Domain-name : - DNS-server0 : 10.0.23.2 NBNS-server0 : - Netbios-type : - Position : Local Status : Unlocked Gateway-0 : 10.0.23.2 Mask : 255.255.255.0 VPN instance : – -—————————————————————————- ​ Start End Total Used Idle(Expired) Conflict Disable -—————————————————————————- ​ 10.0.23.1 10.0.23.254 253 1 252(0) 0 0 -—————————————————————————- display ip pool命令用来查看已配置的IP地址池信息。包括地址池的名称、租期、锁定状态、地址池中IP地址的状态等。 [R2]display ip pool interface GigabitEthernet0&#x2F;0&#x2F;1 Pool-name : GigabitEthernet****0&#x2F;0&#x2F;1 Pool-No : 0 Lease : 1 Days 0 Hours 0 Minutes Domain-name : - DNS-server0 : 10.0.12.2 NBNS-server0 : - Netbios-type : - Position : Interface Status : Unlocked Gateway-0 : 10.0.12.2 Mask : 255.255.255.0 VPN instance : – -—————————————————————————- ​ Start End Total Used Idle(Expired) Conflict Disable -—————————————————————————- ​ 10.0.12.1 10.0.12.254 253 1 252(0) 0 0 -—————————————————————————- 当配置接口地址池时，地址池的名称为接口的名称。分配的网关地址为该接口的IP地址，且无法修改。 中继实验交换机4上有多个vlan，交换机1模拟dhcp服务器实现为多个vlan分配地址，交换机3作为dhcp终极连接服务器和客户端 实验步骤创建VLAN[S1]vlan 40 [S3]vlan batch 10 20 30 40 [S4]vlan batch 10 20 30 配置接口放通相应的VLAN[S4]interface GigabitEthernet0&#x2F;0&#x2F;3 [S4-GigabitEthernet0&#x2F;0&#x2F;3] port link-type trunk [S4-GigabitEthernet0&#x2F;0&#x2F;3] port trunk allow-pass vlan 10 20 30 [S4-GigabitEthernet0&#x2F;0&#x2F;3] quit [S3]interface GigabitEthernet0&#x2F;0&#x2F;1 [S3-GigabitEthernet0&#x2F;0&#x2F;1] port link-type access [S3-GigabitEthernet0&#x2F;0&#x2F;1] port default vlan 40 [S3-GigabitEthernet0&#x2F;0&#x2F;1] quit [S3]interface GigabitEthernet0&#x2F;0&#x2F;3 [S3-GigabitEthernet0&#x2F;0&#x2F;3] port link-type trunk [S3-GigabitEthernet0&#x2F;0&#x2F;3] port trunk allow-pass vlan 10 20 30 [S3-GigabitEthernet0&#x2F;0&#x2F;3] quit [S1]interface GigabitEthernet0&#x2F;0&#x2F;12 [S1-GigabitEthernet0&#x2F;0&#x2F;12] port link-type access [S1-GigabitEthernet0&#x2F;0&#x2F;12] port default vlan 40 [S1-GigabitEthernet0&#x2F;0&#x2F;12] quit 交换机4和交换机3之间因为放通多个vlan，所以使用trunk口，交换机3和交换机1之间只有一个vlan40，所以配置access口，pvid&#x3D;40 VLANIF配置[S4]interface Vlanif 10 [S4-Vlanif10] quit [S4]interface Vlanif 20 [S4-Vlanif20] quit [S4]interface Vlanif 30 [S4-Vlanif30] quit [S3]interface Vlanif 10 [S3-Vlanif10] ip address 10.0.10.3 24 [S3-Vlanif10] quit [S3]interface Vlanif 20 [S3-Vlanif20] ip address 10.0.20.3 24 [S3-Vlanif20] quit [S3]interface Vlanif 30 [S3-Vlanif30] ip address 10.0.30.3 24 [S3-Vlanif30] quit [S3]interface Vlanif 40 [S3-Vlanif40] ip address 10.0.40.3 24 [S3-Vlanif40] quit [S1]interface Vlanif 40 [S1-Vlanif40] ip address 10.0.40.1 24 [S1-Vlanif40] quit 检查一下交换机3和1之间的连通性 （开启DHCP服务，配置全局地址池，同时为S4上的VLANIF30分配静态IP地址。）： 开启DHCP服务[S1]dhcp enable 创建地址池VLAN10，用于给S4的VLANIF10分配地址[S1]ip pool vlan10 &#x2F;&#x2F;创建地址池名为vlan10 [S1-ip-pool-vlan10] gateway-list 10.0.10.3 &#x2F;&#x2F;网关是中继上的vlanif 10 [S1-ip-pool-vlan10] network 10.0.10.0 mask 255.255.255.0 &#x2F;&#x2F;设置分配ip范围是10.0.10.1-10.0.10.255 [S1-ip-pool-vlan10] dns-list 10.0.10.3 [S1-ip-pool-vlan10] quit 创建地址池VLAN20，用于给S4的VLANIF20分配地址[S1]ip pool vlan20 [S1-ip-pool-vlan20] gateway-list 10.0.20.3 [S1-ip-pool-vlan20] network 10.0.20.0 mask 255.255.255.0 [S1-ip-pool-vlan20] dns-list 10.0.20.3 [S1-ip-pool-vlan20] quit 创建地址池VLAN30，用于给S4的VLANIF30分配地址[S1]ip pool vlan30 [S1-ip-pool-vlan30] gateway-list 10.0.30.3 [S1-ip-pool-vlan30] network 10.0.30.0 mask 255.255.255.0 [S1-ip-pool-vlan30] dns-list 10.0.30.3 [S1-ip-pool-vlan30] quit 查看s4的vlanif30的mac为了实现给s4的vlanif30口静态绑定一个指定的ip地址，我们需要先查看一下mac 在S1上为S4的VLANIF30配置静态地址分配 给s4的vlanif口静态分配ip：10.0.30.2 在VLANIF40接口下使能DHCP Server[S1]interface Vlanif 40 [S1-Vlanif40] dhcp select global &#x2F;&#x2F;全局的使能 查看IP地址池配置情况[S1]display ip pool name vlan30 地址池vlan30已经存在一个“Used”地址，该地址为静态分配的地址。 配置前往用户网段的路由[S1]ip route-static 10.0.10.0 24 10.0.40.3 [S1]ip route-static 10.0.20.0 24 10.0.40.3 [S1]ip route-static 10.0.30.0 24 10.0.40.3 （或者配置缺省路由） 保证连通性 在S3上完成DHCP Relay相关配置 开启DHCP服务[S3]dhcp enable 在接口上配置DHCP Relay，指定DHCP Server[S3]interface Vlanif10 [S3-Vlanif10] dhcp select relay [S3-Vlanif10] dhcp relay server-ip 10.0.40.1 [S3-Vlanif10] quit [S3]interface Vlanif20 [S3-Vlanif20] dhcp select relay [S3-Vlanif20] dhcp relay server-ip 10.0.40.1 [S3-Vlanif20] quit [S3]interface Vlanif30 [S3-Vlanif30] dhcp select relay [S3-Vlanif30] dhcp relay server-ip 10.0.40.1 [S3-Vlanif30] quit 查看relay配置 DHCP Client配置在S4上配置VLANIF10、20、30接口通过DHCP获取IP地址 开启DHCP服务[S4]dhcp enable 开启接口通过DHCP获取地址[S4]interface Vlanif10 [S4-Vlanif10] ip address dhcp-alloc [S4-Vlanif10] quit [S4]interface Vlanif20 [S4-Vlanif20] ip address dhcp-alloc [S4-Vlanif20] quit [S4]interface Vlanif30 [S4-Vlanif30] ip address dhcp-alloc [S4-Vlanif30] quit 查看各个接口IP地址获取情况display interface Vlanif 10 Vlanif10 current state : UP Line protocol current state : UP Last line protocol up time : 2020-06-05 17:37:57 UTC-08:00 Description: Route Port,The Maximum Transmit Unit is 1500 Internet Address is allocated by DHCP, 10.0.10.254&#x2F;24 [S4]display interface Vlanif 20 Vlanif20 current state : UP Line protocol current state : UP Last line protocol up time : 2020-06-05 17:41:23 UTC-08:00 Description: Route Port,The Maximum Transmit Unit is 1500 Internet Address is allocated by DHCP, 10.0.20.254&#x2F;24 [S4]display interface Vlanif 30 Vlanif30 current state : UP Line protocol current state : UP Last line protocol up time : 2020-06-05 17:43:22 UTC-08:00 Description: Route Port,The Maximum Transmit Unit is 1500 Internet Address is allocated by DHCP, 10.0.30.2&#x2F;24 接口已经通过DHCP获取到IP地址，并且VLANIF30的地址为静态分配的地址：10.0.30.2。","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"DHCP Relay","slug":"DHCP-Relay","permalink":"http://example.com/tags/DHCP-Relay/"},{"name":"DHCP","slug":"DHCP","permalink":"http://example.com/tags/DHCP/"}]},{"title":"vlan间通信","slug":"vlan间通信","date":"2023-11-24T07:17:21.000Z","updated":"2023-11-25T07:51:39.450Z","comments":true,"path":"2023/11/24/vlan间通信/","permalink":"http://example.com/2023/11/24/vlan%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"VLAN间通信背景划分VLAN后，不同VLAN的用户间不能二层互访，这样能起到隔离广播的作用。但实际应用中，不同VLAN的用户又常有互访的需求，此时就需要实现不同VLAN的用户互访，简称VLAN间互访。","text":"VLAN间通信背景划分VLAN后，不同VLAN的用户间不能二层互访，这样能起到隔离广播的作用。但实际应用中，不同VLAN的用户又常有互访的需求，此时就需要实现不同VLAN的用户互访，简称VLAN间互访。 实验拓扑 详解：R2划入vlan2，R3划入vlan3，与交换机之间采用access口，由于交换机g0&#x2F;0&#x2F;1需要通过多个vlan，所以配成trunk口。R2和R3相当于主机，发送和接受的数据都不带标签，交换机g0&#x2F;0&#x2F;2收到R2发送的数据，打上标签vlan2，然后发出去；交换机g0&#x2F;0&#x2F;1收到数据后，发现vlan的标签允许通过，则数据带着vlan2的标签通过；然后交换机g0&#x2F;0&#x2F;3口转发数据时，发现自己的pvid是vlan3，和vlan2不一样，所以不接受，则vlan2和vlan3不能通信。 在某些场景下，需要特定vlan之间通信 方法一：dot1q接口 在r1上配置两个dot1q接口，g0&#x2F;0&#x2F;1.1和g0&#x2F;0&#x2F;1.2，分别对应vlan2和vlan3，作用就是可以终结vlan标签（剥离），vlan2的标签到r1后，被剥离掉vlan2的标签，然后转发时又被g0&#x2F;0&#x2F;1.2打上vlan3的标签，交换机g0&#x2F;0&#x2F;1通过，到g0&#x2F;0&#x2F;3，access口发现和自己的pvid一样，然后剥离掉标签，转发数据帧给r3. 方法二：vlanif接口：交换机上配置vlanif2和vlanif3，ip地址配成192.168.2.254和192.168.3.254 其实就是相当于两个不同网段的网关，然后实现三层的转发 Access接口交换机上常用来连接用户PC、服务器等终端设备的接口。Access接口所连接的这些设备的网卡往往只收发无标记帧。Access接口只能加入一个VLAN。只能允许一个VLAN通过。 转发原则 接收原则： ①收到不带标签的数据帧，打上标签，vlan id&#x3D;端口的PVID ②收到带标签的数据帧，检查数据帧vlan id是否和端口的PVID相同，相同直接接收；不同拒绝接收 发送原则： ①数据帧vlan id和端口PVID 相同，剥离标签发送； ②数据帧vlan id和端口PVID 不同，禁止发送。 Trunk接口Trunk接口允许多个VLAN的数据帧通过，这些数据帧通过802.1Q Tag实现区分。Trunk接口常用于交换机之间的互联，也用于连接路由器、防火墙等设备的 子接口 转发原则 接收原则： ①收到不带标签的数据帧，打上标签，vlan id&#x3D;端口的PVID，然后查看该vlanid是否在允许列表中，是–接收，不是–拒绝 ②收到带标签的数据帧，查看该vlan id是否在允许列表中，是–接收，不是–拒绝 发送原则： 查看vlan id是否在允许列表中，I:不是–拒绝发送；II：是，查看接口的PVID和vlan id是否相同，相同–剥标签发送；不同–直接发送。 Hybrid接口Hybrid接口与Trunk接口类似，也允许多个VLAN的数据帧通过，这些数据帧通过802.1Q Tag实现区分。用户可以灵活指定Hybrid接口在发送某个（或某些）VLAN的数据帧时是否携带Tag 转发原则 接收原则： ①收到不带标签的数据帧，打上标签，vlan id&#x3D;端口的PVID，然后查看该vlanid是否在允许列表中，是–接收，不是–拒绝 ②收到带标签的数据帧，查看该vlan id是否在允许列表中，是–接收，不是–拒绝发送原则：查看vlan id是否在允许列表中，I:不是–拒绝发送；II：是，是否带标签发送取决于接口的配置。 PVID可以手工修改，默认是1，access口的就是本身的vlan号，trunk可以有一个主vlan和多个副vlan，收到的数据和主vlan相同就剥离转发，收到和主vlan不一样的标签，查表，看看是不是在允许通过的列表，如果有，就带着原来的转发，要是没有，就不让过去啦。 实验配置过程# R2和R3的IP地址及网关配置 system-view Enter system view, return user view with Ctrl+Z. [R2]interface GigabitEthernet 0&#x2F;0&#x2F;1 [R2-GigabitEthernet0&#x2F;0&#x2F;1]ip address 192.168.2.1 24 [R2-GigabitEthernet0&#x2F;0&#x2F;1]quit [R2]ip route-static 0.0.0.0 0 192.168.2.254 配置默认路由，相当于给设备配置了网关。 system-view Enter system view, return user view with Ctrl+Z. [R3]interface GigabitEthernet 0&#x2F;0&#x2F;1 [R3-GigabitEthernet0&#x2F;0&#x2F;1]ip address 192.168.3.1 24 [R3-GigabitEthernet0&#x2F;0&#x2F;1]quit [R3]ip route-static 0.0.0.0 0 192.168.3.254 # 在S1上对R2和R3进行VLAN划分 [S1]vlan batch 2 3 Info: This operation may take a few seconds. Please wait for a moment…done. [S1]interface GigabitEthernet 0&#x2F;0&#x2F;2 [S1-GigabitEthernet0&#x2F;0&#x2F;2]port link-type access [S1-GigabitEthernet0&#x2F;0&#x2F;2]port default vlan 2 [S1-GigabitEthernet0&#x2F;0&#x2F;2]quit [S1]interface GigabitEthernet 0&#x2F;0&#x2F;3 [S1-GigabitEthernet0&#x2F;0&#x2F;3]port link-type access [S1-GigabitEthernet0&#x2F;0&#x2F;3]port default vlan 3 步骤 1 通过Dot1q终结子接口实现VLAN间互访 # 配置S1上的Trunk接口 [S1]interface GigabitEthernet 0&#x2F;0&#x2F;1 [S1-GigabitEthernet0&#x2F;0&#x2F;1]port trunk allow-pass vlan 2 3 因为VLAN间互访数据要由R1来终结VLAN，所以S1和R1之间的链路要允许VLAN2和VLAN3通过**。 # 在R1上创建并配置Dot1q终结子接口 [R1]interface GigabitEthernet 0&#x2F;0&#x2F;1.2 创建并进入子接口视图。2代表子接口的编号，一般建议子接口编号与VLAN ID相同，方便记忆。 [R1-GigabitEthernet0&#x2F;0&#x2F;1.2]dot1q termination vid 2 dot1q termination vid vlan-id命令用来配置子接口Dot1q终结的VLAN ID。 以此配置为例：当GigabitEthernet0&#x2F;0&#x2F;1接口收到带有VLAN 2标签的数据之后，会交由2号子接口进行VLAN终结操作并做后续处理。从2号子接口发出的数据也会带上VLAN 2的标签。 [R1-GigabitEthernet0&#x2F;0&#x2F;1.2]arp broadcast enable 终结子接口不能转发广播报文，在收到广播报文后它们直接把该报文丢弃。为了允许终结子接口能转发广播报文，可以通过在子接口上执行命令arp broadcast enable使能终结子接口的ARP广播功能。部分设备默认使能该功能，此命令的配置根据设备而定。 [R1-GigabitEthernet0&#x2F;0&#x2F;1.2]ip address 192.168.2.254 24 [R1-GigabitEthernet0&#x2F;0&#x2F;1.2]quit [R1]interface GigabitEthernet 0&#x2F;0&#x2F;1.3 [R1-GigabitEthernet0&#x2F;0&#x2F;1.3]dot1q termination vid 3 [R1-GigabitEthernet0&#x2F;0&#x2F;1.3]arp broadcast enable [R1-GigabitEthernet0&#x2F;0&#x2F;1.3]ip address 192.168.3.254 24 [R1-GigabitEthernet0&#x2F;0&#x2F;1.3]quit # 检测VLAN间互访联通性 ping 192.168.3.1 PING 192.168.3.1: 56 data bytes, press CTRL_C to break Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;1 ttl&#x3D;254 time&#x3D;60 ms Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;2 ttl&#x3D;254 time&#x3D;40 ms Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;3 ttl&#x3D;254 time&#x3D;110 ms Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;4 ttl&#x3D;254 time&#x3D;70 ms Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;5 ttl&#x3D;254 time&#x3D;100 ms — 192.168.3.1 ping statistics — 5 packet(s) transmitted 5 packet(s) received 0.00% packet loss round-trip min&#x2F;avg&#x2F;max &#x3D; 40&#x2F;76&#x2F;110 ms tracert 192.168.3.1 traceroute to 192.168.3.1(192.168.3.1), max hops: 30 ,packet length: 40,press CTRL_C to break 1 192.168.2.254 30 ms 50 ms 50 ms 2 192.168.3.1 70 ms 60 ms 60 ms 此时VLAN2和VLAN3之间已经可以正常的互访。 步骤 2 通过VLANIF接口实现VLAN间互访 # 清除上一步配置 [S1]interface GigabitEthernet 0&#x2F;0&#x2F;1 [S1-GigabitEthernet0&#x2F;0&#x2F;1]undo port trunk allow-pass vlan 2 3 [S1-GigabitEthernet0&#x2F;0&#x2F;1]undo port link-type [R1]undo interface GigabitEthernet 0&#x2F;0&#x2F;1.2 [R1]undo interface GigabitEthernet 0&#x2F;0&#x2F;1.3 # 在S1上创建相应的VLANIF接口 [S1]interface Vlanif 2 interface vlanif vlan-id命令用来创建VLANIF接口并进入VLANIF接口视图。只有先通过命令创建VLAN后，才能执行interface vlanif命令创建VLANIF接口。 [S1-Vlanif2]ip address 192.168.2.254 24 [S1-Vlanif2]quit [S1]interface Vlanif 3 [S1-Vlanif3]ip address 192.168.3.254 24 [S1-Vlanif3]quit # 检测VLAN间互访联通性 ping 192.168.3.1 PING 192.168.3.1: 56 data bytes, press CTRL_C to break Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;1 ttl&#x3D;254 time&#x3D;100 ms Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;2 ttl&#x3D;254 time&#x3D;50 ms Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;3 ttl&#x3D;254 time&#x3D;50 ms Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;4 ttl&#x3D;254 time&#x3D;60 ms Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;5 ttl&#x3D;254 time&#x3D;70 ms — 192.168.3.1 ping statistics — 5 packet(s) transmitted 5 packet(s) received 0.00% packet loss round-trip min&#x2F;avg&#x2F;max &#x3D; 50&#x2F;66&#x2F;100 ms tracert 192.168.3.1 traceroute to 192.168.3.1(192.168.3.1), max hops: 30 ,packet length: 40,press CTRL_C to break 1 192.168.2.254 40 ms 30 ms 20 ms 2 192.168.3.1 40 ms 30 ms 40 ms 此时VLAN2和VLAN3之间已经可以正常的互访。","categories":[{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"vlan间通信","slug":"vlan间通信","permalink":"http://example.com/tags/vlan%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"name":"dot1q","slug":"dot1q","permalink":"http://example.com/tags/dot1q/"},{"name":"vlanif","slug":"vlanif","permalink":"http://example.com/tags/vlanif/"}]}],"categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"ip实验","slug":"ip实验","permalink":"http://example.com/categories/ip%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"VRRP","slug":"VRRP","permalink":"http://example.com/tags/VRRP/"},{"name":"SSH","slug":"SSH","permalink":"http://example.com/tags/SSH/"},{"name":"BGP","slug":"BGP","permalink":"http://example.com/tags/BGP/"},{"name":"IGMP","slug":"IGMP","permalink":"http://example.com/tags/IGMP/"},{"name":"PIM","slug":"PIM","permalink":"http://example.com/tags/PIM/"},{"name":"stp拓扑变更","slug":"stp拓扑变更","permalink":"http://example.com/tags/stp%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4/"},{"name":"PPP","slug":"PPP","permalink":"http://example.com/tags/PPP/"},{"name":"PPPoE","slug":"PPPoE","permalink":"http://example.com/tags/PPPoE/"},{"name":"IS-IS","slug":"IS-IS","permalink":"http://example.com/tags/IS-IS/"},{"name":"ospf","slug":"ospf","permalink":"http://example.com/tags/ospf/"},{"name":"交换机工作原理","slug":"交换机工作原理","permalink":"http://example.com/tags/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"name":"子网划分","slug":"子网划分","permalink":"http://example.com/tags/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/"},{"name":"ap上线","slug":"ap上线","permalink":"http://example.com/tags/ap%E4%B8%8A%E7%BA%BF/"},{"name":"wlan","slug":"wlan","permalink":"http://example.com/tags/wlan/"},{"name":"USG5500","slug":"USG5500","permalink":"http://example.com/tags/USG5500/"},{"name":"防火墙nat","slug":"防火墙nat","permalink":"http://example.com/tags/%E9%98%B2%E7%81%AB%E5%A2%99nat/"},{"name":"rstp","slug":"rstp","permalink":"http://example.com/tags/rstp/"},{"name":"mstp","slug":"mstp","permalink":"http://example.com/tags/mstp/"},{"name":"链路聚合","slug":"链路聚合","permalink":"http://example.com/tags/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/"},{"name":"lacp","slug":"lacp","permalink":"http://example.com/tags/lacp/"},{"name":"eth-trunk","slug":"eth-trunk","permalink":"http://example.com/tags/eth-trunk/"},{"name":"mpls","slug":"mpls","permalink":"http://example.com/tags/mpls/"},{"name":"hybrid","slug":"hybrid","permalink":"http://example.com/tags/hybrid/"},{"name":"tag","slug":"tag","permalink":"http://example.com/tags/tag/"},{"name":"telnet","slug":"telnet","permalink":"http://example.com/tags/telnet/"},{"name":"aaa","slug":"aaa","permalink":"http://example.com/tags/aaa/"},{"name":"FTP","slug":"FTP","permalink":"http://example.com/tags/FTP/"},{"name":"BFD","slug":"BFD","permalink":"http://example.com/tags/BFD/"},{"name":"BGP路由优选","slug":"BGP路由优选","permalink":"http://example.com/tags/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/"},{"name":"BGP路由反射器","slug":"BGP路由反射器","permalink":"http://example.com/tags/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/"},{"name":"路由策略","slug":"路由策略","permalink":"http://example.com/tags/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/"},{"name":"nat","slug":"nat","permalink":"http://example.com/tags/nat/"},{"name":"DHCP Relay","slug":"DHCP-Relay","permalink":"http://example.com/tags/DHCP-Relay/"},{"name":"DHCP","slug":"DHCP","permalink":"http://example.com/tags/DHCP/"},{"name":"vlan间通信","slug":"vlan间通信","permalink":"http://example.com/tags/vlan%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"name":"dot1q","slug":"dot1q","permalink":"http://example.com/tags/dot1q/"},{"name":"vlanif","slug":"vlanif","permalink":"http://example.com/tags/vlanif/"}]}