<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BGP实验</title>
    <url>/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="BGP基础实验"><a href="#BGP基础实验" class="headerlink" title="BGP基础实验"></a>BGP基础实验</h1><p>设备连接方式、IP地址规划、BGP AS号如图所示，所有设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号，所有设备都使用Loopback0接口IP地址作为BGP Router ID。R1、R5上存在Loopback1模拟用户网段。</p>
<p>R2、R3、R4之间运行OSPF，在R2、R3、R4的互联接口、Loopback0接口上激活OSPF。!</p>
<span id="more"></span>

<h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>你是公司的网络管理员。公司的网络采用了BGP协议作为路由协议。公司的网络由多个自治系统组成，不同的分支机构使用了不同的AS号，现在你需要完成公司网络的搭建工作。在公司总部使用了OSPF作为IGP，公司内部不同分支机构使用的是私有的BGP AS号。</p>
<p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/bgpadaw110633.png" alt="bgpadaw110633"></p>
<h1 id="1-配置ip"><a href="#1-配置ip" class="headerlink" title="1.配置ip"></a>1.配置ip</h1><p>如拓扑图配置各个接口ip，和loopback 0 ：10.0.x.x</p>
<p>r1 loopback 1 ：10.1.1.1 24</p>
<p>r5 loopback 1 ：10.1.5.5 24</p>
<p>r2 r3 r4配置ospf：略</p>
<h1 id="2-配置IBGP对等体"><a href="#2-配置IBGP对等体" class="headerlink" title="2.配置IBGP对等体"></a>2.配置IBGP对等体</h1><p>在R2、R3、R4之间基于Loopback0接口建立全互联的IBGP对等体关系。</p>
<p>#R2上配置BGP</p>
<p>[R2]bgp 64512</p>
<p>[R2-bgp] router-id 10.0.2.2</p>
<p>[R2-bgp] peer 10.0.3.3 as-number 64512</p>
<p>[R2-bgp] peer 10.0.3.3 connect-interface LoopBack0</p>
<p>[R2-bgp] peer 10.0.4.4 as-number 64512</p>
<p>[R2-bgp] peer 10.0.4.4 connect-interface LoopBack0</p>
<p>#R3上配置BGP</p>
<p>[R3]bgp 64512</p>
<p>[R3-bgp] router-id 10.0.3.3</p>
<p>[R3-bgp] peer 10.0.2.2 as-number 64512</p>
<p>[R3-bgp] peer 10.0.2.2 connect-interface LoopBack0</p>
<p>[R3-bgp] peer 10.0.4.4 as-number 64512</p>
<p>[R3-bgp] peer 10.0.4.4 connect-interface LoopBack0</p>
<p>#R4上配置BGP</p>
<p>[R4]bgp 64512</p>
<p>[R4-bgp] peer 10.0.2.2 as-number 64512</p>
<p>[R4-bgp] peer 10.0.2.2 connect-interface LoopBack0</p>
<p>[R4-bgp] peer 10.0.3.3 as-number 64512</p>
<p>[R4-bgp] peer 10.0.3.3 connect-interface LoopBack0</p>
<p>#分别在R2、R3、R4上检查BGP对等体状态</p>
<h1 id="3-配置EBGP对等体"><a href="#3-配置EBGP对等体" class="headerlink" title="3.配置EBGP对等体"></a>3.配置EBGP对等体</h1><p>（一般情况使用直连接口建立EBGp）</p>
<p>在R1与R2、R4与R5之间基于Loopback0接口建立EBGP对等体关系，为保证能够正常建立，在R1、R2上配置静态路由使Loopback0之间路由可达（R4、R5同样操作）。</p>
<p>#在R1、R2上配置静态路由</p>
<p>[R1]ip route-static 10.0.2.2 32 10.0.12.2</p>
<p>[R2]ip route-static 10.0.1.1 32 10.0.12.1</p>
<p>#在R4、R5上配置静态路由</p>
<p>[R4]ip route-static 10.0.5.5 32 10.0.45.5</p>
<p>[R5]ip route-static 10.0.4.4 32 10.0.45.4</p>
<p>这里配置静态路由，因为要建立TCP会话的前提，需要在数据层面两路由器相通，所以需要需要手工配置静态路由，实现loopback 0 之间互通</p>
<p>#配置R1、R2之间的EBGP对等体</p>
<p>[R1]bgp 64513</p>
<p>[R1-bgp] router-id 10.0.1.1</p>
<p>[R1-bgp] peer 10.0.2.2 as-number 64512</p>
<p>[R1-bgp] peer 10.0.2.2 ebgp-max-hop 2</p>
<p>[R1-bgp] peer 10.0.2.2 connect-interface LoopBack0</p>
<p>[R2]bgp 64512</p>
<p>[R2-bgp] peer 10.0.1.1 as-number 64513</p>
<p>[R2-bgp] peer 10.0.1.1 ebgp-max-hop 2</p>
<p>[R2-bgp] peer 10.0.1.1 connect-interface LoopBack0</p>
<p>默认情况下，EBGP连接允许的最大跳数为1，这导致EBGP对等体之间只能使用直连链路建立EBGP对等体关系，为使用环回口作为更新源需要手动修改EBGP连接允许的最大跳数。</p>
<p>#配置R4、R5之间的EBGP对等体</p>
<p>[R4]bgp 64512</p>
<p>[R4-bgp] peer 10.0.5.5 as-number 64514</p>
<p>[R4-bgp] peer 10.0.5.5 ebgp-max-hop 2</p>
<p>[R4-bgp] peer 10.0.5.5 connect-interface LoopBack0</p>
<p>[R5]bgp 64514</p>
<p>[R5-bgp] router-id 10.0.5.5</p>
<p>[R5-bgp] peer 10.0.4.4 as-number 64512</p>
<p>[R5-bgp] peer 10.0.4.4 ebgp-max-hop 2</p>
<p>[R5-bgp] peer 10.0.4.4 connect-interface LoopBack0</p>
<p>#在R1、R5上检查EBGP对等体状态</p>
<h1 id="4-在BGP中发布路由"><a href="#4-在BGP中发布路由" class="headerlink" title="4.在BGP中发布路由"></a>4.在BGP中发布路由</h1><p>在R1、R5上将Loopback1接口路由发布到BGP</p>
<p>#在R1、R5上通过network命令发布路由</p>
<p>[R1]bgp 64513</p>
<p>[R1-bgp] network 10.1.1.1 24</p>
<p>[R5]bgp 64514</p>
<p>[R5-bgp] network 10.1.5.5 24</p>
<p>在R3上查看BGP路由表</p>
<p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/luyoub122914.png" alt="luyoub122914"></p>
<p>可以看到此时R3上已经学习到R1、R5上发布的BGP路由，但是都是<strong>非有效路由</strong>，这是因为它们的下一跳在R3上都不可达，为此可以在R2、R4上通过<strong>next-hop-local</strong>命令修改下一跳地址为R2、R4的更新源地址。</p>
<p>原因：ebgp对等体在发送数据时，下一跳地址为自身更新源地址，ibgp收到ebgp发送的数据，下一跳不变</p>
<p>#在R2、R4上将路由的下一跳地址修改为自身</p>
<p>[R2]bgp 64512</p>
<p>[R2-bgp] peer 10.0.3.3 next-hop-local</p>
<p>[R2-bgp] peer 10.0.4.4 next-hop-local</p>
<p>[R4]bgp 64512</p>
<p>[R4-bgp] peer 10.0.2.2 next-hop-local</p>
<p>[R4-bgp] peer 10.0.3.3 next-hop-local</p>
<p><strong>peer next-hop-local</strong>命令一般在ASBR上配置。当设备通过EBGP邻居学到路由再转发给其他IBGP邻居时，默认不修改下一跳，但其EBGP邻居发来的路由的下一跳都是其EBGP邻居的Peer地址，本端对等体所属AS域内的IBGP邻居收到这样的路由后，由于下一跳不可达导致路由无法活跃。因此，需要在ASBR上对IBGP邻居配置<strong>peer next-hop-local</strong>命令，使得发给IBGP邻居的路由的下一跳是其自身的地址，IBGP邻居收到这样的路由后（由于域内都配置了IGP）发现下一跳可达，路由即为活跃路由。</p>
<p>此命令为覆盖式命令。</p>
<p>执行<strong>peer next-hop-local</strong>命令后，设备向IBGP对等体&#x2F;对等体组通告路由时，把下一跳属性设为自身的IP地址。</p>
<p><strong>peer next-hop-local</strong>命令仅应用于IBGP对等体间。</p>
<p>再次r3上查看bgp路由表</p>
<p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/louybadwad128123318.png" alt="louybadwad128123318"></p>
<p>此时两条BGP路由都变成了有效、最优的状态。</p>
<p>#在R1、R5上查看BGP路由表<img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/r11128123426.png" alt="r11128123426"></p>
<p>R1、R5之间相互学习到了对端Loopback1接口路由。</p>
<h1 id="BGP路由汇总实验"><a href="#BGP路由汇总实验" class="headerlink" title="BGP路由汇总实验"></a>BGP路由汇总实验</h1><p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/luyouhuizongdaw143536.png" alt="luyouhuizongdaw143536"></p>
<p>BGP AS号、互联地址如图所示，所有设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号。</p>
<p>R1、R2、R3使用Loopback0地址作为BGP Router ID，基于直连接口建立EBGP对等体关系。</p>
<p>R1、R3上存在Loopback1、Loopback2接口，用于模拟用户网段。</p>
<h1 id="1-配置ip-1"><a href="#1-配置ip-1" class="headerlink" title="1.配置ip"></a>1.配置ip</h1><p>略</p>
<h1 id="2-配置EBGPd对等体"><a href="#2-配置EBGPd对等体" class="headerlink" title="2.配置EBGPd对等体"></a>2.配置EBGPd对等体</h1><p>#配置R1</p>
<p>[R1]bgp 64511</p>
<p>[R1-bgp] router-id 10.0.1.1</p>
<p>[R1-bgp] peer 10.0.12.2 as-number 64512</p>
<p>#配置R2</p>
<p>#配置R3</p>
<p>[R3]bgp 64513</p>
<p>[R3-bgp] router-id 10.0.3.3</p>
<p>[R3-bgp] peer 10.0.23.2 as-number 64512</p>
<h1 id="3-BGP路由自动汇总"><a href="#3-BGP路由自动汇总" class="headerlink" title="3.BGP路由自动汇总"></a>3.BGP路由自动汇总</h1><p>在R1上开启BGP路由自动汇总，将Loopback1、Loopback2接口路由发布到BGP中，并进行自动汇总。</p>
<p>#创建IP前缀列表1，匹配Loopback1、Loopback2接口路由</p>
<p>[R1]ip ip-prefix 1 permit 172.16.0.0 16 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1</p>
<p>[R1]route-policy hcip permit node 10</p>
<p>[R1-route-policy] if-match ip-prefix 1</p>
<p>[R1-route-policy] quit</p>
<p>[R1]bgp 64511</p>
<p>[R1-bgp] import-route direct route-policy hcip</p>
<p>[R1-bgp] summary automatic</p>
<p>Info: Automatic summarization is valid only for the routes imported through the import-route command.</p>
<p>自动汇总只对通过<strong>import-route</strong>命令引入的路由生效。</p>
<p>#在R1上查看BGP路由表</p>
<p><R1>display	bgp	routing-table	</R1></p>
<p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/r11128123426.png" alt="r11128123426"></p>
<p>Loopback1、Loopback2接口路由已经发布到BGP，由于R1激活了BGP路由自动汇总，因此R1会将这些路由汇总成172.16.0.0&#x2F;16，同时抑制所有的明细路由，通过明细路由前的“s”标记可以看出，该标记的含义为“suppressed”，表示被抑制，最终R1只对外通告汇总路由172.16.0.0&#x2F;16。</p>
<p>#在R2上查看BGP路由表</p>
<p><R2>display bgp routing-table </R2></p>
<p>R2上只能看到一条主类路由172.16.0.0&#x2F;16。</p>
<p>#在R2上查看BGP路由172.16.0.0的明细信息</p>
<p><R2>display bgp routing-table 172.16.0.0</R2></p>
<p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/r2jyj28150027.png" alt="r2jyj28150027"></p>
<p>该路由的路径属性中存在Aggregator属性，其中携带了汇总路由生成设备所属的AS号以及其Router ID</p>
<h1 id="4-BGP路由手动汇总"><a href="#4-BGP路由手动汇总" class="headerlink" title="4.BGP路由手动汇总"></a>4.BGP路由手动汇总</h1><p>在R3上将Loopback1、Loopback2接口路由发布到BGP，在R2上通过<strong>aggregate</strong>命令执行手动汇总，并抑制明细路由的对外发布。</p>
<p>#创建IP前缀列表1，匹配Loopback1、Loopback2接口路由</p>
<p>[R3]ip ip-prefix 1 permit 172.17.0.0 16 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1</p>
<p>[R3]route-policy hcip permit node 10</p>
<p>[R3-route-policy] if-match ip-prefix 1</p>
<p>[R3-route-policy] quit</p>
<p>#将Loopback1、Loopback2接口路由发布到BGP </p>
<p>[R3]bgp 64513</p>
<p>[R3-bgp] import-route direct route-policy hcip</p>
<p>#查看R2的BGP路由表</p>
<p><R2>display	bgp	routing-table</R2></p>
<p>​	<img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/QQr2aef31128150511.png" alt="QQr2aef31128150511"></p>
<p>在R2的BGP路由表中已经存在R3通告的BGP路由172.17.1.0&#x2F;24、172.17.2.0&#x2F;24。</p>
<p>#R2上执行手动路由汇总，将172.17.1.0&#x2F;24、172.17.2.0&#x2F;24汇总成172.17.0.0&#x2F;22，并抑制明细路由的对外通告</p>
<p>[R2]bgp 64512</p>
<p>[R2-bgp] aggregate 172.17.0.0 22 detail-suppressed</p>
<p>#查看R2的BGP路由表</p>
<p><R2>display	bgp	routing-table</R2></p>
<p>​	</p>
<p>此时在R2的BGP路由表中可以看到汇总后的路由。</p>
<p> <img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/radwahh128150729.png" alt="radwahh128150729"></p>
<p>#在R2上查看BGP路由172.16.0.0&#x2F;22的明细信息</p>
<p><R2>display bgp routing-table 172.17.0.0 22</R2></p>
<p>从输出信息<img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/diushi222f1030.png" alt="diushi222f1030">可以看到AS_Path值为Nil，代表了AS_Path属性值为空，这意味着丢失了明细的AS_Path属性值，BGP依赖AS_Path实现防环，因此AS_Path属性的丢失可能带来路由环路。从该条路由对外通告的对等体中可以看到10.0.23.3（R3)。</p>
<p>#查看R3的BGP路由表</p>
<p>在R3的BGP路由表中可以看到汇总路由172.17.0.0&#x2F;22。</p>
<p>#为防止路由环路，在R2上执行手动汇总时增加as-set关键字</p>
<p>[R2]bgp 64512</p>
<p>[R2-bgp] aggregate 172.17.0.0 255.255.252.0 detail-suppressed as-set</p>
<p>#再次在R2上查看BGP路由172.17.0.0&#x2F;22的明细信息</p>
<p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/as645138151320.png" alt="as645138151320"></p>
<p>可以看到此时AS_Path属性值为64513，此时该条路由<strong>依旧向10.0.23.3（R3）</strong>通告。</p>
<p>R3收到关于172.17.0.0&#x2F;22的通告之后，在AS_Path中将看到自身的AS号（64153），将会忽略该路由通告。此时R3的BGP路由表中无法看到汇总路由172.17.0.0&#x2F;22，因此通过在手动路由汇总的配置中使用as-set关键字顺利地规避了路由环路的产生。</p>
<h1 id="BGP路由反射器"><a href="#BGP路由反射器" class="headerlink" title="BGP路由反射器"></a>BGP路由反射器</h1>]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>BGP</tag>
      </tags>
  </entry>
  <entry>
    <title>BGP总结</title>
    <url>/2024/05/11/BGP%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>BGP使用<strong>TCP</strong>作为其传输层协议（端口号为<strong>179</strong>），使用<strong>触发式路由更新</strong>，而不是周期性路由更新。—BGP要想建立邻居关系，必须保证建立邻居关系的两端能够ping通<br>BGP能够承载大批量的路由信息，能够支撑大规模网络。<br>BGP提供了丰富的路由策略，能够灵活的进行路由选路，并能指导对等体按策略发布路由。<br>BGP能够支撑MPLS&#x2F;VPN的应用，传递客户VPN路由。<br>BGP提供了路由聚合和路由衰减功能用于防止路由振荡，通过这两项功能有效地提高了网络稳定性。</p>
<p>AS范围：1-65535</p>
<p>BGP版本：BGP4+</p>
<p>一台路由器不能配置多个BGP进程</p>
<p>只传递路由信息，不会暴露AS内拓扑信息</p>
<h1 id="BGP对等体"><a href="#BGP对等体" class="headerlink" title="BGP对等体"></a>BGP对等体</h1><p>EBGP：对等体两端属于不同的AS</p>
<p>IBGP：对等体两端属于同一个AS</p>
<p>建立BGP对等体的时候可以使用物理接口建立，也可以使用loopback接口建立</p>
<p><strong>EBGP对等体</strong>：建议使用物理接口建立 </p>
<p>①使用物理接口建立：<br>[AR1]bgp 100</p>
<p>[AR1-bgp]router-id 1.1.1.1  </p>
<p>[AR1-bgp]peer 10.0.12.2 as-number 200</p>
<p>②使用loopback接口建立：</p>
<p>[Ar4]bgp 200    </p>
<p>[Ar4-bgp]peer 5.5.5.5 as-number 300   </p>
<p>[Ar4-bgp]peer 5.5.5.5 connect-interface loopback0     <strong>如果使用loopback接口建立对等体，必须要指明建立对等体的接口</strong></p>
<p>[Ar4-bgp]router-id 4.4.4.4  指定router id</p>
<p>[Ar4-bgp]peer 5.5.5.5  ebgp-max-hop   EBGP建立对等体关系默认发出报文TTL值为1，如果用loopback接口建立，到达loopback接口TTL值变成0，此时报文会丢弃，所以需要更改接口的TTL，peer 5.5.5.5  ebgp-max-hop命令可以直接设置TTL，至少设置为2，如果不设置，此时TTL值为255</p>
<p>I<strong>BGP对等体</strong>：建议使用loopback接口建立（更稳定）</p>
<p>IBGP建立对等体关系，发送报文TTL值为255，所以不用考虑TTL不可达问题</p>
<p>①使用loopback接口建立：</p>
<p>[Ar4]bgp 200   </p>
<p>[Ar4-bgp]peer 2.2.2.2 as-number 200  </p>
<p>[Ar4-bgp]peer 2.2.2.2 connect-interface loopback0</p>
<p>②使用物理接口建立：</p>
<p>[Ar4]bgp 200    </p>
<p>[Ar4-bgp]peer 10.0.34.4 as-number 200</p>
<h1 id="BGP对等体关系建立"><a href="#BGP对等体关系建立" class="headerlink" title="BGP对等体关系建立"></a>BGP对等体关系建立</h1><p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/image-20240511132855207.png" alt="image-20240511132855207"></p>
<ul>
<li><p>Open消息：是TCP连接建立后发送的第一个消息，用于建立BGP对等体之间的连接关系。对等体在接收到Open消息并协商成功后，将发送Keepalive消息确认并保持连接的有效性。确认后，对等体间可以进行Update、Notification、Keepalive和Route-refresh消息的交换。</p>
</li>
<li><p>Update消息：用于在对等体之间交换路由信息。Update消息可以发布多条属性相同的可达路由信息，也可以撤销多条不可达路由信息。</p>
<ul>
<li>一条Update消息可以发布多条具有相同路由属性的可达路由，这些路由可共享一组路由属性。所有包含在一个给定的Update消息里的路由属性适用于该Update消息中的NLRI（Network Layer Reachability Information）字段里的所有目的地（用IP前缀表示）。</li>
<li>一条Update消息可以撤销多条不可达路由。每一个路由通过目的地（用IP前缀表示）清楚的定义了BGP Speaker之间先前通告过的路由。</li>
<li>一条Update消息可以同时发布可达路由，并且撤销另一部分不可达路由。一条Update消息也可以只用于撤销路由，这样就不需要包括路径属性或者NLRI。相反，也可以只用于通告可达路由，就不需要携带撤销路由信息了。</li>
</ul>
</li>
<li><p>Notification消息：当BGP检测到错误状态时，就向对等体发出Notification消息，之后BGP连接会立即中断。</p>
</li>
<li><p>Keepalive消息：BGP会周期性的向对等体发出Keepalive消息，用来保持连接的有效性。缺省情况下，间隔60s，保持180s</p>
</li>
<li><p>Route-refresh消息：Route-refresh消息用来请求对等体重新发送所有的可达路由信息。</p>
<p>在所有BGP设备使能Route-refresh能力的情况下，如果BGP的入口路由策略发生了变化，本地BGP设备会向对等体发布Route-refresh消息，收到此消息的对等体会将其路由信息重新发给本地BGP设备。这样，可以在不中断BGP连接的情况下，对BGP路由表进行动态刷新，并应用新的路由策略。</p>
</li>
</ul>
<h1 id="BGP状态机"><a href="#BGP状态机" class="headerlink" title="BGP状态机"></a>BGP状态机</h1><p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/image-20240511133639233.png" alt="image-20240511133639233"></p>
<ol>
<li><p>Idle状态是BGP初始状态。在Idle状态下，BGP拒绝邻居发送的连接请求。只有在收到本设备的Start事件后，BGP才开始尝试和其他BGP对等体进行TCP连接，并转至Connect状态。</p>
<p> <strong>注意：</strong></p>
<ul>
<li>Start事件是由一个操作者配置一个BGP进程，或者重置一个已经存在的进程或者设备软件重置BGP进程引起的。</li>
<li>任何状态中收到Notification报文或TCP拆链通知等Error事件后，BGP都会转至Idle状态。</li>
</ul>
</li>
<li><p>在Connect状态下，BGP启动连接重传定时器（Connect Retry），等待TCP完成连接。</p>
<ul>
<li>如果TCP连接成功，那么BGP向对等体发送Open报文，并转至OpenSent状态。</li>
<li>如果TCP连接失败，那么BGP转至Active状态。</li>
<li>如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP继续尝试和对等体进行TCP连接，停留在Connect状态。</li>
</ul>
</li>
<li><p>在Active状态下，BGP总是在试图建立TCP连接。</p>
<ul>
<li>如果TCP连接成功，那么BGP向对等体发送Open报文，关闭连接重传定时器，并转至OpenSent状态。</li>
<li>如果TCP连接失败，那么BGP停留在Active状态。</li>
<li>如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP转至Connect状态。</li>
</ul>
</li>
<li><p>在OpenSent状态下，BGP等待对等体的Open报文，并对收到的Open报文中的AS号、版本号、认证码等进行检查。</p>
<ul>
<li>如果收到的Open报文正确，那么BGP发送Keepalive报文，并转至OpenConfirm状态。</li>
<li>如果发现收到的Open报文有错误，那么BGP发送Notification报文给对等体，并转至Idle状态。</li>
</ul>
</li>
<li><p>在OpenConfirm状态下，BGP等待Keepalive或Notification报文。如果收到Keepalive报文，则转至Established状态，如果收到Notification报文，则转至Idle状态。</p>
</li>
<li><p>在Established状态下，BGP可以和对等体交换Update、Keepalive、Route-refresh报文和Notification报文。</p>
<ul>
<li>如果收到正确的Update或Keepalive报文，那么BGP就认为对端处于正常运行状态，将保持BGP连接。</li>
<li>如果收到错误的Update或Keepalive报文，那么BGP发送Notification报文通知对端，并转至Idle状态。</li>
<li>Route-refresh报文不会改变BGP状态。</li>
<li>如果收到Notification报文，那么BGP转至Idle状态。</li>
<li>如果收到TCP拆链通知，那么BGP断开连接，转至Idle状态。</li>
</ul>
</li>
</ol>
<p>BGP对等体双方的状态必须都为Established，BGP对等体（也可以称为BGP邻居）关系才能成立，双方通过Update报文交换路由信息。</p>
<h1 id="BGP路由的生成"><a href="#BGP路由的生成" class="headerlink" title="BGP路由的生成"></a>BGP路由的生成</h1><p>1）network：逐条在BGP协议中注入路由（其中origin属性位“i”）</p>
<p>注意：network注入的路由必须是路由器的路由表存在的路由</p>
<p>2）import-route：将某个协议的路由引入到路由表中，直连路由、静态路由、OSPF路由、IS-IS路由等（origin属性位“incomplete”）<br>3）路由聚合</p>
<p>bgp 200<br>aggregate 10.1.0.0 22 detail-suppressed</p>
<p>（detail-suppressed：BGP只会向对等体通告聚合后的路由，而不通告聚合前的明细路由）</p>
<p>自动聚合：summary automatic</p>
<ul>
<li>自动聚合：对BGP引入的路由进行聚合。配置自动聚合后，对参加聚合的具体路由进行抑制。配置自动聚合后，BGP将按照自然网段聚合路由（如10.1.1.1&#x2F;24和10.2.1.1&#x2F;24将聚合为A类地址10.0.0.0&#x2F;8），并且BGP向对等体只发送聚合后的路由。</li>
</ul>
<p>（自动聚合只能聚合import引入的路由）</p>
<p>优先级：手动＞自动＞network＞import＞从对等体学到</p>
<h1 id="BGP对等体通告原则"><a href="#BGP对等体通告原则" class="headerlink" title="BGP对等体通告原则"></a>BGP对等体通告原则</h1><p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/image-20240511134752905.png" alt="image-20240511134752905"></p>
<p>只发布最优路由—下一跳可达、最优路由</p>
<p>从EBGP对等体获取的路由，会发布给所有对等体。</p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps1.jpg" alt="img"> </p>
<ol start="3">
<li>IBGP水平分割：从IBGP对等体获取的路由，不会发送给IBGP对等体。</li>
</ol>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps2.jpg" alt="img"> </p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps3.jpg" alt="img"> </p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps4.jpg" alt="img"> </p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps5.jpg" alt="img"> </p>
<ol start="4">
<li>BGP同步规则指的是：当一台路由器从自己的IBGP对等体学习到一条BGP路由时（这类路由被称为IBGP路由），它将不能使用该条路由或把这条路由通告给自己的EBGP对等体，除非它又从IGP协议（例如OSPF等，此处也包含静态路由）学习到这条路由，也就是要求IBGP路由与IGP路由同步。同步规则主要用于规避BGP路由黑洞问题。</li>
</ol>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps6.jpg" alt="img"> </p>
<p>路由黑洞：解决办法：</p>
<p>①BGP–IGP互相引入   该方法不建议</p>
<p>②IBGP全互联</p>
<p>③MPLS</p>
<h1 id="BGP属性"><a href="#BGP属性" class="headerlink" title="BGP属性"></a>BGP属性</h1><p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/image-20240511135334705.png" alt="image-20240511135334705"></p>
<h1 id="AS-path属性："><a href="#AS-path属性：" class="headerlink" title="AS_path属性："></a>AS_path属性：</h1><p>该属性为公认必遵属性，是前往目标网络的路由经过的AS号列表；<br>作用：确保路由在EBGP对等体之间传递无环；另外也作为路由优选的衡量标准之一；<br>路由在被通告给EBGP对等体时，路由器会在该路由的AS_Path中追加上本地的AS号；路由被通告给IBGP对等体时，AS_Path不会发生改变。</p>
<p><strong>AS_path防环机制</strong>：路由每经过一个AS就会在AS_path中记录经过的AS 号，当路由器收到update报文，检查发现AS_path中含有本AS号，不接收该路由，从而防止了路由环路的产生。</p>
<p>AS_path影响路由优选：收到同一个网段多条路，比较AS_path属性，哪条路由的AS_Path属性值较短，也即AS号的个数更少，就优选哪条路由。</p>
<p><strong>AS-PATH类型：</strong></p>
<p>AS_SEQENCE：AS在传递时是有序的，默认就是该类型<br>AS_SET：无序的，在做路由聚合时可以使用该类型。路由聚合解决了两类问题，一是减轻了设备的负担，二是隐藏了明细的路由信息，减少了路由震荡的影响。但是路由聚合后，AS_Path属性丢失，存在产生环路的风险，为此可以通过AS_SET类型的AS_Path属性携带聚合前的AS路径信息。</p>
<p>修改AS_path：</p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps7.jpg" alt="img"> </p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps8.jpg" alt="img"> </p>
<p>①additive</p>
<p>#</p>
<p> acl number 2000  </p>
<p> rule 5 permit source 10.10.10.10 0 </p>
<p>#</p>
<p>route-policy aa permit node 10 </p>
<p> if-match acl 2000 </p>
<p> apply as-path 500 additive</p>
<p>#</p>
<p>bgp 200</p>
<p> peer 5.5.5.5 route-policy aa export</p>
<p>②overwrite</p>
<p>#</p>
<p> acl number 2000  </p>
<p> rule 5 permit source 10.10.10.10 0 </p>
<p>#</p>
<p>route-policy aa permit node 10 </p>
<p> if-match acl 2000 </p>
<p> apply as-path 500 overwrite</p>
<p>#</p>
<p>bgp 200</p>
<p> peer 5.5.5.5 route-policy aa export</p>
<h1 id="Origin属性"><a href="#Origin属性" class="headerlink" title="Origin属性"></a>Origin属性</h1><p>Origin属性用来定义路径信息的来源，标记一条路由是怎么成为BGP路由的。它有以下3种类型：</p>
<ul>
<li>IGP：具有最高的优先级。通过路由始发AS的IGP得到的路由信息，比如通过<strong>network</strong>命令注入到BGP路由表的路由，其Origin属性为IGP。</li>
<li>EGP：优先级次之。通过EGP得到的路由信息，其Origin属性为EGP。</li>
<li>Incomplete：优先级最低。通过其他方式学习到的路由信息。比如BGP通过<strong>import-route</strong>命令引入的路由，其Origin属性为Incomplete。</li>
</ul>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/image-20240511140106339.png" alt="image-20240511140106339"></p>
<p>当去往同一个目的地存在多条不同Origin属性的路由时，在其他条件都相同的情况下，BGP将按如Origin的下顺序优选路由：IGP &gt; EGP &gt; Incomplete。也就是i &gt; e &gt; ?</p>
<h1 id="Next-Hop"><a href="#Next-Hop" class="headerlink" title="Next-Hop"></a>Next-Hop</h1><ul>
<li><p>BGP的下一跳属性和IGP的有所不同，不一定就是邻居的IP地址。通常情况下，Next_Hop属性遵循下面的规则：</p>
<ul>
<li>BGP Speaker在向EBGP对等体发布某条路由时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。</li>
<li>BGP Speaker将本地始发路由发布给IBGP对等体时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。</li>
<li>BGP Speaker在向IBGP对等体发布从EBGP对等体学来的路由时，并不改变该路由信息的下一跳属性。</li>
</ul>
</li>
</ul>
<p>IBGP在进行路由传递时，下一跳地址 不变会造成路由不可达这种情况，可以使用一下命令修改</p>
<p>[AR2-bgp]peer 4.4.4.4 next-hop-local</p>
<h1 id="Local-Preference"><a href="#Local-Preference" class="headerlink" title="Local_Preference"></a>Local_Preference</h1><p>Local_Preference即本地优先级属性，是公认任意属性，可以用于告诉AS中的路由器，哪条路径是离开本AS的首选路径。<br>Local_Preference属性值越大则BGP路由越优。缺省的Local_Preference值为<strong>100</strong>。<br>该属性<strong>只能被传递给IBGP对等体</strong>，而不能传递给EBGP对等体。<strong>越大越优。</strong></p>
<p>注意事项：</p>
<p>Local_Preference属性只能在IBGP对等体间传递（除非做了策略否则Local_Preference值在IBGP对等体间传递过程中不会丢失），而不能在EBGP对等体间传递，如果在EBGP对等体间收到的路由的路径属性中携带了Local_Preference，则会进行错误处理。<br>但是可以在AS边界路由器上使用Import方向的策略来修改Local_Preference属性值。也就是在收到路由之后，在本地为路由赋予Local_Preference。<br>使用bgp default local-preference命令修改缺省Local_Preference值，该值缺省为100。<br>路由器在向其EBGP对等体发送路由更新时，不能携带Local_Preference属性，但是对方接收路由之后，会在本地为这条路由赋一个缺省Local_Preference值（100），然后再将路由传递给自己的IBGP对等体。<br>本地使用network命令及import-route命令引入的路由， Local_Preference为缺省值100，并能在AS内向其他IBGP对等体传递，传递过程中除非受路由策略影响，否则Local_Preference不变</p>
<h1 id="Community（团体）"><a href="#Community（团体）" class="headerlink" title="Community（团体）"></a>Community（团体）</h1><p>Community属性为可选过渡属性，是一种路由标记，用于简化路由策略的执行。<br>可以将某些路由分配一个特定的Community属性值，之后就可以基于Community值而不是网络前缀&#x2F;掩码信息来匹配路由并执行相应的策略了。</p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps9.jpg" alt="img"> </p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps10.jpg" alt="img"> </p>
<h1 id="MED"><a href="#MED" class="headerlink" title="MED"></a>MED</h1><p>（Multi-Exit Discriminator，多出口鉴别器）是可选非过渡属性，是一种度量值，用于向外部对等体指出进入本AS的首选路径，即当进入本AS的入口有多个时，AS可以使用MED动态地影响其他AS选择进入的路径。<br>MED属性值<strong>越小则BGP路由越优</strong>。<br>MED主要用于在AS之间影响BGP的选路。MED被传递给EBGP对等体后，对等体在其AS内传递路由时，携带该MED值，但将路由再次传递给其EBGP对等体时，<strong>缺省不会携带MED属性</strong>。0-4294967295</p>
<p>注意事项：</p>
<p>缺省情况下，<strong>路由器只比较来自同一相邻AS的BGP路由的MED值</strong>，也就是说如果去往同一个目的地的两条路由来自不同的相邻AS，则不进行MED值的比较。<br>一台BGP路由器将路由通告给EBGP对等体时，是否携带MED属性，需要根据以下条件进行判断（不对EBGP对等体使用策略的情况下）：<br>如果该BGP路由是本地始发（本地通过network或import-route命令引入）的，则缺省携带MED属性发送给EBGP对等体。<br>如果该BGP路由为从BGP对等体学习到，那么该路由传递给EBGP对等体时缺省不会携带MED属性。<br>在IBGP对等体之间传递路由时，MED值会被保留并传递，除非部署了策略，否则MED值在传递过程中不发生改变也不会丢失。<br>如果路由器通过IGP学习到一条路由，并通过network或import-route的方式将路由引入BGP，产生的BGP路由的MED值继承路由在IGP中的metric。</p>
<p>可以使用default med命令修改缺省的MED值，default med命令只对本设备上用import-route命令引入的路由和BGP的聚合路由生效。</p>
<h1 id="Preferred-Value（协议首选值）"><a href="#Preferred-Value（协议首选值）" class="headerlink" title="Preferred-Value（协议首选值）"></a>Preferred-Value（协议首选值）</h1><p>是华为设备的特有属性，该属性仅在本地有效。当BGP路由表中存在到相同目的地的路由时，将优先选择Preferred-Value值高的路由。<br>取值范围：0~65535；该值越大，则路由越优先。<br>Preferred-Value只能在路由器本地配置，而且只影响本设备的路由优选。该属性不会传递给任何BGP对等体。</p>
<h1 id="路由反射器"><a href="#路由反射器" class="headerlink" title="路由反射器"></a>路由反射器</h1><p>作用：解决IBGP全互联的问题</p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps1-1715409454233-11.jpg" alt="img"> </p>
<p>1、RR从EBGP学习到的，会发送给client和非client</p>
<p>2、RR从非client学习到的路由，会反射给自己的client，但是不会给非client</p>
<p>3、RR从client学习到的路由，会反射非自己的非client和client</p>
<p>非非不传</p>
<p>路由反射器中的防环：<strong>Originator_ID，Cluster_List</strong><br>RR将一条BGP路由进行反射时会在反射出去的路由中增加Originator_ID，其值为本地AS中通告该路由的BGP路由器Router ID。<br>若AS内存在多个RR，则Originator_ID属性由第一个RR创建，并且不被后续的RR（若有）所更改。<br>当BGP路由器收到一条携带Originator_ID属性的IBGP路由，并且Originator_ID属性值与自身的Router ID相同，则它会忽略关于该条路由的更新。</p>
<p>路由反射簇包括反射器RR及其Client。一个AS内允许存在多个路由反射簇（如下图）。<br>每一个簇都有唯一的簇ID（Cluster_ID，缺省时为RR的BGP Router ID ）。<br>当一条路由被反射器反射后，该RR（该簇）的Cluster_ID就会被添加至路由的Cluster_list属性中。<br>当RR收到一条携带Cluster_list属性的BGP路由，且该属性值中包含该簇的Cluster_ID时，RR认为该条路由存在环路，因此将忽略关于该条路由的更新。</p>
<p>配置：</p>
<p>在RR路由器上配置：</p>
<p>Bgp 200</p>
<p>   peer 6.6.6.6 reflect-client  –谁是client，就peer谁</p>
<p>缺省情况下，每个路由反射器使用自己的Router ID作为集群ID。<br>[Huawei-bgp] reflector cluster-id  20.2.2.2</p>
<h1 id="路由优选原则："><a href="#路由优选原则：" class="headerlink" title="路由优选原则："></a>路由优选原则：</h1><p>P   L  L  A  O  M  E  N 漂亮老男人</p>
<p>p—Preference Value (越大越优，仅限路由器本地)</p>
<p>L— Local Preference，本地优先级 (越大越优，同一AS内的路由器）</p>
<p>L— 手动聚合-&gt;自动聚合-&gt;network-&gt;import，为本地始发</p>
<p>A —AS Path (短的优先)</p>
<p>O —Origin，起源i(network)&gt;e(EBGP)&gt;? (import-route)</p>
<p>M—MED (值越小越优，本AS内或上游AS内所有路由器，EBGP邻居上设置)</p>
<p>E— EBGP优于IBGP (前面都一样，比不出最优路径时)</p>
<p>N— Next-Hop，下一跳(BGP选择IGP下一跳cost值最小的)</p>
<p>9.优选Cluster-List最短的路由</p>
<p>10.优选Router-ID（Origintor- ID）最小的设备通告的路由</p>
<p>11.优选具有最小的IP地址的对等体通告的路由</p>
<p>前八条全部相同形成路由负载分担</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>BGP</tag>
      </tags>
  </entry>
  <entry>
    <title>BGP路由反射器</title>
    <url>/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/</url>
    <content><![CDATA[<h1 id="BGP路由反射器"><a href="#BGP路由反射器" class="headerlink" title="BGP路由反射器"></a>BGP路由反射器</h1><p>由于水平分割的原因，为了保证AS内所有的BGP路由器都能学习到完整的BGP路由，就必须在AS内实现IBGP全互联。</p>
<p>然而实现IBGP全互联存在诸多短板：</p>
<p> 路由器需维护大量的TCP及BGP连接，尤其在路由器数量较多时。</p>
<p> AS内BGP网络的可扩展性较差，因为通过纯手工配置命令。</p>
<p>为了解决该问题，可应用到RR路由反射器技术。</p>
<p>1、Client：RR客户端，在RR设备上通过手动指定。</p>
<blockquote>
<p>指定命令：peer 邻居 reflect-client</p>
</blockquote>
<p>2、除了指定的设备为客户端，其它设备均为非客户端。</p>
<p>实验：</p>
<p>R1、R2、R3、R4都属于AS64511，其连接方式、互联接口地址如图所示。每台设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号。R1、R2上的Loopback1地址分别为10.1.1.1&#x2F;24、10.2.2.2&#x2F;24，用于模拟用户网段。</p>
<span id="more"></span>

<p>所有设备都使用Loopback0地址作为BGP Router ID，R1与R2、R2与R3、R3与R4、R4与R2之间基于直连接口建立IBGP对等体关系，其中R1为R2的路由反射器客户端，R2为R3的路由反射器客户端，R3为R4的路由反射器客户端。</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/bgpluy8165208.png" alt="bgpluy8165208"></p>
<p>配置ip地址：略</p>
<p>建立ibgp对等体：略</p>
<h1 id="配置路由反射器"><a href="#配置路由反射器" class="headerlink" title="配置路由反射器"></a>配置路由反射器</h1><p>#R2上将R1配置为路由反射器客户端</p>
<p>[R2]bgp 64511</p>
<p>[R2-bgp] peer 10.0.1.1 reflect-client</p>
<p>#R3上将R2配置为路由反射器客户端</p>
<p>[R3]bgp 64511</p>
<p>[R3-bgp] peer 10.0.2.2 reflect-client</p>
<p>#R4上将R3配置为路由反射器客户端</p>
<p>[R4]bgp 64511</p>
<p>[R4-bgp] peer 10.0.3.3 reflect-client</p>
<h1 id="验证Orginator-ID实现路由防环"><a href="#验证Orginator-ID实现路由防环" class="headerlink" title="验证Orginator_ID实现路由防环"></a>验证Orginator_ID实现路由防环</h1><p>在本步骤中，我们将在R2上发布BGP路由10.2.2.0&#x2F;24，并观察该路由依次经路由反射器R3、R4反射后，被通告回R2从而引发潜在路由环路风险的情况。</p>
<p>缺省情况下，R2发布BGP路由后，该路由将被R2直接通告给R4，另一方面也会通过R3反射给R4，此时R4将优选R2直接通告过来的路由，从而不会再将R3反射过来的路由再反射回给R2。为此，我们需要在R2上部署路由策略，使R2不直接向R4通告10.2.2.0&#x2F;24路由。</p>
<p>#配置路由策略</p>
<p>[R2]acl number 2000</p>
<p>[R2-acl-basic-2000] rule 5 permit</p>
<p>[R2-acl-basic-2000] quit</p>
<p>[R2]route-policy bgp deny node 10</p>
<p>[R2-route-policy] if-match acl 2000</p>
<p>#在BGP中调用路由策略</p>
<p>[R2]bgp 64511</p>
<p>[R2-bgp] peer 10.0.24.4 route-policy bgp export</p>
<p>#在R2上发布路由</p>
<p>[R2]bgp 64511</p>
<p>[R2-bgp] network 10.2.2.0 24</p>
<p>#R2上查看BGP路由10.2.2.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/chakan102224728.png" alt="chakan102224728"></p>
<p>R2将该条路由通告给了R3、R1，但是并未通告给R4。</p>
<p>#R3上查看BGP路由10.2.2.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/r174808.png" alt="r174808"></p>
<p>R3将来自反射器客户端的BGP路由10.2.2.0&#x2F;24反射给了10.0.34.4（R4）。同时该BGP路由的nexthop为10.0.23.2。</p>
<p># R4上查看BGP路由10.2.2.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/r4chakan80119.png" alt="r4chakan80119"></p>
<p>该条路由来自反射器客户端R3，原始路由经由R3反射，路由的nexthop地址并未改变，同时R3为其添加了Orginator_ID属性，值为10.0.2.2。同时R4将该条路由反射给了R2。</p>
<p>#再次在R2上查看BGP路由10.2.2.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/zacifa80349.png" alt="zacifa80349"></p>
<p>依旧只存在本地通告的BGP路由，没有R4通告的BGP路由。</p>
<p>#在R2上查看BGP对等体10.0.4.4的详细信息</p>
<p>display bgp peer 10.0.4.4 verbose</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/safhaofbsh1128180629.png" alt="safhaofbsh1128180629"></p>
<p>从输出信息可以看到R2从R4收到了1个Update报文，未向R4发送Update报文（路由策略限制），但是本地BGP路由表中不存在由R4通告的BGP路由10.2.2.0&#x2F;24。</p>
<p>R4通告的BGP路由Orginator_ID属性值与本地的Router ID一致，R2忽略了该路由通告。</p>
<h1 id="验证Cluster-List实现路由防环"><a href="#验证Cluster-List实现路由防环" class="headerlink" title="验证Cluster_List实现路由防环"></a>验证Cluster_List实现路由防环</h1><p>为了方便观察现象，取消R2上的BGP路由发布，在R1上将Loopback1接口路由发布到BGP，观察Cluster_List如何防止环路。</p>
<p>#取消R2上的BGP路由发布</p>
<p>[R2]bgp 64511</p>
<p>[R2-bgp] undo network 10.2.2.0 255.255.255.0</p>
<p>#在R1上将Loopback1接口路由发布到BGP</p>
<p>[R1]bgp 64511</p>
<p>[R1-bgp] network 10.1.1.0 24</p>
<p>#依次在R1、R2、R3、R4上查看BGP路由10.1.1.0 &#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/xinfuaiell181000.png" alt="xinfuaiell181000"></p>
<p>R1为BGP路由10.1.1.0&#x2F;24的始发者，R1将路由通告给了R2</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/2xinfahol128181116.png" alt="2xinfahol128181116"></p>
<p>来自路由反射器客户端R1的BGP路由10.1.1.0&#x2F;24，R2将其反射给了R3</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/3xinmbxmcx1128181206.png" alt="3xinmbxmcx1128181206"></p>
<p>来自路由反射器客户端R2的BGP路由10.1.1.0&#x2F;24，R2反射时添加了Cluster_List属性，值为10.0.2.2，R3将该条路由反射给了R4</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/44xinm1334.png" alt="44xinm1334"></p>
<p>来自路由反射器客户端R3的BGP路由10.1.1.0&#x2F;24，R3反射时添加了Cluster_List属性的值，当前值为10.0.3.3，10.0.2.2，R4将该条路由反射给了R2</p>
<p>#再次查看R2的BGP路由表</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/zaizaici661435.png" alt="zaizaici661435"></p>
<p>R2的BGP路由表中依旧只有一条来自r1的BGP路由10.1.1.0&#x2F;24。</p>
<p>4通告的BGP路由其Cluster_List属性值中包含了R2的Cluster-ID，R2忽略了该路由通告。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>BGP路由反射器</tag>
      </tags>
  </entry>
  <entry>
    <title>BGP路由优选</title>
    <url>/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/</url>
    <content><![CDATA[<h1 id="BGP路由优选"><a href="#BGP路由优选" class="headerlink" title="BGP路由优选"></a>BGP路由优选</h1><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>你是公司的网络管理员。公司的网络采用了BGP协议接入了两个服务运营商。公司自己采用了私有的AS号64512，ISP1的AS号为100，ISP2的AS号为200。通过AS100、AS200都可以到达相同的网络，你通过改变BGP的各种属性达到了调整路由走向的目的。</p>
<span id="more"></span>

<p>实验介绍：</p>
<p>设备互联方式、互联接口地址如图所示，所有设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号，所有设备都使用Loopback0地址作为BGP Router ID。</p>
<p>R1在AS100，R5在AS200，R2、R3、R4在AS64512。AS64512内运行OSPF，在互联接口（不包括连接外部AS的接口）、Loopback0接口上激活OSPF。</p>
<p>EBGP对等体关系基于直连接口建立，IBGP对等体关系基于Loopback0接口建立。</p>
<p>R1、R5上存在相同的网段172.16.1.0&#x2F;24、172.16.2.0&#x2F;24、172.16.3.0&#x2F;24、172.16.4.0&#x2F;24，在R1、R5上将其发布到BGP，以用于BGP路由优选。</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/tuopu22sd182306.png" alt="tuopu22sd182306"></p>
<p>配置ip，配置bgp：略</p>
<p>#在R1、R5上将Loopback1、Loopback2、Loopback3、Loopback4接口路由发布到BGP中</p>
<p>[R1]bgp 100</p>
<p>[R1-bgp] network 172.16.1.0 24</p>
<p>[R1-bgp] network 172.16.2.0 24</p>
<p>[R1-bgp] network 172.16.3.0 24</p>
<p>[R1-bgp] network 172.16.4.0 24</p>
<p>[R5]bgp 200</p>
<p>[R5-bgp] network 172.16.1.0 24</p>
<p>[R5-bgp] network 172.16.2.0 24</p>
<p>[R5-bgp] network 172.16.3.0 24</p>
<p>[R5-bgp] network 172.16.4.0 24</p>
<p>#在R3上查看BGP路由表，检查BGP路由是否成功学习</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/r3chakandp128185306.png" alt="r3chakandp128185306"></p>
<p>R3已经成功学习R1、R5发布的路由，此时所有路由都优选由R2通告的。</p>
<h2 id="修改AS-Path属性"><a href="#修改AS-Path属性" class="headerlink" title="修改AS_Path属性"></a>修改AS_Path属性</h2><p>在R1上通过路由策略修改BGP路由172.16.1.0&#x2F;24的 AS_Path属性值，使得R3优选R5发布的BGP路由172.16.1.0&#x2F;24。</p>
<p>#创建IP前缀列表1，匹配Loopback1接口路由</p>
<p>[R1]ip ip-prefix 1 permit 172.16.1.0 24 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1，修改AS_Path属性值</p>
<p>[R1]route-policy hcip permit node 10</p>
<p>[R1-route-policy] if-match ip-prefix 1</p>
<p>[R1-route-policy] apply as-path 300 400 additive</p>
<p>[R1-route-policy] quit</p>
<p>[R1]route-policy hcip permit node 20</p>
<p>注意创建一个空节点，对于另外3条BGP路由不执行任何操作。</p>
<p>#对向BGP对等体R2通告的BGP路由应用Route-Policy</p>
<p>[R1]bgp 100</p>
<p>[R1-bgp] peer 10.0.12.2 route-policy hcip export</p>
<p>#在R1上触发出方向的软复位，刷新对外通告的BGP路由</p>
<p><R1>refresh bgp all export</R1></p>
<p>#在R3上查看BGP路由172.16.1.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/as5cs28190005.png" alt="as5cs28190005"></p>
<p>此时R3优选R4通告的BGP路由172.16.1.0&#x2F;24，R2通告的未被优选的原因是AS_Path长度。</p>
<h2 id="修改Local-Preference属性"><a href="#修改Local-Preference属性" class="headerlink" title="修改Local_Preference属性"></a>修改Local_Preference属性</h2><p>local_Preference：默认100，越大越优先，只能在ibgp对等体之间传递</p>
<p>在R4上通过路由策略修改BGP路由172.16.2.0&#x2F;24的Local_Preference属性值，使得R3优选R4通告的BGP路由172.16.2.0&#x2F;24。</p>
<p>#创建IP前缀列表1，匹配BGP路由172.16.2.0&#x2F;24</p>
<p>[R4]ip ip-prefix 1 permit 172.16.2.0 24 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1，修改Local_Preference属性值</p>
<p>[R4]route-policy hcip permit node 10</p>
<p>[R4-route-policy] if-match ip-prefix 1</p>
<p>[R4-route-policy] apply local-preference 200</p>
<p>[R4-route-policy] quit</p>
<p>[R4]route-policy hcip permit node 20</p>
<p>注意创建一个空节点，对于另外3条BGP路由不执行任何操作。</p>
<p>#对向BGP对等体R3通告的BGP路由应用Route-Policy</p>
<p>[R4]bgp 64512</p>
<p>[R4-bgp] peer 10.0.3.3 route-policy hcip export</p>
<p>#在R4上触发出方向的软复位，刷新对外通告的BGP路由</p>
<p><R4>refresh bgp all export</R4></p>
<p>#在R3上查看BGP路由172.16.2.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/local55chakan192014.png" alt="local55chakan192014"></p>
<p>此时R3优选R4通告的BGP路由172.16.2.0&#x2F;24，R2通告的BGP路由其Local_Preference值为100，小于R3通告的BGP路由Local_Preference值200，因此R2通告的BGP路由未被优选。</p>
<h2 id="修改MED属性"><a href="#修改MED属性" class="headerlink" title="修改MED属性"></a>修改MED属性</h2><p>在R2上通过路由策略修改BGP路由172.16.3.0&#x2F;24的MED属性值，使得R3优选R5发布的BGP路由172.16.3.0&#x2F;24。</p>
<p>#创建IP前缀列表1，匹配BGP路由172.16.3.0&#x2F;24</p>
<p>[R2]ip ip-prefix 1 permit 172.16.3.0 24 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1，修改MED属性值</p>
<p>[R2]route-policy hcip permit node 10</p>
<p>[R2-route-policy] if-match ip-prefix 1</p>
<p>[R2-route-policy] apply cost 200</p>
<p>[R2-route-policy] quit</p>
<p>[R2]route-policy hcip permit node 20</p>
<p>注意创建一个空节点，对于另外3条BGP路由不执行任何操作。</p>
<p>#对来自BGP对等体R1的BGP路由应用Route-Policy</p>
<p>[R2]bgp 64512</p>
<p>[R2-bgp] peer 10.0.12.1 route-policy hcip import</p>
<p>#在R2上触发入方向的软复位，刷新接收到的BGP路由</p>
<p><R2>refresh bgp all import</R2></p>
<p>#在R3上配置允许比较来自不同AS的BGP路由的MED值</p>
<p>[R3]bgp 64512</p>
<p>[R3-bgp] compare-different-as-med  </p>
<p>缺省情况下，不比较来自不同AS邻居的BGP的MED属性值。</p>
<p>#在R3上查看BGP路由172.16.3.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/medchakanf2735.png" alt="medchakanf2735"></p>
<p>R2通告的BGP路由172.16.3.0&#x2F;24其MED值为200，而R4通告BGP路由MED值为0，R3优选MED值较小的BGP路由，因此R2通告的BGP路由未被优选。</p>
<h2 id="修改preferred-value属性"><a href="#修改preferred-value属性" class="headerlink" title="修改preferred-value属性"></a>修改preferred-value属性</h2><p>preferred-value：华为特有的属性值，仅在本地有效，当bgp存在到相同的路由时，将优选prefeerred-value大的路由。只能在路由器本地配置，只影响本设备的路由优选，不会传递给任何bgp对等体。</p>
<p>在R3上通过路由策略修改BGP路由172.16.4.0&#x2F;24的preferred-value属性值，使得R3优选R4通告的BGP路由172.16.4.0&#x2F;24。</p>
<p>#创建IP前缀列表1，匹配BGP路由172.16.4.0&#x2F;24</p>
<p>[R3]ip ip-prefix 1 permit 172.16.4.0 24 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1，修改preferred-value属性值</p>
<p>[R3]route-policy hcip permit node 10</p>
<p>[R3-route-policy] if-match ip-prefix 1</p>
<p>[R3-route-policy] apply preferred-value 300</p>
<p>[R3-route-policy] quit</p>
<p>[R3]route-policy hcip permit node 20</p>
<p>注意创建一个空节点，对于另外3条BGP路由不执行任何操作。</p>
<p>#对来自BGP对等体R4的BGP路由应用Route-Policy</p>
<p>[R3]bgp 64512</p>
<p>[R3-bgp] peer 10.0.4.4 route-policy hcip import</p>
<p>#在R3上触发入方向的软复位，刷新收到的BGP路由</p>
<p><R3>refresh bgp all import</R3></p>
<p>#在R3上查看BGP路由172.16.4.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/prexiiuhai8193458.png" alt="prexiiuhai8193458"></p>
<p>R4通告的BGP路由172.16.3.0&#x2F;24其preferred-value值为300，而R2通告的preferred-value值为0，R3优选preferred-value值较大的BGP路由，因此R3优选R4通告的BGP路由。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>BGP路由优选</tag>
      </tags>
  </entry>
  <entry>
    <title>DHCP基础配置</title>
    <url>/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p> DHCP是一种终端自动配置协议，客户端通过DHCP协议可获取一个合法的动态IP地址。</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>随着网络规模的扩大和网络复杂度的提高，网络配置越来越复杂，经常出现计算机位置变化（如便携机或无线网络）和计算机数量超过可分配的IP地址的情况。动态主机配置协议DHCP（Dynamic Host Configuration Protocol）就是为满足这些需求而发展起来的。DHCP协议以服务器&#x2F;客户端（Server&#x2F;Client）模式工作，DHCP客户端向DHCP服务器动态地请求配置信息，DHCP服务器可以很方便地为客户端动态发送配置信息。</p>
<h3 id="DHCP服务器"><a href="#DHCP服务器" class="headerlink" title="DHCP服务器"></a>DHCP服务器</h3><p>DHCP Server即DHCP服务器，负责客户端IP地址的分配。客户端向服务器发送配置申请报文（包括IP地址、子网掩码、缺省网关等参数），服务器根据策略返回携带相应配置信息的报文，请求报文和回应报文都采用UDP进行封装。</p>
<h3 id="DHCP中继"><a href="#DHCP中继" class="headerlink" title="DHCP中继"></a>DHCP中继</h3><p>DHCP Relay即DHCP中继，它是为解决服务器和客户端不在同一个网段而提出来的，它提供了对DHCP广播报文的透明传输功能，能够把DHCP客户端的广播报文透明地传送到其它网段的DHCP服务器上，同样能够把DHCP服务器端的广播报文透明地传送到其它网段的DHCP客户端。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>基本命令<br><strong>pc：</strong></p>
<p>ipconfig &#x2F;release—释放ip地址<br>ipconfig &#x2F;renew—重新获取ip</p>
<p><strong>将DHCP转化为固定的地址：</strong></p>
<p>ip pool 名字—进入地址池<br>staic-bind ip-address 要分配的固定ip mac-address 目标的mac地址—添加固定地址到pc端<br>lease day &lt;0-999&gt;—修改租期（不建议修改）</p>
<p>将部分ip地址排除地址池，用于静态路由配置</p>
<p>ip pool 名字—进入地址池<br>excluded-ip-address 192.168.1.1 192.168.1.50—把1.1到1.50的地址排除出地址池不使用</p>
<p><strong>重置与查看地址池</strong></p>
<p>reset ip pool name 名字—重置ip配置<br>dis ip pool name 名字—查看指定地址池<br>dis ip pool—查看地址池<br>dis ip pool 名字 used—查看使用情况</p>
<p><strong>配置global全局模式</strong></p>
<p>先配置物理接口</p>
<p>interface 接口号—进入物理接口<br>ip address ip地址—配置物理接口IP</p>
<p>DHCP enable—开启DHCP功能<br>ip pool 名字—创建一个ip地址池（有几个网段就建几个池）<br>network 192.168.1.0 mask 24—给ip地址池添加一个网段<br>gateway-list 192.168.1.1—设置192.168.1.1这个ip地址为网关<br>dns-list 8.8.8.8 192.168.1.1—配置DNS为8.8.8.8（前面的优先）<br>interface ip地址—进入物理接口<br>dhcp select global—给接口配置全局模式</p>
<p>将pc更改为DHCP获取IP方式，就可以自动分配ip地址了</p>
<p><strong>interface配置方式</strong><br>基于接口的DHCP的配置方式：<br>配置物理接口的ip网关：</p>
<p>interface 接口号—进入接口<br>ip address IP网关—配置网关</p>
<p>dhcp enable—开启服务<br>dhcp select interface—选择interface这个配置方式<br>dhcp server dns-list 8.8.8.8-–配置DNS服务</p>
<p>注意：这种配置方式分配的ip地址网段，是该接口所在的网段的ip地址，网关就是这个接口的ip地址</p>
<p><strong>relay（中继）配置方式</strong></p>
<p>用于在服务器上做配置，路由器进行转发，减少负载量，可以对整个网络体系进行配置<br>首先要实现服务器与个网段互通<br>在服务器的配置：</p>
<p>服务器物理接口配置ip<br>ip route-static 0.0.0.0 0 下一跳的ip—服务器配置缺省路由保证互通<br>dhcp enable—在服务器开启dhcp功能<br>ip pool 名字—创建ip地址池（需要几个网段就创建几个地址池）<br>network 192.168.1.0 mask 24—创建网段<br>gateway-list 192.168.1.1—创建网关<br>dns-list 8.8.8.8—创建dns<br>interface 物理接口—进入物理接口<br>dhcp select global—选择全局配置模式</p>
<p><strong>在路由器&#x2F;核心交换机上的配置</strong></p>
<p>dhcp enable—开启dhcp功能<br>interface 接口号—进入接口 （需要几个网段就分别进入配置）<br>dhcp select relay—开启中继模式<br>dhcp relay server-ip 服务器物理ip—选择中继分配的接口</p>
<h1 id="基本实验"><a href="#基本实验" class="headerlink" title="基本实验"></a>基本实验</h1><p><img src="/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/newtu222.png" alt="newtu222"></p>
<ol>
<li>R1和R3模拟客户端，作为DHCP Client。</li>
<li>R2作为DHCP Server为R1和R3分配IP地址。</li>
</ol>
<p>动态主机配置协议DHCP（Dynamic Host Configuration Protocol）是一种用于集中对用户IP地址进行动态管理和配置的技术。即使规模较小的网络，通过DHCP也可以使后续增加网络设备变得简单快捷。</p>
<p>DHCP协议由RFC 2131定义，采用客户端&#x2F;服务器通信模式，由客户端（DHCP Client）向服务器（DHCP Server）提出配置申请，服务器返回为客户端分配的配置信息。</p>
<p>DHCP可以提供两种地址分配机制，网络管理员可以根据网络需求为不同的主机选择不同的分配策略。</p>
<p>• 动态分配机制：通过DHCP为主机分配一个有使用期限（这个使用期限通常叫做租期）的IP地址。这种分配机制适用于主机需要临时接入网络或者空闲地址数小于网络主机总数且主机不需要永久连接网络的场景。</p>
<p>• 静态分配机制：网络管理员通过DHCP为指定的主机分配固定的IP地址。相比手工静态配置IP地址，通过DHCP方式静态分配机制避免人工配置发生错误，方便管理员统一维护管理。</p>
<p>配置R2 ip：略</p>
<h2 id="开启DHCP功能"><a href="#开启DHCP功能" class="headerlink" title="开启DHCP功能"></a>开启DHCP功能</h2><p>[R1]dhcp enable </p>
<p>Info: The operation may take a few seconds. Please wait for a moment.done.</p>
<p><strong>dhcp enable</strong>命令是DHCP相关功能的总开关，DHCP Client和DHCP Server等功能都要在执行dhcp enable命令使能DHCP功能后才会生效。</p>
<p>[R2]dhcp enable </p>
<p>Info: The operation may take a few seconds. Please wait for a moment.done.</p>
<p>[R3]dhcp enable </p>
<p>Info: The operation may take a few seconds. Please wait for a moment.done.</p>
<h2 id="配置地址池"><a href="#配置地址池" class="headerlink" title="配置地址池"></a>配置地址池</h2><p># 配置R2的GigabitEthernet 0&#x2F;0&#x2F;0的接口地址池，为R1分配IP地址 </p>
<p>[R2]interface GigabitEthernet 0&#x2F;0&#x2F;0</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;0]dhcp select interface </p>
<p><strong>dhcp select interface</strong>命令用来开启接口采用接口地址池的DHCP Server功能。若不执行此命令，则无法配置接口地址池的相关参数。</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;0]dhcp server dns-list 10.0.12.2 </p>
<p><strong>dhcp server dns-list</strong>命令用来指定接口地址池下的DNS服务器地址。最多可以配置8个DNS Server的IP地址，用空格分隔。</p>
<p># 配置全局地址池 </p>
<p>[R2]ip pool GlobalPool</p>
<p>Info: It’s successful to create an IP address pool.</p>
<p><em>创建名<strong>为</strong>G**lobalPool的地址池</em></p>
<p>[R2-ip-pool-GlobalPool]network 10.0.23.0 mask 24 </p>
<p><strong>network</strong>命令用来配置全局地址池下可分配的网段地址。</p>
<p>[R2-ip-pool-GlobalPool]dns-list 10.0.23.2 </p>
<p>[R2-ip-pool-GlobalPool]gateway-list 10.0.23.2 </p>
<p><strong>gateway-list</strong>命令用来为DHCP Client配置出口网关地址。R3在获取地址之后，会生成一条默认路由，下一跳地址为10.0.23.2。</p>
<p>[R2-ip-pool-GlobalPool]lease day 2 hour 2 </p>
<p><strong>lease</strong>命令用来配置地址池下的地址租期。当租约被设置为<strong>unlimited</strong>时，代表租期无限制。缺省情况下，IP地址租期是1天。</p>
<p>[R2-ip-pool-GlobalPool]static-bind ip-address 10.0.23.3 mac-address 00e0-fc6f-6d1f</p>
<p><strong>static-bind</strong>命令用来将DHCP Server全局地址池下的IP地址与MAC地址进行绑定。00e0-fc6f-6d1f为当前实验环境下R3的GigabitEthernet0&#x2F;0&#x2F;0接口的MAC地址，可以在R3上通过命令“display interface GigabitEthernet0&#x2F;0&#x2F;0”来查看接口的MAC地址。配置完这条命令之后，R3会获得固定的IP–10.0.23.3。</p>
<p>[R2-ip-pool-GlobalPool]quit</p>
<p>#开启R2 GigabitEthernet 0&#x2F;0&#x2F;1接口的DHCP Server功能，为R3分配IP地址  </p>
<p>[R2]interface GigabitEthernet 0&#x2F;0&#x2F;1</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1]dhcp select global</p>
<p><strong>dhcp select global</strong>命令用来开启接口采用全局地址池的DHCP Server功能。当接口收到DHCP Client请求之后，会到所有全局地址池中查找对应的地址池，然后分配可用的地址给DHCP Client。</p>
<h2 id="配置DHCP-Client"><a href="#配置DHCP-Client" class="headerlink" title="配置DHCP Client"></a>配置DHCP Client</h2><p>[R1]interface GigabitEthernet 0&#x2F;0&#x2F;0</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;0] ip address dhcp-alloc</p>
<p>[R3]interface GigabitEthernet 0&#x2F;0&#x2F;0</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;0] ip address dhcp-alloc</p>
<h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><h5 id="查看R1和R3的地址及路由等信息"><a href="#查看R1和R3的地址及路由等信息" class="headerlink" title="查看R1和R3的地址及路由等信息"></a>查看R1和R3的地址及路由等信息</h5><p>[R1]display ip interface brief </p>
<p>Interface             	IP Address&#x2F;Mask    Physical  	Protocol  </p>
<p>GigabitEthernet0&#x2F;0&#x2F;0       	<strong>10.0.12.254&#x2F;24</strong>    	up     up     </p>
<p> <em>仅保留<strong>关键信息，可</strong>以<strong>看到</strong>R1已经<strong>获取到了</strong>IP地址**。</em></p>
<p>[R1]display dns server </p>
<p>Type:</p>
<p>D:Dynamic   S:Static</p>
<p>No.  Type   IP Address</p>
<p>1   D   	10.0.12.2 </p>
<p><em>仅保留<strong>关键信息，可</strong>以<strong>看到</strong>R1已经<strong>获取到了DNS</strong>地址**。</em></p>
<p>[R1]display ip routing-table </p>
<p>Destination&#x2F;Mask   Proto  	Pre  Cost  	Flags 	NextHop     Interface</p>
<p>   0.0.0.0&#x2F;0  		<strong>Unr</strong>   60  0    D  		10.0.12.2    GigabitEthernet0&#x2F;0&#x2F;0</p>
<p><em>仅保留<strong>关键信息，可</strong>以<strong>看到</strong>R1已经<strong>获取到了</strong>默认路由**。</em></p>
<p>[R3]display ip interface brief </p>
<p>Interface            	IP Address&#x2F;Mask    Physical 	Protocol  </p>
<p>GigabitEthernet0&#x2F;0&#x2F;0       	<strong>10.0.23.3&#x2F;24</strong>     	up    up     </p>
<p><em>仅保留<strong>关键信息，可</strong>以<strong>看到</strong>R3已经<strong>获取到了</strong>固定<strong>的</strong>IP地址**。</em></p>
<p>[R3]display dns server </p>
<p>Type:</p>
<p>D:Dynamic   S:Static</p>
<p>No.  Type   IP Address</p>
<p>1   D    2.23.0.10</p>
<p><em>仅保留<strong>关键信息，可</strong>以<strong>看到</strong>R<strong>3</strong>已经<strong>获取到了DNS</strong>地址**。</em></p>
<p>[R3]display ip routing-table </p>
<p>Route Flags: R - relay, D - download to fib</p>
<p>-—————————————————————————–</p>
<p>Routing Tables: Public</p>
<p>​     Destinations : 8     Routes : 8     </p>
<p>Destination&#x2F;Mask   Proto  	Pre  Cost  Flags 	NextHop   	Interface</p>
<p>   0.0.0.0&#x2F;0    Unr   	60  0   D  		10.0.23.2  	GigabitEthernet0&#x2F;0&#x2F;0</p>
<p><em>仅保留<strong>关键信息，可</strong>以<strong>看到</strong>R3已经<strong>获取到了</strong>默认路由**。</em></p>
<h5 id="2、查看R2上的地址分配情况"><a href="#2、查看R2上的地址分配情况" class="headerlink" title="2、查看R2上的地址分配情况"></a>2、查看R2上的地址分配情况</h5><p>[R2]display ip pool name GlobalPool </p>
<p> Pool-name    : GlobalPool</p>
<p> Pool-No     : 1</p>
<p> Lease      : <strong>2 Days 2 Hours 0 Minutes</strong></p>
<p> Domain-name   : -</p>
<p> DNS-server0   	: 10.0.23.2    </p>
<p> NBNS-server0  	: -        </p>
<p> Netbios-type  		: -        </p>
<p> Position    		: Local      Status      : Unlocked</p>
<p> Gateway-0    : <strong>10.0.23.2</strong>    </p>
<p> Mask      	: <strong>255.255.255.0</strong></p>
<p> VPN instance  		: –</p>
<p> -—————————————————————————-</p>
<p>​     Start      End   Total  Used  Idle(Expired)  Conflict  Disable</p>
<p> -—————————————————————————-</p>
<p>​    10.0.23.1   10.0.23.254  253   <strong>1</strong>     252(0)     0     0</p>
<p> -—————————————————————————-</p>
<p><strong>display ip pool</strong>命令用来查看已配置的IP地址池信息。包括地址池的名称、租期、锁定状态、地址池中IP地址的状态等。</p>
<p>[R2]display ip pool interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p> Pool-name    : <strong>GigabitEthernet****0&#x2F;0&#x2F;1</strong></p>
<p> Pool-No     : 0</p>
<p> Lease      : <strong>1 Days 0 Hours 0 Minutes</strong></p>
<p> Domain-name   : -</p>
<p> DNS-server0   	: <strong>10.0.12.2</strong>    </p>
<p> NBNS-server0  	: -        </p>
<p> Netbios-type  		: -        </p>
<p> Position    	: Interface    Status      : Unlocked</p>
<p> Gateway-0    : <strong>10.0.12.2</strong>    </p>
<p> Mask      	: 255.255.255.0</p>
<p> VPN instance  		: –</p>
<p> -—————————————————————————-</p>
<p>​     Start  		End   		Total  Used  	Idle(Expired)  Conflict  Disable</p>
<p> -—————————————————————————-</p>
<p>​    10.0.12.1   	10.0.12.254  	253   <strong>1</strong>     252(0)     0     0</p>
<p> -—————————————————————————-</p>
<p>当配置接口地址池时，地址池的名称为接口的名称。分配的网关地址为该接口的IP地址，且无法修改。</p>
<h1 id="中继实验"><a href="#中继实验" class="headerlink" title="中继实验"></a>中继实验</h1><p><img src="/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/dhcpzz111.png" alt="dhcpzz111">交换机4上有多个vlan，交换机1模拟dhcp服务器实现为多个vlan分配地址，交换机3作为dhcp终极连接服务器和客户端</p>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="创建VLAN"><a href="#创建VLAN" class="headerlink" title="创建VLAN"></a>创建VLAN</h3><p>[S1]vlan 40</p>
<p>[S3]vlan batch 10 20 30 40</p>
<p>[S4]vlan batch 10 20 30</p>
<h3 id="配置接口放通相应的VLAN"><a href="#配置接口放通相应的VLAN" class="headerlink" title="配置接口放通相应的VLAN"></a>配置接口放通相应的VLAN</h3><p>[S4]interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>[S4-GigabitEthernet0&#x2F;0&#x2F;3] port link-type trunk</p>
<p>[S4-GigabitEthernet0&#x2F;0&#x2F;3] port trunk allow-pass vlan 10 20 30</p>
<p>[S4-GigabitEthernet0&#x2F;0&#x2F;3] quit</p>
<p>[S3]interface GigabitEthernet0&#x2F;0&#x2F;1</p>
<p>[S3-GigabitEthernet0&#x2F;0&#x2F;1] port link-type access</p>
<p>[S3-GigabitEthernet0&#x2F;0&#x2F;1] port default vlan 40</p>
<p>[S3-GigabitEthernet0&#x2F;0&#x2F;1] quit</p>
<p>[S3]interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>[S3-GigabitEthernet0&#x2F;0&#x2F;3] port link-type trunk</p>
<p>[S3-GigabitEthernet0&#x2F;0&#x2F;3] port trunk allow-pass vlan 10 20 30</p>
<p>[S3-GigabitEthernet0&#x2F;0&#x2F;3] quit</p>
<p>[S1]interface GigabitEthernet0&#x2F;0&#x2F;12</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12] port link-type access</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12] port default vlan 40</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12] quit</p>
<p>交换机4和交换机3之间因为放通多个vlan，所以使用trunk口，交换机3和交换机1之间只有一个vlan40，所以配置access口，pvid&#x3D;40</p>
<h3 id="VLANIF配置"><a href="#VLANIF配置" class="headerlink" title="VLANIF配置"></a>VLANIF配置</h3><p>[S4]interface Vlanif 10</p>
<p>[S4-Vlanif10] quit</p>
<p>[S4]interface Vlanif 20</p>
<p>[S4-Vlanif20] quit</p>
<p>[S4]interface Vlanif 30</p>
<p>[S4-Vlanif30] quit</p>
<p>[S3]interface Vlanif 10</p>
<p>[S3-Vlanif10] ip address 10.0.10.3 24</p>
<p>[S3-Vlanif10] quit</p>
<p>[S3]interface Vlanif 20</p>
<p>[S3-Vlanif20] ip address 10.0.20.3 24</p>
<p>[S3-Vlanif20] quit</p>
<p>[S3]interface Vlanif 30</p>
<p>[S3-Vlanif30] ip address 10.0.30.3 24</p>
<p>[S3-Vlanif30] quit</p>
<p>[S3]interface Vlanif 40</p>
<p>[S3-Vlanif40] ip address 10.0.40.3 24</p>
<p>[S3-Vlanif40] quit</p>
<p>[S1]interface Vlanif 40</p>
<p>[S1-Vlanif40] ip address 10.0.40.1 24</p>
<p>[S1-Vlanif40] quit</p>
<p>检查一下交换机3和1之间的连通性</p>
<p>（开启DHCP服务，配置全局地址池，同时为S4上的VLANIF30分配静态IP地址。）：</p>
<h3 id="开启DHCP服务"><a href="#开启DHCP服务" class="headerlink" title="开启DHCP服务"></a>开启DHCP服务</h3><p>[S1]dhcp enable</p>
<h3 id="创建地址池VLAN10，用于给S4的VLANIF10分配地址"><a href="#创建地址池VLAN10，用于给S4的VLANIF10分配地址" class="headerlink" title="创建地址池VLAN10，用于给S4的VLANIF10分配地址"></a>创建地址池VLAN10，用于给S4的VLANIF10分配地址</h3><p>[S1]ip pool vlan10 &#x2F;&#x2F;创建地址池名为vlan10</p>
<p>[S1-ip-pool-vlan10] gateway-list 10.0.10.3  &#x2F;&#x2F;网关是中继上的vlanif 10</p>
<p>[S1-ip-pool-vlan10] network 10.0.10.0 mask 255.255.255.0 &#x2F;&#x2F;设置分配ip范围是10.0.10.1-10.0.10.255</p>
<p>[S1-ip-pool-vlan10] dns-list 10.0.10.3</p>
<p>[S1-ip-pool-vlan10] quit</p>
<h3 id="创建地址池VLAN20，用于给S4的VLANIF20分配地址"><a href="#创建地址池VLAN20，用于给S4的VLANIF20分配地址" class="headerlink" title="创建地址池VLAN20，用于给S4的VLANIF20分配地址"></a>创建地址池VLAN20，用于给S4的VLANIF20分配地址</h3><p>[S1]ip pool vlan20</p>
<p>[S1-ip-pool-vlan20] gateway-list 10.0.20.3</p>
<p>[S1-ip-pool-vlan20] network 10.0.20.0 mask 255.255.255.0</p>
<p>[S1-ip-pool-vlan20] dns-list 10.0.20.3</p>
<p>[S1-ip-pool-vlan20] quit</p>
<h3 id="创建地址池VLAN30，用于给S4的VLANIF30分配地址"><a href="#创建地址池VLAN30，用于给S4的VLANIF30分配地址" class="headerlink" title="创建地址池VLAN30，用于给S4的VLANIF30分配地址"></a>创建地址池VLAN30，用于给S4的VLANIF30分配地址</h3><p>[S1]ip pool vlan30</p>
<p>[S1-ip-pool-vlan30] gateway-list 10.0.30.3</p>
<p>[S1-ip-pool-vlan30] network 10.0.30.0 mask 255.255.255.0</p>
<p>[S1-ip-pool-vlan30] dns-list 10.0.30.3</p>
<p>[S1-ip-pool-vlan30] quit</p>
<h3 id="查看s4的vlanif30的mac"><a href="#查看s4的vlanif30的mac" class="headerlink" title="查看s4的vlanif30的mac"></a>查看s4的vlanif30的mac</h3><p>为了实现给s4的vlanif30口静态绑定一个指定的ip地址，我们需要先查看一下mac<img src="/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/macsiis30.png" alt="macsiis30"></p>
<h3 id="在S1上为S4的VLANIF30配置静态地址分配"><a href="#在S1上为S4的VLANIF30配置静态地址分配" class="headerlink" title="在S1上为S4的VLANIF30配置静态地址分配"></a>在S1上为S4的VLANIF30配置静态地址分配</h3><p><img src="/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/mac0234.png" alt="mac0234"></p>
<p>给s4的vlanif口静态分配ip：10.0.30.2</p>
<h3 id="在VLANIF40接口下使能DHCP-Server"><a href="#在VLANIF40接口下使能DHCP-Server" class="headerlink" title="在VLANIF40接口下使能DHCP Server"></a>在VLANIF40接口下使能DHCP Server</h3><p>[S1]interface Vlanif 40 </p>
<p>[S1-Vlanif40] dhcp select global &#x2F;&#x2F;全局的使能</p>
<h3 id="查看IP地址池配置情况"><a href="#查看IP地址池配置情况" class="headerlink" title="查看IP地址池配置情况"></a>查看IP地址池配置情况</h3><p>[S1]display ip pool name vlan30</p>
<p><img src="/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/3chakan0.png" alt="3chakan0"></p>
<p>地址池vlan30已经存在一个“Used”地址，该地址为静态分配的地址。</p>
<h3 id="配置前往用户网段的路由"><a href="#配置前往用户网段的路由" class="headerlink" title="配置前往用户网段的路由"></a>配置前往用户网段的路由</h3><p>[S1]ip route-static 10.0.10.0 24 10.0.40.3 </p>
<p>[S1]ip route-static 10.0.20.0 24 10.0.40.3</p>
<p>[S1]ip route-static 10.0.30.0 24 10.0.40.3</p>
<p>（或者配置缺省路由）</p>
<p>保证连通性</p>
<p>在S3上完成DHCP Relay相关配置</p>
<h3 id="开启DHCP服务-1"><a href="#开启DHCP服务-1" class="headerlink" title="开启DHCP服务"></a>开启DHCP服务</h3><p>[S3]dhcp enable</p>
<h3 id="在接口上配置DHCP-Relay，指定DHCP-Server"><a href="#在接口上配置DHCP-Relay，指定DHCP-Server" class="headerlink" title="在接口上配置DHCP Relay，指定DHCP Server"></a>在接口上配置DHCP Relay，指定DHCP Server</h3><p>[S3]interface Vlanif10</p>
<p>[S3-Vlanif10] dhcp select relay</p>
<p>[S3-Vlanif10] dhcp relay server-ip 10.0.40.1</p>
<p>[S3-Vlanif10] quit</p>
<p>[S3]interface Vlanif20</p>
<p>[S3-Vlanif20] dhcp select relay</p>
<p>[S3-Vlanif20] dhcp relay server-ip 10.0.40.1</p>
<p>[S3-Vlanif20] quit</p>
<p>[S3]interface Vlanif30</p>
<p>[S3-Vlanif30] dhcp select relay</p>
<p>[S3-Vlanif30] dhcp relay server-ip 10.0.40.1</p>
<p>[S3-Vlanif30] quit</p>
<h3 id="查看relay配置"><a href="#查看relay配置" class="headerlink" title="查看relay配置"></a>查看relay配置</h3><p><img src="/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/relayallss7.png" alt="relayallss7"></p>
<h3 id="DHCP-Client配置"><a href="#DHCP-Client配置" class="headerlink" title="DHCP Client配置"></a>DHCP Client配置</h3><p>在S4上配置VLANIF10、20、30接口通过DHCP获取IP地址</p>
<h4 id="开启DHCP服务-2"><a href="#开启DHCP服务-2" class="headerlink" title="开启DHCP服务"></a>开启DHCP服务</h4><p>[S4]dhcp enable</p>
<h4 id="开启接口通过DHCP获取地址"><a href="#开启接口通过DHCP获取地址" class="headerlink" title="开启接口通过DHCP获取地址"></a>开启接口通过DHCP获取地址</h4><p>[S4]interface Vlanif10</p>
<p>[S4-Vlanif10] ip address dhcp-alloc</p>
<p>[S4-Vlanif10] quit</p>
<p>[S4]interface Vlanif20</p>
<p>[S4-Vlanif20] ip address dhcp-alloc</p>
<p>[S4-Vlanif20] quit</p>
<p>[S4]interface Vlanif30</p>
<p>[S4-Vlanif30] ip address dhcp-alloc</p>
<p>[S4-Vlanif30] quit</p>
<h4 id="查看各个接口IP地址获取情况"><a href="#查看各个接口IP地址获取情况" class="headerlink" title="查看各个接口IP地址获取情况"></a>查看各个接口IP地址获取情况</h4><p><S4>display interface Vlanif 10</S4></p>
<p>Vlanif10 current state : UP</p>
<p>Line protocol current state : UP</p>
<p>Last line protocol up time : 2020-06-05 17:37:57 UTC-08:00</p>
<p>Description:</p>
<p>Route Port,The Maximum Transmit Unit is 1500</p>
<p>Internet Address is allocated by DHCP, 10.0.10.254&#x2F;24</p>
<p>[S4]display interface Vlanif 20</p>
<p>Vlanif20 current state : UP</p>
<p>Line protocol current state : UP</p>
<p>Last line protocol up time : 2020-06-05 17:41:23 UTC-08:00</p>
<p>Description:</p>
<p>Route Port,The Maximum Transmit Unit is 1500</p>
<p>Internet Address is allocated by DHCP, 10.0.20.254&#x2F;24</p>
<p>[S4]display interface Vlanif 30</p>
<p>Vlanif30 current state : UP</p>
<p>Line protocol current state : UP</p>
<p>Last line protocol up time : 2020-06-05 17:43:22 UTC-08:00</p>
<p>Description:</p>
<p>Route Port,The Maximum Transmit Unit is 1500</p>
<p>Internet Address is allocated by DHCP, 10.0.30.2&#x2F;24</p>
<p>接口已经通过DHCP获取到IP地址，并且VLANIF30的地址为静态分配的地址：10.0.30.2。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>DHCP Relay</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title>FTP实验</title>
    <url>/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="File-Transfer-Protocol-文件传输协议"><a href="#File-Transfer-Protocol-文件传输协议" class="headerlink" title="File Transfer Protocol 文件传输协议"></a>File Transfer Protocol 文件传输协议</h1><p>FTP服务器开启21号端口进行控制连接，20号端口与客户端建立数据连接</p>
<p>ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言，它是最通用的信息交换标准。</p>
<p>FTP是用来传送文件的协议。使用FTP实现远程文件传输的同时，还可以保证数据传输的可靠性和高效性。</p>
<p>FTP 是基于客户———服务器（C&#x2F;S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接</p>
<h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><p>FTP支持两种方式的传输：文本（ASCII）方式和二进制（Binary）方式。通常文本文件的传输采用ASCII方式，而图象、声音文件、加密和压缩文件等非文本文件采用二进制方式传输，如果为了从一个系统上传输文件而使用了与本地系统不同的计算机字节位数，那么就必须使用Tenex模式。FTP以ASCII方式作为缺省的文件传输方式。</p>
<h2 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h2><p> 使用FTP进行文件传输时，会使用两个TCP连接。第一个连接是FTP客户端和FTP服务器间的控制连接。FTP服务器开启21号端口，等待FTP客户端发送连接请求。FTP客户端随机开启端口，向服务器发送建立连接的请求。控制连接用于在服务器和客户端之间传输控制命令。<br>        第二个连接是FTP客户端和FTP服务器间的数据连接。服务器使用TCP的20号端口与客户端建立数据连接。通常情况下，服务器主动建立或中断数据连接。</p>
<h2 id="FTP服务器配置"><a href="#FTP服务器配置" class="headerlink" title="FTP服务器配置"></a>FTP服务器配置</h2><p>路由器和X7系列交换机均可提供FTP功能。<br>执行ftp server enable命令使能FTP功能。<br>执行set default ftp-directory命令设置FTP用户的默认工作目录。</p>
<p>在配置FTP服务器时，可以使用AAA为每个用户分别配置登录账号和访问权限。 aaa命令用来进入AAA视图。</p>
<p>  local-user user-name { access-limit max-number | ftp-directory directory | idle-timeout         minutes [ seconds ] | password cipher password [ opt ]         | privilege level level | state {active | block } } *命令用来创建本地用户，并配置本地用户的各项参数。</p>
<pre><code>  user-name指定用户名。
    local-user huawei service-type ftp命令用来配置本地用户的接入类型为ftp。
    ftp-directory指定FTP用户可访问的目录。如果不配置FTP用户可访问的目录，则FTP用户无法登录设备。
    access-limit指定用户名可建立的最大连接数目。
    idle-timeout指定用户的闲置超时时间。
    privilege level指定用户的优先级。
</code></pre>
<h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="idle-timeout"><a href="#idle-timeout" class="headerlink" title="idle-timeout"></a>idle-timeout</h3><p><strong>idle-timeout</strong>命令用来设置用户连接的超时时间。</p>
<p><strong>undo idle-timeout</strong>命令用来恢复超时时间的缺省值。</p>
<p>缺省情况下，用户连接的超时时间是5分钟。</p>
<p>命令格式</p>
<p><strong>idle-timeout</strong> <em>minutes</em> [ <em>seconds</em> ]</p>
<p><strong>undo idle-timeout</strong></p>
<table>
<thead>
<tr>
<th align="left"><em>minutes</em></th>
<th>指定用户界面断连的超时时间的分钟数。</th>
<th>整数形式，取值范围是0～35791，单位是分钟。</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>seconds</em></td>
<td>指定用户界面断连的超时时间的秒数。</td>
<td>整数形式，取值范围是0～59，单位是秒</td>
</tr>
</tbody></table>
<p>缺省级别</p>
<p>3：管理级</p>
<ul>
<li>设置执行命令<strong>idle-timeout</strong> <strong>0 0</strong>即关闭用户界面的超时断连功能。</li>
<li>如果用户界面没有设置闲置断连功能，则会导致已登录的用户始终处于连接状态，给设备带来安全风险，同时还有可能导致其他用户无法获得连接。</li>
<li>通常情况下，推荐设置用户界面断连的超时时间在10～15分钟之间。</li>
</ul>
<p># 设置超时为1分钟30秒。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idle-timeout 1 30</span><br></pre></td></tr></table></figure>



<h3 id="local-user-privilege-level"><a href="#local-user-privilege-level" class="headerlink" title="local-user privilege level"></a>local-user privilege level</h3><p>必须配置在3以上，否则ftp连接无法成功</p>
<p><strong>local-user privilege level</strong>命令用来配置本地用户的优先级。</p>
<p><strong>undo</strong> <strong>local-user privilege level</strong>命令用来将本地用户的优先级恢复为缺省配置。</p>
<p>缺省情况下，本地用户（如Telnet用户、SSH用户）的优先级由管理模块来决定。</p>
<p>命令格式</p>
<p><strong>local-user</strong> <em>user-name</em> <strong>privilege level</strong> <em>level</em></p>
<p><strong>undo local-user</strong> <em>user-name</em> <strong>privilege level</strong></p>
<table>
<thead>
<tr>
<th><em>user-name</em></th>
<th>用户名。</th>
<th>字符串形式，不支持空格，不区分大小写，长度范围是1~64。</th>
</tr>
</thead>
<tbody><tr>
<td><em>level</em></td>
<td>用户的优先级。</td>
<td>整数形式，取值范围是0~15，取值越大，用户的优先级越高。缺省级别是0级。不同级别的用户登录后，只能使用等于或低于自己级别的命令</td>
</tr>
</tbody></table>
<p>缺省情况下，命令级别分为0~3级：</p>
<ul>
<li>级别0即参观级，网络诊断工具命令（ping、tracert）、从本设备出发访问外部设备的命令（包括：Telnet 客户端、SSH）等。该级别命令不允许进行配置文件保存的操作。</li>
<li>级别1即监控级，用于系统维护，包括display命令。该级别命令不允许进行配置文件保存的操作。</li>
<li>级别2即配置级，可以使用业务配置命令，包括路由、各个网络层次的命令，向用户提供直接网络服务。</li>
<li>级别3即管理级，用于系统基本运行的命令，对业务提供支撑作用，包括文件系统、FTP、TFTP、配置文件切换命令、备板控制命令、用户管理命令、命令级别设置命令、系统内部参数设置命令；用于业务故障诊断的debugging命令。</li>
</ul>
<h3 id="access-limit"><a href="#access-limit" class="headerlink" title="access-limit"></a>access-limit</h3><p><strong>access-limit</strong>命令用来配置当前域允许接入的用户数。</p>
<p><strong>undo access-limit</strong>命令用来恢复缺省配置。</p>
<p>缺省情况下，不限制接入的用户数目。</p>
<p>命令格式</p>
<p><strong>access-limit</strong> <em>max-number</em></p>
<p><strong>undo access-limit</strong></p>
<table>
<thead>
<tr>
<th><em>max-number</em></th>
<th>指定允许接入的用户数。</th>
<th>整数形式，取值范围是0～283648。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>为了更方便地管理用户访问设备，可以限制域下用户的在线数量。</p>
<p><strong>注意事项</strong></p>
<p>执行这条配置命令后，当接入用户数大于允许的用户数时，系统不再允许用户接入系统，提示用户认证失败。</p>
<p><strong>access-limit</strong>命令对一个域下所能接入的用户总数进行限制，不区分接入用户的类型。</p>
<p># 设置当前域最多允许接入100个用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access-limit 100</span><br></pre></td></tr></table></figure>



<h3 id="local-user-ftp-directory"><a href="#local-user-ftp-directory" class="headerlink" title="local-user ftp-directory"></a>local-user ftp-directory</h3><p><strong>local-user ftp-directory</strong>命令用来配置本地用户的FTP目录。</p>
<p><strong>undo local-user ftp-directory</strong>命令用来将本地用户的FTP目录恢复为缺省配置。</p>
<p>缺省情况下，本地用户的FTP目录为空。</p>
<p>当需要将设备配置为FTP服务器，从而便于本地用户以FTP方式登录设备，对设备上的文件进行增加、删除、修改等操作时，可以通过本命令配置本地用户以FTP方式登录设备后所处的目录。</p>
<p>不指定该目录时，本地用户无法以FTP方式登录设备。</p>
<p>配置本地用户的FTP目录时，该用户必须已由local-user password命令建立。</p>
<h3 id="local-user-password"><a href="#local-user-password" class="headerlink" title="local-user password"></a>local-user password</h3><p><strong>local-user password</strong>命令用来创建一个本地用户并配置该用户的登录密码，或者修改已创建用户的登录密码。</p>
<p><strong>undo local-user</strong>命令用来删除一个本地用户。</p>
<p>缺省情况下，系统没有本地用户。</p>
<p><strong>local-user</strong> <em>user-name</em> <strong>password</strong> [ <strong>cipher</strong> <em>password</em> | <strong>irreversible-cipher</strong> <em>irreversible-cipher-password</em> ]</p>
<p><strong>undo local-user</strong> <em>user-name</em></p>
<p><strong>cipher</strong> <em>password</em></p>
<p>指定密文密钥。密钥以明文或密文形式输入，但配置文件中保存为密文形式。</p>
<p><strong>irreversible-cipher</strong> <em>irreversible-cipher-password</em></p>
<p>指定不可逆密文密钥。密钥以明文或不可逆密文形式输入，但配置文件中保存为密文形式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.FTP服务器需要开启TCP的21号端口来建立控制连接，20号端口来建立数据连接。</p>
<p>2.如果用户无权访问任何工作目录，则需要定义一个默认的FTP目录。执行set default ftp-directory <directory location>命令建立默认目录。</directory></p>
<h2 id="FTP实验"><a href="#FTP实验" class="headerlink" title="FTP实验"></a>FTP实验</h2><p>R1 做为FTP Server 进行配置<br>R2 做为Client 测试</p>
<p>R1：<br>undo ter mo<br>sys<br>sysname R1<br>int g0&#x2F;0&#x2F;0<br>ip add 192.168.1.1 24</p>
<p>R2：<br>undo ter mo<br>sys<br>sysname R2<br>int g0&#x2F;0&#x2F;0<br>ip add 192.168.1.2 24</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/ftp1130183749.png" alt="ftp1130183749"></p>
<p>R1:<br>ftp server enable<br>set default ftp-directory flash:&#x2F;</p>
<p>（设置默认目录为flash:&#x2F;）</p>
<p><strong>ftp server enable</strong>命令用来开启设备的FTP服务器功能，允许FTP用户登录。缺省情况下，FTP服务器功能处于关闭状态。</p>
<p>其他可选的配置参数还包括：指定FTP服务器端口号、指定FTP服务器的源地址和配置FTP连接空闲时间等。</p>
<p>R1：</p>
<p>通过在AAA中设置用户名和密码（均为huawei）<br>aaa<br>local-user huawei password cipher huawei<br>local-user huawei service-type ftp<br>local-user huawei ftp-directory flash:&#x2F;<br>local-user huawei access-limit 200<br>local-user huawei idle-timeout 0 0<br>local-user huawei privilege level 3</p>
<p>查看ftp server配置信息</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/diskvk30184121.png" alt="diskvk30184121"></p>
<p>R2登录FTP服务器</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/ftpdenglu1130184259.png" alt="ftpdenglu1130184259"></p>
<p>在R1和R2上分别保存文件text1.cfg和text2.cfg，用于后续测试</p>
<p>R1：save text1.cfg</p>
<p>R2：save text2.cfg</p>
<p>R2上通过dir命令查看服务器上的文件</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/dirr2184558.png" alt="dirr2184558"></p>
<p>R2从服务器上下载text1.cfg文件，并改名为newtext1.cfg</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/xiazaigaiming0184834.png" alt="xiazaigaiming0184834"></p>
<p>R2本地查看dir</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/r2bendichakan30184952.png" alt="r2bendichakan30184952"></p>
<p>put把本地文件text2.cfg上传到服务器，并改名为newtext2.cfg</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/putnew85130.png" alt="putnew85130"></p>
<p>查看是否上传成功</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/yanzg5227.png" alt="yanzg5227"></p>
<p>关闭ftp连接：bye</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hybrid接口</title>
    <url>/2023/12/05/Hybrid%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="接口属性"><a href="#接口属性" class="headerlink" title="接口属性"></a>接口属性</h1><p>​	交换机接口的类型，可以是Access、Trunk和Hybrid。Access类型的接口仅属于一个VLAN,,,,只能接收、转发相应VLAN的帧；而Trunk类型接口则默认属于所有VLAN任何Tagged帧都能经过Trunk接收和转发； Hybrid类型接口则介于二者之间，可自主定义端口上能接收和转发那些VLAN Tag帧，并可决定VLAN Tag是否继续携带或者剥离。。Access和Trunk类型接口是Hybrid类型接口的两个特例，，，一个仅支持一个VLAN传递，，一个默认支持所有VLAN的传递，而Access类型和Trunk类型的接口能做到的，Hybrid接口都能做到。</p>
<p>​    hybrid属性具有trunk和access两种端口属性的特点，tag类似trunk，untag类似access，但是又不同，因为hybrid端口可以接收某个或者多个vlan的数据。</p>
<p>在开始研究之前强调几点：</p>
<p>1、在hybrid端口中，所有端口都默认属于vlan1，除非配置undo port hybrid vlan 1 才能将该hybrid剔除出vlan1，可以使用display vlan 查看端口所属的vlan</p>
<p>2、在hybrid端口中，无论是tag还是untag后面配置的vlan-id就是该hybrid端口所能够收到vlan数据的vlan-id，换句话说就是这些vlan中发出的数据该端口都能收到，可以使用display vlan查看（这里注意虽然可以收到这些vlan的数据但是严格意义上讲hybrid端口并不属于任何一个vlan）</p>
<p>3、所有类型端口的默认pvid都是vlan1，而pvid这个属性只！针对！进入！该端口的！没有标签的！普通数据包有效，作用是将没有标签的普通数据包打上pvid中配置的标签号</p>
<p>4、hybrid属性中，tag是针对于端口的接收方向的（从该端口进来的流量允许带有这些vlan标签的通过），untag是针对端口的发送方向的（从该端口出去的流量去除这些vlan标签）</p>
<p>5、加入一个hybrid端口配置tag vlan 2 3和untag vlan 4 5 ，那么默认情况下这个hybrid属于vlan1、2、3、4、5，在display vlan中可以查看到，只有端口属于了某个vlan，那么该端口才能收到某个vlan的数据包，这一点是理解下列两种配置和hybrid端口属性的关键！！！</p>
<h1 id="收发过程"><a href="#收发过程" class="headerlink" title="收发过程"></a>收发过程</h1><p>在数据发送时untag列表的原理，如下图<br>1.带有vlan 3标签的数据从F0&#x2F;0接口出去，通过时查看untag列表，发现有对应的标签，将标签脱掉发送出去<br>2.带有vlan 8标签的数据从F0&#x2F;1接口出去，通过时查看untag列表，发现没有对应的标签，继续查看tag表，发现有对应标签，所以直接带有vlan 8标签的数据发送出去<br>3.带有vlan 5标签的数据从F0&#x2F;2接口出去，通过时查看untag列表，发现没有对应的标签 ，继续查看tag列表，发现也没有对应的标签，所以数据直接被丢弃<br><img src="/2023/12/05/Hybrid%E6%8E%A5%E5%8F%A3/shoufa6505133622.png" alt="shoufa6505133622"></p>
<p>tag列表处理数据帧的接收和发送的原理，如下图<br>1.没有标签的数据进入F0&#x2F;0接口，接口查看到数据没有标签，根据接口PVID&#x3D;3，将vlan 3标签打入数据<br>2.带有vlan 9标签的数据进入接口F0&#x2F;1，接口查看到数据带有标签，接着查看tag列表，发现列表中存在对应标签，放通数据<br>3.带有vlan 5标签的数据从接口F0&#x2F;2出去，接口查看到数据带有标签，查看untag列表，发现列表中没有对应vlan 5标签，继续查看tag列表，发现列表中存在对应标签vlan 5，放通数据出去<br>4.带有vlan 3标签的数据从F0&#x2F;2接口出去，查看untag列表，发现列表中存在对应vlan 3标签，将标签脱掉，放通数据出去<br>5.带有vlan 9标签的数据从F0&#x2F;2接口出去，查看untag表，发现列表中不存在对应vlan 9标签，继续查看tag列表，发现列表中不存在vlan 9标签，将数据丢弃</p>
<p><img src="/2023/12/05/Hybrid%E6%8E%A5%E5%8F%A3/fataf2133722.png" alt="fataf2133722"></p>
<h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p><img src="/2023/12/05/Hybrid%E6%8E%A5%E5%8F%A3/tuo2205133307.png" alt="tuo2205133307"></p>
<p>1、为了让我们更加简洁的理解hydrid的属性，首先在所有的端口上移除了vlan1这个默认有的vlan，假设为所有端口初始不属于任何vlan，都不能相互之间通信</p>
<p>2、pvid是当普通的主机数据帧进入交换机端口后被打上的vlan-tag的属性，在途中可以看出PC1、PC2、PC3的流量在进入交换机的时候分别会被打上vlan2、vlan3、vlan99的vlan标签</p>
<p>3、untag后面的vlan就是该端口属于的vlan，那么不难看出LSW1的G0&#x2F;0&#x2F;1属于vlan2、3，G0&#x2F;0&#x2F;2属于vlan2、10，G0&#x2F;0&#x2F;3属于vlan3、10，而untag的动作是在流量出端口去往主机的时候把vlan-tag全部去除，那么不难看出LSW1的G0&#x2F;0&#x2F;1将去除vlan2、3的标签，G0&#x2F;0&#x2F;2去除vlan2、10的标签，G0&#x2F;0&#x2F;3去除vlan3、10的标签（还原成普通帧）</p>
<p>LSW2的G0&#x2F;0&#x2F;1属于vlan99，G0&#x2F;0&#x2F;2属于vlan99，在流量出端口的时候会去除vlan99的标签（还原成普通帧）</p>
<p>那么PC1与PC2的通信现在分析如下：当PC1发送arp去请求PC2的MAC地址的时候，PC1会将数据包广播发往LSW1的G0&#x2F;0&#x2F;2接口，LSW1收到后发现是个普通的不带标签的数据帧，于是根据接口的pvid给该帧打上vlan2的tag，然后往vlan2中进行泛红，无奈G0&#x2F;0&#x2F;3端口只属于vlan3、10所以无法收到vlan2中的泛红，故PC1与PC2通信失败。</p>
<p>下面再来分析PC1与PC3通信：前面已经分析了PC1要去请求PC3的MAC，被LSW1的G0&#x2F;0&#x2F;2收到，并且打上vlan2的tag，然后在vlan2中泛红，那么在vlan2中的端口就都能收到该泛红了，所以在配置了untag vlan 2 3的G0&#x2F;0&#x2F;1端口自然也能收到vlan2和vlan3的泛红并转发出去，但是LSW1发现G0&#x2F;0&#x2F;1配置untag vlan2 3，所以将从该端口发送出去的所有带有vlan2和vlan3的数据包的tag全部去除（还原成普通帧），然后这个普通的帧就会发往LSW2被G0&#x2F;0&#x2F;1端口接收到，LSW2发现了一个普通的帧，那么就会用到pvid了不是，所以LSW2收到这个帧后打上vlan99的tag进行泛红，那么PC3所在的hybrid因为配置有untag vlan99必然能够收到vlan99的数据包了，然后在G0&#x2F;0&#x2F;2发给PC3的时候将vlan99的tag去除掉，PC3收到的就是一个不带任何tag的普通包（PC3完全不知道在它个PC1之间还有SW这种东西存在），好了PC3收到了PC1发来的arp请求，那么作为有礼貌的人应该回复自己的MAC地址了，与回一个arp响应给PC1，</p>
<p>下面PC3的回包分析：PC3使用PC1的MAC和ip封装好数据包后从网卡发送出去，LSW2的G0&#x2F;0&#x2F;2端口收到了，发现是一个普通帧，OK来pvid打上vlan99的tag，然后查看mac地址表发现PC1的MAC地址在G0&#x2F;0&#x2F;1口，在查看vlan信息，发现G0&#x2F;0&#x2F;1口可以接收vlan99的数据（untag vlan99），两个转发条件都满足了，那么久把数据包发给G0&#x2F;0&#x2F;1转发，G0&#x2F;0&#x2F;1转发的时候根据untag vlan99把数据包vlan-id去除还原成普通帧，被LSW1的G0&#x2F;0&#x2F;1收到，按照pvid的惯例，普通帧被打上了pvid vlan10的tag（用vlan10举例，也可以是任意vlan），然后LSW1根据MAC地址表找到PC1在自己的G0&#x2F;0&#x2F;2口，再查看vlan信息发现G0&#x2F;0&#x2F;2接口配置了untag vlan2 10，可以接收vlan10的数据包，于是就把这个被打上vlan10的PC3发来的arp响应通过G0&#x2F;0&#x2F;2发送给了PC1，当然在从G0&#x2F;0&#x2F;2接口出去的时候根据untag vlan2 10的配置将vlan10的tag去除还原成一个普通的帧，PC1收到的是一个普通的帧，完全不知道它和PC3之间还有交换机这个东西。好了，这就是一次通信过程，PC2与PC3的通信原理也是一样的，于是就实现了PC3与PC1、PC2互通，PC1与PC2之间不通的效果。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>hybrid</tag>
        <tag>tag</tag>
      </tags>
  </entry>
  <entry>
    <title>IA综合实验</title>
    <url>/2024/06/21/IA%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<img src="/2024/06/21/IA%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/QQ截图20240621210447.png" alt="QQ截图20240621210447" style="zoom:80%;">

<p>如图所示为某园区网络简易拓扑，LSW1,LSW2作为汇聚层交换机，AR1作为核心路由器，LSW3-4作为<br>各自楼层的接入交换机，现按照要求实现如下配置：</p>
<p>一.IP地址规划<br>   1.办公楼1所有PC的网段为：192.168.10.0&#x2F;24  网关地址为：192.168.10.254<br>   2.办公楼2所有PC的网段为：192.168.20.0&#x2F;24  网关地址为：192.168.20.254<br>   3.服务器区所有PC的网段为：192.168.30.0&#x2F;24  网关地址为：192.168.30.254<br>   4.LSW1作为汇聚层交换机使用INT VLANIF 100接口与R1互连，IP地址为100.1.1.1&#x2F;24；<br>     R1与LSW1互连接口的IP地址为100.1.1.2&#x2F;24<br>   5.R1与R2接口,R1接口IP地址为：200.1.1.1&#x2F;24,R2接口IP地址为：200.1.1.2&#x2F;24,<br>   6.配置设备的名称</p>
<p>二.配置LSW1与LSW2汇聚交换机之间的链路聚合，采用LACP的方式，活动链路2条<br>   要求G0&#x2F;0&#x2F;3端口down掉之后，数据走G0&#x2F;0&#x2F;2转发。</p>
<p>三.配置交换机之间的生成树<br>    1.要求所有运行RSTP<br>    2.LSW1作为主根桥，LSW2作为备份根桥<br>    3.配置边缘端口，让所有的终端接入到网络中，能立即转发数据<br>四.配置交换机的链路类型以及VLAN<br>    1.在交换机上创建拓扑图中所存在的VLAN<br>    2.配置交换机与PC与路由器的链路类型为access链路，然后将接口划分进相应的VLAN；<br>      办公楼1为VLAN 10<br>      办公楼2为VLAN 20<br>      服务器区为VLAN 30<br>      LSW1与连接R1的接口VLAN 100<br>    3.配置交换机与交换机互连的链路的trunk，并且允许相应的VLAN通过</p>
<p>五.在汇聚交换机LSW1配置相应的VLANIF接口，使不同楼层的PC能实现通讯</p>
<p>六.DHCP配置:<br>     在LSW1上配置全局地址池1：<br>     地址池pool10分配地址段为192.168.10.0&#x2F;24,网关为192.168.10.254,DNS为114.114.114.114，<br>        为VLAN10的主机分配IP地址；<br>     在LSW2上配置全局地址池2：<br>     地址池pool20分配地址段为192.168.20.0&#x2F;24,网关为192.168.20.254,DNS为8.8.8.8<br>        为VLAN20的主机分配IP地址。<br>七.路由协议<br>1.在核心路由器AR1和汇聚交换机LSW1上配置动态路由协议ospf，使R1能学到教学楼和服务器区网段的路由<br> 配置完成之后，测试R1是否访问到每台PC上<br>2.在核心路由器AR1配置一跳静态默认路由指向ISP的路由器AR2</p>
<p>八.NAT技术<br>   1、在AR1上使用NAT技术，使内网VLAN10，VLAN20的网段访问外网时，转化的地址为AR1 g0&#x2F;0&#x2F;1接口的IP地址。<br>     （通过easy ip技术实现）</p>
<p><strong>LSW3-1</strong></p>
<p><Huawei>sys</Huawei></p>
<p>[Huawei]sysn lsw3-1</p>
<p>[lsw3-1]v b 10 20</p>
<p>Info: This operation may take a few seconds. Please wait for a</p>
<p>moment…done.</p>
<p>[lsw3-1]int e0&#x2F;0&#x2F;3</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;3]p l a</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;3]p d v 10</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;3]int e0&#x2F;0&#x2F;4</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;4]p l a[lsw3-1-Ethernet0&#x2F;0&#x2F;4]p d v 10</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;4]int e0&#x2F;0&#x2F;1</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;1]p l t</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;1]p t a v 10 20</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;1]int e0&#x2F;0&#x2F;2</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;2]p l t</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;2]p t a v 10 20</p>
<p>[lsw3-1]stp mode r</p>
<p>[lsw3-1]int e0&#x2F;0&#x2F;3</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;3]stp edged-port enable &#x2F;&#x2F;设置边缘端口便于快速收</p>
<p>敛</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;3]int e0&#x2F;0&#x2F;4</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;4]stp edged-port enable</p>
<p><strong>LSW4</strong></p>
<p><Huawei>sys</Huawei></p>
<p>Enter system view, return user view with Ctrl+Z.</p>
<p>[Huawei]sysn LSW4-1</p>
<p>[LSW4-1]v b 20</p>
<p>[LSW4-1]int e0&#x2F;0&#x2F;4</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;4]p l a</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;4]p d v 20</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;4]int e0&#x2F;0&#x2F;5</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;5]p l a</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;5]p d v 20</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;5]int e0&#x2F;0&#x2F;1</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;1]p l t</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;1]p t a v 10 20</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;1]int e0&#x2F;0&#x2F;2</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;2]p l t</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;2]p t a v 10 20</p>
<p>[LSW4-1]stp mode r</p>
<p>[LSW4-1]int e0&#x2F;0&#x2F;4</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;4]stp edged-port enable</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;4]int e0&#x2F;0&#x2F;5[LSW4-1-Ethernet0&#x2F;0&#x2F;5]stp ed e</p>
<p>[LSW4-1]int e0&#x2F;0&#x2F;1</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;1]stp cost 300000 &#x2F;&#x2F;修改端口cost来使到达网关最优</p>
<p><strong>LSW1</strong></p>
<p>[LSW1]v b 10 20 12 100 30</p>
<p>[LSW1]int g0&#x2F;0&#x2F;4</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;4]p l t</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;4]p t a v 10 20</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;4]int g0&#x2F;0&#x2F;5</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;5]p l t</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;5]p t a v 10 20</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;5]q</p>
<p>[LSW1]int Eth-Trunk 1</p>
<p>[LSW1-Eth-Trunk1]mode lacp-static</p>
<p>[LSW1-Eth-Trunk1]max active-linknumber 2 &#x2F;&#x2F;设置聚合最大数量为2</p>
<p>[LSW1-Eth-Trunk1]trunkport g 0&#x2F;0&#x2F;1 0&#x2F;0&#x2F;2 0&#x2F;0&#x2F;3</p>
<p>[LSW1-Eth-Trunk1]p l t</p>
<p>[LSW1-Eth-Trunk1]p t a v 10 20 30 12</p>
<p>[LSW1-Eth-Trunk1]shutdown</p>
<p>[LSW1-Eth-Trunk1]undo shutdown</p>
<p>[LSW1-Eth-Trunk1]q</p>
<p>[LSW1]int g0&#x2F;0&#x2F;6</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;6]p l a</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;6]p d v 100</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;6]int g0&#x2F;0&#x2F;7</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;7]p l a</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;7]p d v 30</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;7]int g0&#x2F;0&#x2F;8</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;8]p l a</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;8]p d v 30</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;8]q</p>
<p>[LSW1]stp mode rstp</p>
<p>[LSW1]stp root primary</p>
<p>[LSW1]int g0&#x2F;0&#x2F;7[LSW1-GigabitEthernet0&#x2F;0&#x2F;7]stp ed e</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;7]int g0&#x2F;0&#x2F;8</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;8]stp ed e</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;8]q</p>
<p>[LSW1]int v 10</p>
<p>[LSW1-Vlanif10]ip add 192.168.10.254 24</p>
<p>[LSW1-Vlanif10]int v 12</p>
<p>[LSW1-Vlanif12]ip add 10.0.12.1 24</p>
<p>[LSW1-Vlanif12]int v 100</p>
<p>[LSW1-Vlanif100]ip add 100.1.1.1 24</p>
<p>[LSW1-Vlanif100]int v 30</p>
<p>[LSW1-Vlanif30]ip add 192.168.30.254 24</p>
<p>[LSW1-Vlanif30]q</p>
<p>[LSW1]ip pool vlan10</p>
<p>[LSW1-ip-pool-vlan10]network 192.168.10.0 mask 24</p>
<p>[LSW1-ip-pool-vlan10]gateway-list 192.168.10.254</p>
<p>[LSW1-ip-pool-vlan10]dns-list 8.8.8.8</p>
<p>[LSW1-ip-pool-vlan10]q</p>
<p>[LSW1]ip pool vlan30</p>
<p>[LSW1-ip-pool-vlan30]network 192.168.30.0 m 24</p>
<p>[LSW1-ip-pool-vlan30]g 192.168.30.254</p>
<p>[LSW1-ip-pool-vlan30]dns 114.114.114.114</p>
<p>[LSW1-ip-pool-vlan30]q</p>
<p>[LSW1]dhcp enable</p>
<p>[LSW1]int v 10</p>
<p>[LSW1-Vlanif10]dhcp se g</p>
<p>[LSW1-Vlanif10]int v 30</p>
<p>[LSW1-Vlanif30]dhcp s g</p>
<p>[LSW1]ospf</p>
<p>[LSW1-ospf-1]area 0</p>
<p>[LSW1-ospf-1-area-0.0.0.0]network 10.0.12.0 0.0.0.255</p>
<p>[LSW1-ospf-1-area-0.0.0.0]network 100.1.1.1 0.0.0.255</p>
<p>[LSW1-ospf-1-area-0.0.0.0]network 192.168.10.0 0.0.0.255</p>
<p>[LSW1-ospf-1-area-0.0.0.0]network 192.168.30.0 0.0.0.255</p>
<p>[LSW1-ospf-1-area-0.0.0.0]network 192.168.20.0 0.0.0.255<strong>LSW2</strong></p>
<p><Huawei>sys</Huawei></p>
<p>Enter system view, return user view with Ctrl+Z.</p>
<p>[Huawei]v b 12 10 20 40</p>
<p>[Huawei]sysn LSW2</p>
<p>[LSW2]int g0&#x2F;0&#x2F;4</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;4]p l t</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;4]p t a v 10 20</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;4]int g0&#x2F;0&#x2F;5</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;5]p l t</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;5]p t a v 10 20</p>
<p>[LSW2]int Eth-Trunk 1</p>
<p>[LSW2-Eth-Trunk1]mode lacp-static</p>
<p>[LSW2-Eth-Trunk1]max active-linknumber 2</p>
<p>[LSW2-Eth-Trunk1]trunkport g 0&#x2F;0&#x2F;1 0&#x2F;0&#x2F;2 0&#x2F;0&#x2F;3</p>
<p>[LSW2-Eth-Trunk1]q</p>
<p>[LSW2]int g0&#x2F;0&#x2F;2</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;2]lacp priority 32769 &#x2F;&#x2F;设置该端口在聚合时</p>
<p>为备份</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;2]int e 1</p>
<p>[LSW2-Eth-Trunk1]shutdown</p>
<p>[LSW2-Eth-Trunk1]undo shutdown &#x2F;&#x2F;非抢占 所以需要重启</p>
<p>[LSW2-Eth-Trunk1]p l t</p>
<p>[LSW2-Eth-Trunk1]p t a v 12 10 20</p>
<p>[LSW2-Eth-Trunk1]q</p>
<p>[LSW2]stp mode rs</p>
<p>[LSW2]stp root secondary</p>
<p>[LSW2]ip pool vlan20</p>
<p>[LSW2-ip-pool-vlan20]network 192.168.20.0 m 24</p>
<p>[LSW2-ip-pool-vlan20]g 192.168.20.254</p>
<p>[LSW2-ip-pool-vlan20]q</p>
<p>[LSW2]dhcp enable</p>
<p>[LSW2]int v 20</p>
<p>[LSW2-Vlanif20]ip add 192.168.20.254 24</p>
<p>[LSW2-Vlanif20]q[LSW2-Vlanif20]dhcp se g</p>
<p>[LSW2-Vlanif20]int v 12</p>
<p>[LSW2-Vlanif12]ip add 10.0.12.2 24</p>
<p>[LSW2-Vlanif12]q</p>
<p>-–</p>
<p>接下来为ac这部分配置</p>
<p>[LSW2]int g0&#x2F;0&#x2F;7</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;7]p l t</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;7]p t a v 40 50</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;7]int g0&#x2F;0&#x2F;6</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;6]p l t</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;6]p t a v 40 50 10 20 12</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;6]p t p v 40</p>
<p>[LSW2]ospf</p>
<p>[LSW2-ospf-1]area 0</p>
<p>[LSW2-ospf-1-area-0.0.0.0]network 192.168.20.0 0.0.0.255</p>
<p>[LSW2-ospf-1-area-0.0.0.0]network 10.0.12.0 0.0.0.255</p>
<p><strong>AC</strong></p>
<p><AC6005>sys</AC6005></p>
<p>Enter system view, return user view with Ctrl+Z.</p>
<p>[AC6005]sysn AC</p>
<p>[AC]int g0&#x2F;0&#x2F;1</p>
<p>[AC-GigabitEthernet0&#x2F;0&#x2F;1]q</p>
<p>[AC]v b 40 50</p>
<p>[AC]int g0&#x2F;0&#x2F;1</p>
<p>[AC-GigabitEthernet0&#x2F;0&#x2F;1]p l t</p>
<p>[AC-GigabitEthernet0&#x2F;0&#x2F;1]p t a v 40 50</p>
<p>[AC-GigabitEthernet0&#x2F;0&#x2F;1]q</p>
<p>[AC]int v 40</p>
<p>[AC-Vlanif40]ip add 192.168.40.254 24</p>
<p>[AC-ip-pool-vlan40]int v 50</p>
<p>[AC-Vlanif50]ip add 192.168.50.254 24</p>
<p>[AC-Vlanif50]int v 1</p>
<p>[AC-Vlanif1]ip add 10.0.11.2 24 &#x2F;&#x2F; 与ar1 通信[AC-Vlanif1]q</p>
<p>[AC]ip pool vlan40</p>
<p>[AC-ip-pool-vlan40]network 192.168.40.0 m 24</p>
<p>[AC-ip-pool-vlan40]g 192.168.40.254</p>
<p>[AC-ip-pool-vlan40]q</p>
<p>[AC]ip pool vlan50</p>
<p>[AC-ip-pool-vlan50]network 192.168.50.0 m 24</p>
<p>[AC-ip-pool-vlan50]g 192.168.50.254</p>
<p>[AC-ip-pool-vlan50]q</p>
<p>[AC-wlan-view]int v 40</p>
<p>[AC-Vlanif40]dhcp select g</p>
<p>[AC-Vlanif40]int v 50</p>
<p>[AC-Vlanif50]dhcp select global</p>
<p>[AC]capwap source interface Vlanif 40</p>
<p>[AC]wlan</p>
<p>[AC-wlan-view]ssid-profile name HCIA-WLAN</p>
<p>[AC-wlan-ssid-prof-HCIA-WLAN]ssid HCIA-WLAN</p>
<p>[AC-wlan-ssid-prof-HCIA-WLAN]q</p>
<p>[AC-wlan-view]security-profile name HCIA-WLAN</p>
<p>[AC-wlan-sec-prof-HCIA-WLAN]security wpa-wpa2 psk pass-phrase HCIA</p>
<p>Datacom aes</p>
<p>[AC-wlan-sec-prof-HCIA-WLAN]q</p>
<p>[AC-wlan-view]vap-profile name HCIA-WLAN</p>
<p>[AC-wlan-vap-prof-HCIA-WLAN]ssid-profile HCIA-WLAN</p>
<p>[AC-wlan-vap-prof-HCIA-WLAN]security-profile HCIA-WLAN</p>
<p>[AC-wlan-vap-prof-HCIA-WLAN]service-vlan vlan-id 50</p>
<p>[AC-wlan-vap-prof-HCIA-WLAN]forward-mode direct-forward</p>
<p>[AC-wlan-view]ap-group name ap-group1</p>
<p>[AC-wlan-ap-group-ap-group1]vap-profile HCIA-WLAN wlan 1 radio all</p>
<p>[AC-wlan-ap-group-ap-group1]q</p>
<p>[AC-wlan-view]ap-id 1 ap-mac 00E0-FC27-2F80</p>
<p>[AC-wlan-ap-1]ap-group ap-group1</p>
<p>[AC]ospf</p>
<p>[AC-ospf-1]area 0</p>
<p>[AC-ospf-1-area-0.0.0.0]network 10.0.11.0 0.0.0.255</p>
<p>[AC-ospf-1-area-0.0.0.0]network 192.168.50.0 0.0.0.255<strong>AR1</strong></p>
<p>[ar1]int g0&#x2F;0&#x2F;0</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;0]ip add 100.1.1.2 24</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;0]int g0&#x2F;0&#x2F;1</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;1]ip add 200.1.1.1 24</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;1]int g0&#x2F;0&#x2F;2</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;2]ip add 10.0.11.1 24</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;2]q</p>
<p>[ar1]ip route-static 0.0.0.0 0 200.1.1.2</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;2]ospf</p>
<p>[ar1-ospf-1]area 0</p>
<p>[ar1-ospf-1-area-0.0.0.0]network 100.1.1.0 0.0.0.255</p>
<p>[ar1-ospf-1-area-0.0.0.0]network 10.0.11.1 0.0.0.255</p>
<p>[ar1-ospf-1]default-route-advertise always</p>
<p>[ar1]acl 2000</p>
<p>[ar1-acl-basic-2000]rule permit source 192.168.10.0 0.0.0.255</p>
<p>[ar1-acl-basic-2000]rule permit source 192.168.20.0 0.0.0.255</p>
<p>[ar1-acl-basic-2000]rule permit source 192.168.50.0 0.0.0.255</p>
<p>ar1]int g0&#x2F;0&#x2F;1</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;1]nat outbound 2000</p>
<p>此时依然可以全部进行通信这是因为走默认路径可以直接出去 而且对端会回包</p>
<p>[ar1]acl 2001</p>
<p>[ar1-acl-basic-2001]rule permit source 192.168.10.0 0.0.0.255</p>
<p>[ar1-acl-basic-2001]rule permit source 192.168.20.0 0.0.0.255</p>
<p>rule deny source 0.0.0.0 255.255.255.255</p>
<p>[ar1-acl-basic-2001]q</p>
<p>[ar1]int g0&#x2F;0&#x2F;0</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;1]traffic-filter inbound acl 2001</p>
<p><strong>AR2</strong></p>
<p>添加默认回程路由</p>
<p>[AR2]ip route-static 0.0.0.0 0 200.1.1.1</p>
<p>测试环回口[AR2]int LoopBack 0</p>
<p>[AR2-LoopBack0]ip add 2.2.2.2 24</p>
]]></content>
      <categories>
        <category>综合实验</category>
      </categories>
  </entry>
  <entry>
    <title>IS-IS总结</title>
    <url>/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>1、IS-IS的介绍</p>
<p>IS-IS   —中间系统到中间系统</p>
<p>Is-is最开始是在osi模型中，适用于CLNP网络，现在的Isis指的是集成Isis</p>
<p>集成IS-IS特点:<br>支持CLNP网络、IP网络<br>采用数据链路层封装</p>
<p>OSPF特点:<br>只支持IP网络<br>采用IP报文封装</p>
<p>应用场景：</p>
<p>ospf：园区网络</p>
<p>Isis：ISP骨干网</p>
<p>CLNP协议中不实用IP地址，使用的是NSAP地址</p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps1.jpg" alt="img"> </p>
<p>NET（Network Entity Title，网络实体名称）是OSI协议栈中设备的网络层信息，主要用于路由计算，由区域地址（Area ID）和System ID组成，可以看作是特殊的NSAP（SEL为00的NSAP）。<br>NET的长度与NSAP的相同，最长为20Byte，最短为8Byte。<br>在IP网络中运行IS-IS时，只需配置NET，根据NET地址设备可以获取到Area ID以及System ID。<br>System ID必须唯一，类似ospf中的router id</p>
<p>2、IS-IS基本概念</p>
<p>1）IS-IS中路由器的分类</p>
<p>Leverl-1：只能和同区域的L1、L1&#x2F;2路由器建立L1的邻接关系，只能有本区域的L1 LSDB数据库</p>
<p>level-2：可以和同区域的或者不同 区域L2、L1&#x2F;2路由器建立L2的邻接关系，拥有L2的LSDB</p>
<p>level1-2：可以 和同区域的L1路由器建立L1的邻接关系，也可以和同区域或者不同区域的L2路由器建立L2的邻接关系</p>
<p>2）Isis支持 的网络类型</p>
<p>广播和点到点</p>
<p>广播（Broadcast）： 如Ethernet。<br>点到点（P2P）： 如PPP、 HDLC等。</p>
<p>3）Isis的开销值</p>
<p>IS-IS有三种方式来确定接口的开销，按照优先级由高到低分别是：<br>接口开销：为单个接口设置开销。<br>全局开销：为所有接口设置开销。<br>自动计算开销：根据接口带宽自动计算开销。</p>
<p>3、IS-IS协议工作原理</p>
<p>工作原理：①建立邻接；②同步LSDB；③计算路由；</p>
<p>1）邻接建立</p>
<p>IS-IS按如下原则建立邻接关系：<br>只有同一层次的相邻路由器才有可能成为邻接。<br>对于Level-1路由器来说，Area ID必须一致。<br>链路两端IS-IS接口的网络类型必须一致。<br>链路两端IS-IS接口的地址必须处于同一网段（默认情况下）。</p>
<p>使用IIH（Isis hello ）：发现邻居；建立邻接关系；维护邻接关系，</p>
<p>广播网络：level-1 LAN IIH、level-2 LAN IIH、</p>
<p>Level-1 IIH和Level-2 IIH发送的组播地址分别为01-80-C2-00-00-14、01-80-C2-00-00-15。</p>
<p>点到点网络中：P2P  IIH</p>
<p>广播类型：</p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps2.jpg" alt="img"> </p>
<p>点到点类型：</p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps3.jpg" alt="img"> </p>
<p>选举DIS：</p>
<p>在广播网络中，IS-IS需要在一个广播网络中的所有的路由器中选举一个路由器作为DIS（Designated Intermediate System）。<br>DIS用来创建和更新伪节点（Pseudonodes），并负责生成伪节点的LSP，用来描述这个网络上有哪些网络设备。伪节点是用来模拟广播网络的一个虚拟节点，并非真实的路由器。在IS-IS中，伪节点用DIS的System ID和Circuit ID（非0值）标识。</p>
<p>Level-1和Level-2的DIS是分别选举的，用户可以为不同级别的DIS选举设置不同的优先级。</p>
<p>DIS选举原则：</p>
<p>①优先级：0-127  默认64，越大越优，优先级0也参与选举</p>
<p>②MAC地址：越大越优</p>
<p>DIS发送Hello PDU的时间间隔是普通路由器的1&#x2F;3，这样可以确保DIS出现故障时能够被更快速地被发现。</p>
<p>IS-IS中DIS与OSPF协议中DR（Designated Router）的区别：<br>在IS-IS广播网中，优先级为0的路由器也参与DIS的选举，而在OSPF中优先级为0的路由器则不参与DR的选举。<br>在IS-IS广播网中，当有新的路由器加入，并符合成为DIS的条件时，这个路由器会被选中成为新的DIS，原有的伪节点被删除。此更改会引起一组新的LSP泛洪。而在OSPF中，当一台新路由器加入后，即使它的DR优先级值最大，也不会立即成为该网段中的DR。—-ISis中的DIS支持抢占，ospf中的DR和BDR不支持抢占<br>在IS-IS广播网中，同一网段上的同一级别的路由器之间都会形成邻接关系，包括所有的非DIS路由器之间也会形成邻接关系。而在OSPF中，路由器只与DR和BDR建立邻接关系。 —Isis中建立的都是邻接的关系</p>
<p>2）同步链路状态数据库</p>
<p>L1和L2分别有自己的LSDB</p>
<p>LSDB中包含的就是LSP，LSP描述路由器的链路状态信息</p>
<p><R1> display isis lsdb<br>               Database information for ISIS(1)<br>Level-1 Link State Database<br>LSPID               Seq Num    Checksum  Holdtime  Length  ATT&#x2F;P&#x2F;OL<br>-——————————————————————————————–<br>0100.0000.1001.00-00*  0x00000005  0x13a8    1187      97     0&#x2F;0&#x2F;0<br>0100.0000.1001.01-00*   0x00000001  0xda2e    1185      55     0&#x2F;0&#x2F;0<br>0100.0000.2002.00-00   0x00000004  0x94e9    1188      86     1&#x2F;0&#x2F;0<br>Total LSP(s): 5<br>  <em>(In TLV)-Leaking Route, <em>(By LSPID)-Self LSP, +-Self LSP(Extended),<br>     ATT-Attached, P-Partition, OL-Overload<br>0100.0000.1001（路由器的系统ID）.00（实节点还是伪节点，00表示实节点，非0表示伪节点）-00（LSP分片）</em>（</em>表示是本路由器产生的）</R1></p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps4.jpg" alt="img"> </p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps5.jpg" alt="img"> </p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps6.jpg" alt="img"> </p>
<p>3）Isis路由计算</p>
<p>①L1的路由器只能通过L1的LSBD计算学习到L1的路由  —只有L1邻接关系的路由</p>
<p>②L2的路由器维护L2的LSDB，但是可以学习所有的路由，包括L1和L2的路由—全网路由</p>
<p>③L1&#x2F;2会向L1区域下发一条L1的缺省路由，L1可以通过该缺省路由到达L2</p>
<p>④路由渗透：将L2路由在L1&#x2F;2路由器上进行引入，让L1路由器可以学习到L2的明细路由</p>
<p>[R2-isis-1]import-route isis level-2 into level-1 </p>
<p> 4、IS-IS协议的报文</p>
<p>ospf–Isis报文的对应</p>
<p>Hello  —&gt;IIH</p>
<p>DD  —&gt;CSNP</p>
<p>LSR  —&gt;PSNP</p>
<p>LSU  —&gt;LSP</p>
<p>LSACK  —&gt;PSNP</p>
<p>LSA  —&gt;LSP</p>
<p>根据报文的种类，认证可以分为以下三类：<br>接口认证：在接口视图下配置，对Level-1和Level-2的Hello报文进行认证。<br>区域认证：在IS-IS进程视图下配置，对Level-1的CSNP、PSNP和LSP报文进行认证。<br>路由域认证：在IS-IS进程视图下配置，对Level-2的CSNP、PSNP和LSP报文进行认证。</p>
<p>根据报文的认证方式，可以分为以下四类：<br>简单认证：将配置的密码直接加入报文中，这种加密方式安全性较其他两种方式低。<br>MD5认证：通过将配置的密码进行MD5算法加密之后再加入报文中，提高密码的安全性。<br>Keychian认证：通过配置随时间变化的密码链表来进一步提升网络的安全性。<br>HMAC-SHA256认证：通过将配置的密码进行HMAC-SHA256算法加密之后再加入报文中，提高密码的安全性。</p>
<p>5、IS-IS协议配置</p>
<p>[r1]isis  进入Isis进程，默认进程1   </p>
<p>[r1-isis-1]network-entity 49.0001.0000.0000.0001.00   配置NET地址，其中system id必须唯一</p>
<p>[r1-isis-1]is-level level-1  修改路由的级别，默认为L1&#x2F;2路由器 </p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;0]isis enable  100   宣告网段进入Isis进程100</p>
<p>[R2-isis-1]is-name R2   将system id用name表示</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1]isis circuit-level level-2  修改接口的链路级别</p>
<p>[r1-GigabitEthernet0&#x2F;0&#x2F;0]isis circuit-type p2p   修改接口的链路类型</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;2]isis dis-priority 127 level-2   修改接口的优先级，影响DIS的选举，可以只针对某个level进行更改</p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps7.jpg" alt="img"> </p>
<p>查看命令</p>
<p>Display  isis peer  查看Isis邻居</p>
<p>Display Isis interface  查看DIS的选举、</p>
<p>Display Isis  route  查看Isis路由</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>IS-IS</tag>
      </tags>
  </entry>
  <entry>
    <title>PPP/PPPoE</title>
    <url>/2024/05/02/PPP-PPPoE/</url>
    <content><![CDATA[<p>PPP（点到点协议 ），该协议支持认证（PAP、CHAP）、该协议中还包括LCP、NCP协议</p>
<p>PPP链路的建立有三个阶段的协商过程，链路层协商、认证协商（可选）和网络层协商。<br>1）链路层协商：通过LCP报文进行链路参数协商，建立链路层连接。</p>
<p>链路层协议（LCP）协商的参数有MRU（最大接收单元）、认证方式（不认证、PAP、CHAP）、魔术字（检测是否有环路）</p>
<img src="/2024/05/02/PPP-PPPoE/微信截图_20240531153136.png" alt="微信截图_20240531153136" style="zoom:67%;">

<p><img src="/2024/05/02/PPP-PPPoE/wps1.jpg" alt="img"> </p>
<p><img src="/2024/05/02/PPP-PPPoE/wps2.jpg" alt="img"> </p>
<p><img src="/2024/05/02/PPP-PPPoE/wps3.jpg" alt="img"> </p>
<p>2）认证协商（可选）：通过链路建立阶段协商的认证方式进行链路认证。</p>
<p><img src="/2024/05/02/PPP-PPPoE/wps4.jpg" alt="img"> </p>
<p><img src="/2024/05/02/PPP-PPPoE/wps5.jpg" alt="img"> </p>
<p>3）网络层协商 ：通过NCP协商来选择和配置一个网络层协议并进行网络层参数协商。</p>
<p><img src="/2024/05/02/PPP-PPPoE/wps6.jpg" alt="img"> </p>
<p><img src="/2024/05/02/PPP-PPPoE/wps7.jpg" alt="img"> </p>
<p>PPP协商时接口状态的变化：</p>
<p><img src="/2024/05/02/PPP-PPPoE/wps8.jpg" alt="img"> </p>
<p>正常PPP链路建立需要经历链路建立阶段、认证阶段和网络层协商阶段，详细过程如下：<br>通信双方开始建立PPP链路时，先进入到Establish阶段。<br>在Establish阶段，进行LCP协商：协商通信双方的MRU（Maximum Receive Unit，最大接收单元）、认证方式和魔术字（Magic Number）等选项。协商成功后进入Opened状态，表示底层链路已建立。<br>如果配置了认证，将进入Authenticate阶段。否则直接进入Network阶段。<br>在Authenticate阶段，会根据连接建立阶段协商的认证方式进行链路认证。认证方式有两种：PAP和CHAP。如果认证成功，进入Network阶段，否则进入Terminate阶段，拆除链路，LCP状态转为Down。<br>在Network阶段，PPP链路进行NCP协商。通过NCP协商来选择和配置一个网络层协议并进行网络层参数协商。最常见的NCP协议是IPCP，用来协商IP参数。<br>在Terminate阶段，如果所有的资源都被释放，通信双方将回到Dead阶段。<br>PPP运行过程中，可以随时中断连接，物理链路断开、认证失败、超时定时器时间到、管理员通过配置关闭连接等动作都可能导致链路进入Terminate阶段。</p>
<p>网络运营商如何对用户上网行为进行收费和控制 ？ 针对特定的数据包，就必须识别发送方的身份。</p>
<ol>
<li>在以太网链路上，以太网技术虽然具有简单易用，成本低等特点，但是以太网广播网络的属性，使得其通信双方无法相互验证对方的身份，因而通信是不安全的。</li>
<li>在PPP链路上，<strong>由于PPP协议自带认证功能</strong>，因此可以完美的解决上述问题。但是，PPP链路又无法实现多用户上网的需求。</li>
<li>为了解决这个矛盾问题，解决用户上网行为管理和收费的问题，提出了<strong>将PPP数据帧封装在以太网数据帧里边</strong>从而在以太网网络中传输的技术——PPPoE技术。</li>
</ol>
<blockquote>
<p>这里的PPP，就是指的PPP协议数据帧，而o就是over的意思，E就是Ethernet的意思，因此，PPPoE形象的说就是<strong>“在以太网上的PPP协议”</strong>。</p>
</blockquote>
<p>PPPoE技术可以将用户连接到远程接入设备上，并提供良好访问控制功能，提供了一种经济的用户接入技术，并实现了对用户的控制。</p>
<p>PPPoE协议采用Client&#x2F;Server模式，普通用户一般为Client，而运营商为Server。</p>
<p>PPPoE的建立分为<strong>Discover阶段</strong>和<strong>PPP Session阶段</strong>。</p>
<ul>
<li><p><strong>Discover阶段：</strong>主要是选择PPPoE服务器，并确定所要建立的会话标识符Session ID。</p>
<p>当Client要运行PPPoE时，首先以广播的形式发送一个<strong>PADI（PPPoE Active Discovery Initiation）报文</strong>，该报文中含有Client端要请求的服务信息</p>
<p>PPPoE服务器在收到该报文后，会以单播的方式发送一个<strong>PADO（PPPoE Active Discovery Offer）报文</strong>，对Client端的PADI报文进行回应。</p>
<p>PPPoE Client端在收到这个报文后，会向PPPoE Server发送<strong>PADR（PPPoE Active Discovery Request）报文</strong>。在这个报文中，PPPoE Client会创建并携带一个<strong>PPPoE Session</strong>。</p>
<p>PPPoE Server还会向客户端发送<strong>PADS（PPPoE Active Discovery Session-confirmation）报文</strong>，表示收到了该Session ID。</p>
<p>发送<strong>PADT（PPPOE Active Discovery Terminate）</strong>报文，终止连接</p>
</li>
<li><p><strong>PPP Session阶段：</strong>即执行标准的PPP过程，包括LCP协商、PAP&#x2F;CHAP认证、NCP协商等阶段。</p>
<p>PPP会话阶段包括<strong>LCP协商、PAP&#x2F;CHAP认证、NCP协商</strong>等阶段。需结合PPP链路建立过程来分析</p>
</li>
<li><p><img src="/2024/05/02/PPP-PPPoE/wc07_r.jpg" alt="wc07_r"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>PPP</tag>
        <tag>PPPoE</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH</title>
    <url>/2024/05/22/SSH/</url>
    <content><![CDATA[<p><img src="/2024/05/22/SSH/QQ%E6%88%AA%E5%9B%BE20240522163645.png" alt="QQ截图20240522163645"></p>
<p><img src="/2024/05/22/SSH/QQ%E6%88%AA%E5%9B%BE20240522163801.png" alt="QQ截图20240522163801"></p>
<p><img src="/2024/05/22/SSH/QQ%E6%88%AA%E5%9B%BE20240522170905.png" alt="QQ截图20240522170905"></p>
<p>1.server配置rsa<br>[server]rsa local-key-pair create<br>[server]dis rsa local-key-pair public（查看）<br>2.全局开启stelnet<br>[server]stelnet server enable<br>3.vty接口配置<br>[server]user-interface vty 0 4	<br>[server-ui-vty0-4]authentication-mode aaa	<br>[server-ui-vty0-4]protocol inbound ssh<br>4.创建用户名和密码<br>[server]aaa<br>[server-aaa]local-user client01 password cipher huawei123<br>[server-aaa]local-user client01 service-type ssh	<br>[server-aaa]local-user client01 privilege level 3<br>（同理创建client02）<br>5.设置服务端口号<br>[server]ssh server port 1025<br>6.客户端上创建rsa本地密钥<br>[client01]rsa local-key-pair create<br>7.将客户端密钥复制到服务器<br>[server]rsa peer-public-key client01<br>[server-rsa-public-key]public-key-code begin<br>Enter “RSA key code” view, return last view with “public-key-code end”.<br>[server-rsa-key-code]<br>[server-rsa-key-code]3047<br>[server-rsa-key-code]  0240<br>[server-rsa-key-code]    BB44D49F 0A455501 33FC2A58 9EA52FF3 7C3A29A5<br>[server-rsa-key-code]    43A29D63 1D74F975 FAF91466 EF0D2222 A8AE038B<br>[server-rsa-key-code]    2DAA1CE0 5F22B5D9 F6D0F2F0 EB0747B9 4D916AE1<br>[server-rsa-key-code]    5B83DE2D<br>[server-rsa-key-code]  0203<br>[server-rsa-key-code]    010001	<br>[server-rsa-key-code]public-key-code end<br>[server-rsa-public-key]peer-public-key end		<br>[server]ssh user client01 assign rsa-key client01<br>8.客户端上开启SSH首次登录验证<br>[client01]ssh client first-time enable </p>
<p>[client01]stelnet 2.2.2.2 1025（登录）</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>STP/RSTP/MSTP总结</title>
    <url>/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="STP"><a href="#STP" class="headerlink" title="STP"></a>STP</h1><p>以太网交换网络中为了进行链路备份，提高网络可靠性，通常会使用冗余链路。但是使用冗余链路会在交换网络上产生环路，引发广播风暴以及MAC地址表不稳定等故障现象，从而导致用户通信质量较差，甚至通信中断。为解决交换网络中的环路问题，提出了生成树协议STP（Spanning Tree Protocol）。</p>
<p>与众多协议的发展过程一样，生成树协议也是随着网络的发展而不断更新的，从最初的IEEE <strong>802.1D</strong>中定义的STP到IEEE <strong>802.1W</strong>中定义的快速生成树协议RSTP（Rapid Spanning Tree Protocol），再到最新的IEEE <strong>802.1S</strong>中定义的多生成树协议MSTP（Multiple Spanning Tree Protocol）。</p>
<p>生成树协议中，<strong>MSTP兼容</strong>RSTP、STP，RSTP兼容STP。</p>
<table>
<thead>
<tr>
<th>生成树协议</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>STP</td>
<td>形成一棵无环路的树，解决广播风暴并实现冗余备份。收敛速度较慢。</td>
<td>无需区分用户或业务流量，所有VLAN共享一棵生成树。</td>
</tr>
<tr>
<td>RSTP</td>
<td>形成一棵无环路的树，解决广播风暴并实现冗余备份。收敛速度快。</td>
<td></td>
</tr>
<tr>
<td>MSTP</td>
<td>形成多棵无环路的树，解决广播风暴并实现冗余备份。收敛速度快。多棵生成树在VLAN间实现负载均衡，不同VLAN的流量按照不同的路径转发。</td>
<td>需要区分用户或业务流量，并实现负载分担。不同的VLAN通过不同的生成树转发流量，每棵生成树之间相互独立。</td>
</tr>
</tbody></table>
<h2 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h2><p>1.广播风暴</p>
<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529135327.png" alt="QQ截图20240529135327" style="zoom: 67%;">

<p>根据交换机的转发原则，如果交换机从一个端口上接收到的是一个广播帧，或者是一个目的MAC地址未知的单播帧，则会将这个帧向除源端口之外的所有其他端口转发（泛洪）。如果交换网络中有环路，则这个帧会被无限转发，此时便会形成广播风暴，网络中也会充斥着重复的数据帧。</p>
<p>SWB，SWA和SWC也会将此帧转发到除了接收此帧的其他所有端口，结果此帧又会被再次转发给SWB，这种循环会一直持续，于是便产生了广播风暴。交换机性能会因此急速下降，并会导致业务中断。</p>
<p>2.MAC地址表震荡</p>
<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529135546.png" alt="QQ截图20240529135546" style="zoom:67%;">

<p>交换机是根据所接收到的数据帧的源地址和接收端口生成MAC地址表项的。</p>
<p>（1）主机A向外发送一个单播帧，假设此单播帧的目的MAC地址在网络中所有交换机的MAC地址表中都暂时不存在。SWB收到此数据帧之后，在MAC地址表中生成一个MAC地址表项：</p>
<table>
<thead>
<tr>
<th>SWB的MAC地址表</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>MAC地址</td>
<td>端口</td>
</tr>
<tr>
<td>00-05-06-07-08-AA</td>
<td>GE0&#x2F;0&#x2F;3</td>
</tr>
</tbody></table>
<p>​     将其从G0&#x2F;0&#x2F;1和G0&#x2F;0&#x2F;2端口转发。此例仅以SWB从G0&#x2F;0&#x2F;1端口转发此帧为例进行说明。</p>
<p>（2）SWA接收到此帧后，由于MAC地址表中没有对应此帧目的MAC地址的表项，所以SWA会将此帧从G0&#x2F;0&#x2F;2转发出去。</p>
<p>（3）SWC接收到此帧后，由于MAC地址表中也没有对应此帧目的MAC地址的表项，所以SWC会将此帧从G0&#x2F;0&#x2F;2端口发送回SWB，也会发给主机B。</p>
<p>（4）SWB从G0&#x2F;0&#x2F;2接口接收到此数据帧之后，会在MAC地址表中删除原有的相关表项，生成一个新的表项：</p>
<table>
<thead>
<tr>
<th>SWB的MAC地址表</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>MAC地址</td>
<td>端口</td>
</tr>
<tr>
<td>00-05-06-07-08-AA</td>
<td>GE0&#x2F;0&#x2F;3</td>
</tr>
<tr>
<td>00-05-06-07-08-AA</td>
<td>GE0&#x2F;0&#x2F;2</td>
</tr>
</tbody></table>
<p>此过程会不断重复，从而导致MAC地址表震荡。</p>
<h2 id="STP基本概念"><a href="#STP基本概念" class="headerlink" title="STP基本概念"></a>STP基本概念</h2><p>根桥</p>
<p>树形的网络结构必须有树根，于是STP引入了根桥（Root Bridge）概念。</p>
<p>对于一个STP网络，根桥在全网中只有一个，它是整个网络的逻辑中心，但不一定是物理中心。根桥会根据网络拓扑的变化而动态变化。</p>
<p>网络收敛后，根桥会按照一定的时间间隔产生并向外发送配置BPDU，其他设备收到该配置BPDU后，如果优先级比自己的配置BPDU高，则非根桥设备会根据收到的配置BPDU中携带的信息更新自己STP端口存储的配置BPDU信息，否则会丢弃该配置BPDU。</p>
<ul>
<li><p>BID：桥ID</p>
<p>IEEE 802.1D标准中规定BID是由16位的桥优先级（Bridge Priority）与桥MAC地址构成。BID桥优先级占据高16位，其余的低48位是MAC地址。</p>
<p>在STP网络中，桥ID最小的设备会被选举为根桥。</p>
</li>
<li><p>PID：端口ID</p>
<p>PID由两部分构成的，高4位是端口优先级，低12位是端口号。</p>
<p>PID只在某些情况下对选择指定端口有作用。</p>
</li>
</ul>
<p>桥优先级：0-65535，默认32768，必须是4095倍数</p>
<p>端口优先级：0-240，默认128，步长16，必须是16的倍数</p>
<h2 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h2><p>1.选举根桥（BID&#x3D;优先级+MAC，优先级越小越优，如果优先级相等，MAC小的成为根桥）</p>
<p>在一个交换网络中选举一个根桥</p>
<p>2.选举根端口（RPC小的优+上行交换机的BID+上行交换机的PID+本地PID）</p>
<p>在每个非根交换机选举一个根端口</p>
<p>3.选举指定端口（RPC小的优+本端口的BID+本端口的PID）</p>
<p>每个网段选举一个指定端口</p>
<p>4.阻塞非指定端口</p>
<p>阻塞交换机上的所有非根，非指定端口</p>
<table>
<thead>
<tr>
<th>端口状态</th>
<th>目的</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Forwarding</td>
<td>端口既转发用户流量也处理BPDU报文。</td>
<td>只有根端口或指定端口才能进入Forwarding状态。</td>
</tr>
<tr>
<td>Learning</td>
<td>设备会根据收到的用户流量构建MAC地址表，但不转发用户流量。</td>
<td>过渡状态，增加Learning状态<strong>防止临时环路</strong>。</td>
</tr>
<tr>
<td>Listening</td>
<td>确定端口角色，将选举出根桥、根端口和指定端口。</td>
<td>过渡状态。</td>
</tr>
<tr>
<td>Blocking</td>
<td>端口仅仅接收并处理BPDU，不转发用户流量。</td>
<td>阻塞端口的最终状态。</td>
</tr>
<tr>
<td>Disabled</td>
<td>端口不仅不处理BPDU报文，也不转发用户流量。</td>
<td>端口状态为Down。</td>
</tr>
</tbody></table>
<p><img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/fig_dc_fd_stp_000504.png" alt="fig_dc_fd_stp_000504"></p>
<p>对于STP，影响端口状态和端口收敛有以下3个参数。</p>
<ul>
<li><p>Hello Time（2s）</p>
<p>运行STP协议的设备发送配置消息BPDU的时间间隔，用于设备检测链路是否存在故障。设备每隔Hello Time时间会向周围的设备发送hello报文，以确认链路是否存在故障。</p>
<p>当网络拓扑稳定之后，该计时器的修改只有在根桥修改后才有效。新的根桥会在发出的BPDU报文中填充适当的字段以向其他非根桥传递该计时器修改的信息。但当拓扑变化之后，TCN BPDU的发送不受这个计时器的管理。</p>
</li>
<li><p>Forward Delay（15s）</p>
<p>设备状态迁移的延迟时间。链路故障会引发网络重新进行生成树的计算，生成树的结构将发生相应的变化。不过重新计算得到的新配置消息无法立刻传遍整个网络，如果新选出的根端口和指定端口立刻就开始数据转发的话，可能会造成临时环路。为此，STP采用了一种状态迁移机制，新选出的根端口和指定端口要经过<strong>2倍的Forward Delay</strong>延时后才能进入转发状态，这个延时保证了新的配置消息传遍整个网络，从而防止了临时环路的产生。30s</p>
<p>Forward Delay Timer指一个端口处于Listening和Learning状态的各自持续时间，默认是15秒。即Listening状态持续15秒，随后Learning状态再持续15秒。这两个状态下的端口不转发用户流量，这正是STP用于避免临时环路的关键。</p>
</li>
<li><p>Max Age（20s）</p>
<p>端口的BPDU报文老化时间，可在根桥上通过命令人为改动老化时间。</p>
<p>Max Age通过配置BPDU报文的传输，可保证Max Age在整网中一致。运行STP协议的网络中非根桥设备收到配置BPDU报文后，报文中的Message Age和Max Age会进行比较：</p>
<ul>
<li>如果Message Age小于等于Max Age，则该非根桥设备继续转发配置BPDU报文。</li>
<li>如果Message Age大于Max Age，则该配置BPDU报文将被老化。该非根桥设备直接丢弃该配置BPDU，可认为网络直径过大，导致根桥连接失败。</li>
</ul>
<p>如果配置BPDU是根桥发出的，则Message Age为0。否则，Message Age是从根桥发送到当前桥接收到BPDU的总时间，包括传输延时等。实际实现中，配置BPDU报文经过一个桥，Message Age增加1。</p>
</li>
</ul>
<h2 id="STP报文格式"><a href="#STP报文格式" class="headerlink" title="STP报文格式"></a>STP报文格式</h2><ul>
<li>配置BPDU是一种心跳报文，只要端口使能STP，则配置BPDU就会按照Hello Time定时器规定的时间间隔从指定端口发出。</li>
<li>TCN BPDU是在设备检测到网络拓扑发生变化时才发出。</li>
</ul>
<p>通常所说的BPDU报文多数指配置BPDU。</p>
<p>在初始化过程中，每个桥都主动发送配置BPDU。在网络拓扑稳定以后，每台设备的指定端口都会周期性的发送配置BPDU。配置BPDU的长度至少要35个字节，包含了桥ID、路径开销和端口ID等参数。只有当发送者的BID或端口的PID两个字段中至少有一个和本桥接收端口不同，BPDU报文才会被处理，否则丢弃。这样避免了处理和本端口信息一致的BPDU报文。</p>
<p>配置BPDU在以下3种情况下会产生：</p>
<ul>
<li>只要端口使能STP，则配置BPDU就会按照Hello Time定时器规定的时间间隔从指定端口发出。</li>
<li>当根端口收到配置BPDU时，如果优先级比自己的配置BPDU高，则会根据收到的配置BPDU中携带的信息更新自己STP端口存储的配置BPDU信息并从指定接口向下游发送，否则会丢弃该配置BPDU。</li>
<li>当指定端口收到比自己差的配置BPDU时，会立刻向下游设备发送自己的BPDU。</li>
</ul>
<h2 id="STP拓扑变更"><a href="#STP拓扑变更" class="headerlink" title="STP拓扑变更"></a>STP拓扑变更</h2><ol>
<li>在网络拓扑发生变化后，下游设备会不间断地向上游设备发送TCN BPDU报文。</li>
<li>上游设备收到下游设备发来的TCN BPDU报文后，只有指定端口处理TCN BPDU报文。其它端口也有可能收到TCN BPDU报文，但不会处理。</li>
<li>上游设备会把配置BPDU报文中的Flags的TCA位设置1，然后发送给下游设备，告知下游设备停止发送TCN BPDU报文。</li>
<li>上游设备复制一份TCN BPDU报文，向根桥方向发送。</li>
<li>重复步骤1、2、3、4，直到根桥收到TCN BPDU报文。</li>
<li>根桥把配置BPDU报文中的Flags的TC位置1后发送，通知下游设备直接删除桥MAC地址表项。</li>
</ol>
<p>详情请看<a href="https://www.yangzhiyu.top/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/">STP拓扑变更机制 | 沃德发 (yangzhiyu.top)</a></p>
<h2 id="STP故障收敛时间"><a href="#STP故障收敛时间" class="headerlink" title="STP故障收敛时间"></a>STP故障收敛时间</h2><p><img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ%E6%88%AA%E5%9B%BE20240529144316.png" alt="QQ截图20240529144316"></p>
<p> sw1的fa0&#x2F;1的接口down了，但是它还是可以从block端口中接收到sw0的bpdu，那么它与root的联系就没有断开，它此时做的操作是根据根桥发送的bpdu重新计算根端口，然后经历<strong>30s</strong>的收敛，将fa0&#x2F;2变为根端口。</p>
<p><img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ%E6%88%AA%E5%9B%BE20240529144351.png" alt="QQ截图20240529144351"></p>
<p>sw2的fa0&#x2F;2断开down了，我们知道block端口时不会对bpdu进行发送的，于是fa0&#x2F;1就相当于与root断开了，一段时间后，他就会从fa0&#x2F;1发送自己是根桥的bpdu，但是sw1是不会理睬的，因为它知道sw0的bpdu才是最好的，因为sw0的bpdu中的根桥ID的优先级是最高的， 经过20s后，sw1的fa0&#x2F;2因为没有从swfa0&#x2F;1上接收到bpdu，所以它会将端口转换为指定端口将bpdu信息进行转发，这个过程大概50s。</p>
<h1 id="RSTP"><a href="#RSTP" class="headerlink" title="RSTP"></a>RSTP</h1><p>IEEE于2001年发布的802.1w标准定义了快速生成树协议RSTP（Rapid Spanning Tree Protocol），该协议基于STP协议，对原有的STP协议进行了更加细致的修改和补充。</p>
<p>STP协议虽然能够解决环路问题，但是由于网络拓扑收敛慢，影响了用户通信质量。如果网络中的拓扑结构频繁变化，网络也会随之频繁失去连通性，从而导致用户通信频繁中断，这是用户无法忍受的。</p>
<p>STP的不足之处如下：</p>
<ul>
<li><p>STP没有细致区分端口状态和端口角色，不利于初学者学习及部署。</p>
<p>网络协议的优劣往往取决于协议是否对各种情况加以细致区分。</p>
<ul>
<li><p>从用户角度来讲，Listening、Learning和Blocking状态并没有区别，都同样不转发用户流量。</p>
</li>
<li><p>从使用和配置角度来讲，端口之间最本质的区别并不在于端口状态，而是在于端口扮演的角色。</p>
<p>根端口和指定端口可以都处于Listening状态，也可能都处于Forwarding状态。</p>
</li>
</ul>
</li>
<li><p>STP算法是被动的算法，<strong>依赖定时器</strong>等待的方式判断拓扑变化，收敛速度慢。</p>
</li>
<li><p>STP算法要求在稳定的拓扑中，根桥主动发出配置BPDU报文，而其他设备进行处理，传遍整个STP网络。</p>
<p>这也是导致拓扑收敛慢的主要原因之一。</p>
</li>
</ul>
<h2 id="端口改进"><a href="#端口改进" class="headerlink" title="端口改进"></a>端口改进</h2><p>根据STP的不足，RSTP删除了3种端口状态，新增加了2种端口角色</p>
<p>RSTP的端口角色共有5种：根端口、指定端口、Alternate端口、Backup端口和Disable端口。</p>
<ul>
<li><p>从配置BPDU报文发送角度来看：</p>
<ul>
<li>Alternate端口就是由于学习到其它网桥发送的配置BPDU报文而阻塞的端口。</li>
<li>Backup端口就是由于学习到自己发送的配置BPDU报文而阻塞的端口。</li>
</ul>
</li>
<li><p>从用户流量角度来看：</p>
<ul>
<li>Alternate端口提供了从指定桥到根的另一条可切换路径，作为根端口的备份端口。</li>
<li>Backup端口作为指定端口的备份，提供了另一条从根桥到相应网段的备份通路。</li>
</ul>
<p>给一个RSTP域内所有端口分配角色的过程就是整个拓扑收敛的过程。</p>
</li>
</ul>
<p>RSTP的状态规范把原来的5种状态缩减为3种。根据端口是否转发用户流量和学习MAC地址来划分:</p>
<ul>
<li>如果不转发用户流量也不学习MAC地址，那么端口状态就是Discarding状态。</li>
<li>如果不转发用户流量但是学习MAC地址，那么端口状态就是Learning状态。</li>
<li>如果既转发用户流量又学习MAC地址，那么端口状态就是Forwarding状态。</li>
</ul>
<table>
<thead>
<tr>
<th>STP端口状态</th>
<th>RSTP端口状态</th>
<th>端口在拓扑中的角色</th>
</tr>
</thead>
<tbody><tr>
<td>Forwarding</td>
<td>Forwarding</td>
<td>包括根端口、指定端口</td>
</tr>
<tr>
<td>Learning</td>
<td>Learning</td>
<td>包括根端口、指定端口</td>
</tr>
<tr>
<td>Listening</td>
<td>Discarding</td>
<td>包括根端口、指定端口</td>
</tr>
<tr>
<td>Blocking</td>
<td>Discarding</td>
<td>包括Alternate端口、Backup端口</td>
</tr>
<tr>
<td>Disabled</td>
<td>Discarding</td>
<td>包括Disable端口</td>
</tr>
</tbody></table>
<h2 id="配置BPDU的处理发生变化"><a href="#配置BPDU的处理发生变化" class="headerlink" title="配置BPDU的处理发生变化"></a>配置BPDU的处理发生变化</h2><ul>
<li><p>拓扑稳定后，配置BPDU报文的发送方式</p>
<p>拓扑稳定后，根桥按照Hello Timer规定的时间间隔发送配置BPDU。其他非根桥设备在收到上游设备发送过来的配置BPDU后，才会触发发出配置BPDU，此方式使得STP协议计算复杂且缓慢。RSTP对此进行了改进，即在拓扑稳定后，无论非根桥设备是否接收到根桥传来的配置BPDU报文，非根桥设备仍然按照Hello Timer规定的时间间隔发送配置BPDU，该行为完全由每台设备自主进行。</p>
</li>
<li><p>更短的BPDU超时计时</p>
<p>如果一个端口在超时时间（超时时间＝Hello Time × 3 × Timer Factor）内没有收到上游设备发送过来的配置BPDU，那么该设备认为与此邻居之间的协商失败。而不像STP那样需要先等待一个Max Age。（6s）</p>
</li>
<li><p>处理次等BPDU</p>
<p>当一个端口收到上游的指定桥发来的RST BPDU报文时，该端口会将自身存储的RST BPDU与收到的RST BPDU进行比较。</p>
<p>如果该端口存储的RST BPDU的优先级高于收到的RST BPDU，那么该端口会直接丢弃收到的RST BPDU，立即回应自身存储的RST BPDU。当上游设备收到下游设备回应的RST BPDU后，上游设备会根据收到的RST BPDU报文中相应的字段立即更新自己存储的RST BPDU。</p>
<p>由此，RSTP处理次等BPDU报文不再依赖于任何定时器通过超时解决拓扑收敛，从而加快了拓扑收敛。</p>
</li>
</ul>
<h2 id="快速收敛（P-A机制）"><a href="#快速收敛（P-A机制）" class="headerlink" title="快速收敛（P&#x2F;A机制）"></a>快速收敛（P&#x2F;A机制）</h2><p>当一个端口被选举成为指定端口之后，在STP中，该端口至少要等待一个Forward Delay（Learning）时间才会迁移到Forwarding状态。而在RSTP中，此端口会先进入Discarding状态，再通过Proposal&#x2F;Agreement机制快速进入Forward状态。这种机制必须在点到点全双工链路上使用。Proposal&#x2F;Agreement机制简称P&#x2F;A机制</p>
<p>Proposal&#x2F;Agreement机制，其目的是使一个指定端口尽快进入Forwarding状态。如<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZH05262_14_zh/HDXAZH05262_14_zh/resources/dc/dc_fd_stp_0009.html#dc_fd_stp_0009__fig_dc_fd_stp_000901">图1</a>所示，根桥S1和S2之间新添加了一条链路。在当前状态下，S2的另外几个端口p2是Alternate端口，p3是指定端口且处于Forwarding状态，p4是边缘端口。</p>
<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529151927.png" alt="QQ截图20240529151927" style="zoom:67%;">

<p>新链路连接成功后，P&#x2F;A机制协商过程如下：</p>
<ol>
<li>p0和p1两个端口马上都先成为指定端口，发送RST BPDU。</li>
<li>S2的p1口收到更优的RST BPDU，马上意识到自己将成为根端口，而不是指定端口，停止发送RST BPDU。</li>
<li>S1的p0进入Discarding状态，于是发送的RST BPDU中把proposal置1。</li>
<li>S2收到根桥发送来的携带proposal的RST BPDU，开始将自己的所有端口进入sync变量置位。</li>
<li>p2已经阻塞，状态不变；p4是边缘端口，不参与运算；所以只需要阻塞非边缘指定端口p3。</li>
<li>各端口的synced变量置位后，p2、p3进入Discarding状态，p1进入Forwarding状态并向S1返回Agreement位置位的回应RST BPDU。</li>
<li>当S1判断出这是对刚刚发出的Proposal的回应，于是端口p0马上进入Forwarding状态。</li>
</ol>
<p>下游设备继续执行P&#x2F;A协商过程。</p>
<p>事实上对于STP，指定端口的选择可以很快完成，主要的速度瓶颈在于：为了避免环路，必须等待足够长的时间，使全网的端口状态全部确定，也就是说必须要等待至少一个Forward Delay所有端口才能进行转发。而RSTP的主要目的就是消除这个瓶颈，通过阻塞自己的非根端口来保证不会出现环路。而使用P&#x2F;A机制加快了上游端口转到Forwarding状态的速度。</p>
<h2 id="保护功能"><a href="#保护功能" class="headerlink" title="保护功能"></a>保护功能</h2><table>
<thead>
<tr>
<th>保护功能</th>
<th>场景</th>
<th>原理</th>
</tr>
</thead>
<tbody><tr>
<td>BPDU保护</td>
<td>在交换设备上，通常将直接与用户终端（如PC机）或文件服务器等非交换设备相连的端口配置为边缘端口。正常情况下，边缘端口不会收到RST BPDU。如果有人伪造RST BPDU恶意攻击交换设备，当边缘端口接收到RST BPDU时，交换设备会自动将边缘端口设置为非边缘端口，并重新进行生成树计算，从而引起网络震荡。</td>
<td>交换设备上启动了BPDU保护功能后，如果边缘端口收到RST BPDU，边缘端口将被error-down，但是边缘端口属性不变，同时通知网管系统。</td>
</tr>
<tr>
<td>根保护</td>
<td>由于维护人员的错误配置或网络中的恶意攻击，网络中合法根桥有可能会收到优先级更高的RST BPDU，使得合法根桥失去根地位，从而引起网络拓扑结构的错误变动。这种不合法的拓扑变化，会导致原来应该通过高速链路的流量被牵引到低速链路上，造成网络拥塞。</td>
<td>对于启用Root保护功能的指定端口，其端口角色只能保持为指定端口。一旦启用Root保护功能的指定端口收到优先级更高的RST BPDU时，端口状态将进入Discarding状态，不再转发报文。在经过一段时间（通常为两倍的Forward Delay），如果端口一直没有再收到优先级较高的RST BPDU，端口会自动恢复到正常的Forwarding状态。<strong>说明：</strong>Root保护功能只能在指定端口上配置生效。</td>
</tr>
<tr>
<td>环路保护</td>
<td>在运行RSTP协议的网络中，根端口和其他阻塞端口状态是依靠不断接收来自上游交换设备的RST BPDU维持。当由于链路拥塞或者单向链路故障导致这些端口收不到来自上游交换设备的RST BPDU时，此时交换设备会重新选择根端口。原先的根端口会转变为指定端口，而原先的阻塞端口会迁移到转发状态，从而造成交换网络中可能产生环路。</td>
<td>在启动了环路保护功能后，如果根端口或Alternate端口长时间收不到来自上游的RST BPDU时，则向网管发出通知信息（如果是根端口则进入Discarding状态）。而阻塞端口则会一直保持在阻塞状态，不转发报文，从而不会在网络中形成环路。直到根端口或Alternate端口收到RST BPDU，端口状态才恢复正常到Forwarding状态。<strong>说明：</strong>环路保护功能只能在根端口或Alternate端口上配置生效。</td>
</tr>
<tr>
<td>防TC-BPDU攻击</td>
<td>交换设备在接收到TC BPDU报文后，会执行MAC地址表项和ARP表项的删除操作。如果有人伪造TC BPDU报文恶意攻击交换设备时，交换设备短时间内会收到很多TC BPDU报文，频繁的删除操作会给设备造成很大的负担，给网络的稳定带来很大隐患。</td>
<td>启用防TC-BPDU报文攻击功能后，在单位时间内，交换设备处理TC BPDU报文的次数可配置。如果在单位时间内，交换设备在收到TC BPDU报文数量大于配置的阈值，那么设备只会处理阈值指定的次数。对于其他超出阈值的TC BPDU报文，定时器到期后设备只对其统一处理一次。这样可以避免频繁的删除MAC地址表项和ARP表项，从而达到保护设备的目的。</td>
</tr>
</tbody></table>
<h2 id="RSTP拓扑变更"><a href="#RSTP拓扑变更" class="headerlink" title="RSTP拓扑变更"></a>RSTP拓扑变更</h2><p>判断拓扑变化唯一标准：一个非边缘端口迁移到Forwarding状态<br>为本交换设备的所有非边缘指定端口启动一个TC While Timer，该计时器值是H<strong>ello Time的两倍</strong>。在这个时间内，清空状态发生变化的端口上学习到的MAC地址。同时，由这些端口向外发送RST BPDU，其中TC置位。一旦TC While Timer超时，则停止发送RST BPDU。<br>其他交换设备接收到RST BPDU后，清空所有端口学习到MAC地址，除了收到RST BPDU的端口。然后也为自己所有的非边缘指定端口和根端口启动TC While Timer，重复上述过程。 如此，网络中就会产生RST BPDU的泛洪。 </p>
<p><img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/1580705-20200812101447639-1540837884.png" alt="1580705-20200812101447639-1540837884"></p>
<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529153721.png" alt="QQ截图20240529153721" style="zoom:67%;">

<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529153729.png" alt="QQ截图20240529153729" style="zoom:67%;">

<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529153735.png" alt="QQ截图20240529153735" style="zoom:67%;">

<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529153742.png" alt="QQ截图20240529153742" style="zoom:67%;">

<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529153750.png" alt="QQ截图20240529153750" style="zoom:67%;">
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>STP</tag>
        <tag>RSTP</tag>
        <tag>MSTP</tag>
      </tags>
  </entry>
  <entry>
    <title>STP拓扑变更机制</title>
    <url>/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="为什么要有STP拓扑变化机制"><a href="#为什么要有STP拓扑变化机制" class="headerlink" title="为什么要有STP拓扑变化机制"></a>为什么要有STP拓扑变化机制</h1><p>网络中发生拓扑变化时，例如链路中断或接口异常Down等情况，由于MAC地址老化时间的存在（缺省为5分钟），如果不及时通知上游设备，则可能会导致上游设备的报文在这段时间内一直向一个不可达的链路发送。</p>
<h5 id="拓扑改变导致MAC地址表错误"><a href="#拓扑改变导致MAC地址表错误" class="headerlink" title="拓扑改变导致MAC地址表错误"></a>拓扑改变导致MAC地址表错误</h5><p><img src="/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/1stp3434.png" alt="1stp3434"></p>
<p> 本例中，SW3中的MAC地址表项定义了通过端口GigabitEthernet 0&#x2F;0&#x2F;2可以到达主机1，通过端口GigabitEthernet 0&#x2F;0&#x2F;3可以到达主机2。由于SW2的根端口产生故障，导致生成树拓扑重新收敛，在生成树拓扑完成收敛之后，从主机1到主机2的帧仍然不能到达目的地。这是因为MAC地址表项老化时间是300秒，主机2发往主机1的帧到达SW3后，SW3会继续通过端口GigabitEthernet 0&#x2F;0&#x2F;2转发该数据帧。那么该怎么快速恢复转发？</p>
<p><img src="/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/2stp821462.png" alt="2stp821462"></p>
<p>   拓扑变更以及MAC地址表项更新的具体过程如下：</p>
<p>SW2感知到网络拓扑发生变化后，会立即向SW3发送TCN BPDU报文。<br>SW3收到SW2发来的TCN BPDU报文后，会把配置BPDU报文中的Flags的TCA位设置1，然后发送给SW2，告知SW2我已经收到你发送的TCN BPDU。<br>SW3向根桥转发TCN BPDU报文。<br>SW1把配置BPDU报文中的Flags的TC位和TCA位设置为1后发送，通知下游设备我已经收到你发送的TCN BPDU，并通知下游交换机把MAC地址表项的老化时间由默认的300 s修改为Forward Delay的时间（默认为15 s），之后会持续不断的发送TC bit &#x3D; 1的BPDU持续35s。<br>最多等待15 s之后，SW3中的错误MAC地址表项会被自动清除。此后，SW3就能重新开始MAC表项的学习及转发操作。</p>
<p>说明：</p>
<ul>
<li>TCN BPDU报文主要用来向上游设备乃至根桥通知拓扑变化。</li>
<li>TCA标记置位的配置BPDU报文主要是上游设备用来告知下游设备已经知道拓扑变化，通知下游设备停止发送TCN BPDU报文。</li>
<li>置位的TC标记的配置BPDU报文主要是上游设备用来告知下游设备拓扑发生变化，请下游设备直接删除桥MAC地址表项，从而达到快速收敛的目的。</li>
</ul>
<h5 id="感知拓扑改变"><a href="#感知拓扑改变" class="headerlink" title="感知拓扑改变"></a>感知拓扑改变</h5><p>什么情况下STP会感知到拓扑发生了改变呢？有下面四种！</p>
<p>（1）当DP端口进入到Forwarding状态认为拓扑发生了改变。</p>
<p><img src="/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/bian1014293.png" alt="bian1014293"></p>
<p>如上图当S2的g0&#x2F;0&#x2F;3接口(与主机直接相连的接口都是DP端口)经过大概30s进入到Forwarding状态之后，S2的RP端口会立即向根桥发送一个TCN BPDU告知根桥拓扑发生了改变，根桥也会向S2交换机回复一个TC bit &#x3D; 1和TCA bit &#x3D; 1的BPDU，并且根桥会将TC bit &#x3D; 1的报文泛洪到全网交换机，持续35s。 S3的DP接口从shutdown重新进入到Forwarding状态与此情况类似。</p>
<p>（2）根桥的DP失效直接发送TC BPDU。<br><img src="/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/bian272946542.png" alt="bian272946542"></p>
<p> 如上图，当根桥的DP失效之后，S3交换机的RP也随即失效，DP立即成为RP并向S2的AP持续不断的发送TCN BPDU。当S2的AP经过大概30s进入到Forwarding状态之后会向S3的DP回复一个TCA bit &#x3D; 1的BPDU，告知S3我已收到你发送的TCN BPDU并且通过自己的RP将TCN BPDU发送给根桥，根桥也会向S2交换机回复一个TC bit &#x3D; 1和TCA bit &#x3D; 1的BPDU，并且根桥会将TC bit &#x3D; 1的报文泛洪到全网交换机持续35s。</p>
<p>(3)RP失效或者RP进入到Forwarding状态。<br>        S3的RP失效其实等同于根桥的DP失效导致S3的RP失效。S2的RP失效等同于 1.拓扑改变导致MAC地址表错误。<br>(4)非根桥的DP端口失效不认为拓扑发生了改变。<br><img src="/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/bian44841788.png" alt="bian44841788"></p>
<p>如上图两种情况，非根桥的DP失效都不会认为拓扑发生了改变。</p>
<p>总结：<strong>stp发生拓扑变更的条件</strong>：<br>1、处于转发状态或者监听状态的端口过渡到阻塞状态，这个状态通常是链路故障<br>2、处于未启用状态的端口进入转发状态，这个状态通常是增加了新的链路<br>3、交换机从指定端口收到TCNBPDU报文。</p>
<p><strong>stp缺点</strong>：1.收敛速度慢，故障切换时间太长（30-50秒）2.网络中大量主机频繁上下线，会导致TCN BPDU大量发送，导致Mac地址表不稳定</p>
<h1 id="RSTP对STP的改进："><a href="#RSTP对STP的改进：" class="headerlink" title="RSTP对STP的改进："></a>RSTP对STP的改进：</h1><ul>
<li>RSTP对STP的改进：<ul>
<li>通过端口角色的增补，简化了生成树协议的理解及部署；</li>
<li>端口状态的重新划分；</li>
<li>配置BPDU格式的改变，充分利用了STP协议报文中的Flag字段，明确了端口角色；</li>
<li>配置BPDU的处理发生变化；</li>
<li>快速收敛；</li>
<li>增加保护功能。</li>
</ul>
</li>
</ul>
<h5 id="改进点1：端口角色的改进："><a href="#改进点1：端口角色的改进：" class="headerlink" title="改进点1：端口角色的改进："></a>改进点1：端口角色的改进：</h5><p>RSTP的端口角色共有4种：根端口、指定端口、Alternate端口和Backup端口。</p>
<p> 根端口和指定端口的作用同STP中定义，Alternate端口和Backup端口的描述如下：  </p>
<ul>
<li>从配置BPDU报文发送角度来看：<ul>
<li>Alternate端口就是由于学习到其它网桥发送的配置BPDU报文而阻塞的端口</li>
<li>Backup端口就是由于学习到自己发送的配置BPDU报文而阻塞的端口</li>
</ul>
</li>
<li>从用户流量角度来看：<ul>
<li>Alternate端口提供了从指定桥到根的另一条可切换路径，作为根端口的备份端口</li>
<li>Backup端口作为指定端口的备份，提供了另一条从根桥到相应网段的备份通路</li>
</ul>
</li>
</ul>
<blockquote>
<p> 给一个RSTP域内所有端口分配角色的过程就是整个拓扑收敛的过程 </p>
</blockquote>
<h5 id="改进点2：端口状态的改进"><a href="#改进点2：端口状态的改进" class="headerlink" title="改进点2：端口状态的改进"></a>改进点2：端口状态的改进</h5><p>RSTP的状态规范缩减为3种，根据端口是否转发用户流量和学习MAC地址来划分:</p>
<ul>
<li>Discarding状态：不转发用户流量也不学习MAC地址</li>
<li>Learning状态：不转发用户流量但是学习MAC地址</li>
<li>Forwarding状：既转发用户流量又学习MAC地址。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">STP端口状态</th>
<th align="left">RSTP端口状态</th>
<th align="left">端口在拓扑中的角色</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Forwarding</td>
<td align="left">Forwarding</td>
<td align="left">包括根端口、指定端口</td>
</tr>
<tr>
<td align="left">Learning</td>
<td align="left">Learning</td>
<td align="left">包括根端口、指定端口</td>
</tr>
<tr>
<td align="left">Listening</td>
<td align="left">Discarding</td>
<td align="left">包括根端口、指定端口</td>
</tr>
<tr>
<td align="left">Blocking</td>
<td align="left">Discarding</td>
<td align="left">包括Alternate端口、Backup端口</td>
</tr>
<tr>
<td align="left">Disabled</td>
<td align="left">Discarding</td>
<td align="left">包括Disable端口</td>
</tr>
</tbody></table>
<h5 id="改进点3：配置BPDU-RST-BPDU"><a href="#改进点3：配置BPDU-RST-BPDU" class="headerlink" title="改进点3：配置BPDU - RST BPDU"></a>改进点3：配置BPDU - RST BPDU</h5><p><strong>RSTP的配置BPDU充分利用了STP报文中的Flag字段，明确了端口角色</strong></p>
<ul>
<li>除了保证和STP格式基本一致之外，RSTP作了如下变化：<ul>
<li>Type字段：配置BPDU类型不再是0而是2，所以运行STP的设备收到RSTP的配置BPDU时会丢弃</li>
<li>Flag字段：使用了原来保留的中间6位，这样改变的配置BPDU叫做RST BPDU</li>
</ul>
</li>
</ul>
<h6 id="RST-BPDU报文格式："><a href="#RST-BPDU报文格式：" class="headerlink" title="RST BPDU报文格式："></a>RST BPDU报文格式：</h6><h6 id="RST-BPDU与STP配置BPDU报文格式不同点"><a href="#RST-BPDU与STP配置BPDU报文格式不同点" class="headerlink" title="RST BPDU与STP配置BPDU报文格式不同点"></a>RST BPDU与STP配置BPDU报文格式不同点</h6><ul>
<li>BPDU类型，1 Byte，RST BPDU的类型值为0x02。</li>
<li>标志，1 Byte，包括：<ul>
<li>bit 7：TCA，表示拓扑变化确认；</li>
<li>bit 6：Agreement，表示同意，用于P&#x2F;A机制；</li>
<li>bit 5：Forwarding，表示转发状态；</li>
<li>bit 4：Learning，表示学习状态；</li>
<li>bit 3和bit 2：表示端口角色, 00表示未知端口, 01表示替代或备份端口, 10表示根端口, 11表示指定端口</li>
<li>bit 1：Proposal，表示提议，用于P&#x2F;A机制；</li>
<li>bit 0：TC，表示拓扑变化。</li>
</ul>
</li>
</ul>
<h5 id="改进点4：配置BPDU的处理"><a href="#改进点4：配置BPDU的处理" class="headerlink" title="改进点4：配置BPDU的处理"></a>改进点4：配置BPDU的处理</h5><h6 id="RSTP对配置BPDU的发送方式进行了改进"><a href="#RSTP对配置BPDU的发送方式进行了改进" class="headerlink" title="RSTP对配置BPDU的发送方式进行了改进"></a>RSTP对配置BPDU的发送方式进行了改进</h6><blockquote>
<p> 在拓扑稳定后，无论非根桥设备是否接收到根桥传来的配置BPDU报文，非根桥设备仍然按照Hello Time规定的时间间隔发送配置BPDU，该行为完全由每台设备自主进行 </p>
</blockquote>
<h6 id="更短的BPDU超时时间"><a href="#更短的BPDU超时时间" class="headerlink" title="更短的BPDU超时时间"></a>更短的BPDU超时时间</h6><p>如果一个端口在超时时间（即三个周期，超时时间＝Hello Time×3）内没有收到上游设备发送过来的配置BPDU，那么该设备认为与此邻居之间的协商失败</p>
<blockquote>
<p> STP需要先等待一个Max Age </p>
</blockquote>
<h6 id="处理次优BPDU"><a href="#处理次优BPDU" class="headerlink" title="处理次优BPDU"></a>处理次优BPDU</h6><p>当一个端口收到上游的指定桥发来的RST BPDU报文时，该端口会将自身缓存的RST BPDU与收到的RST BPDU进行比较如果该端口缓存的RST BPDU优于收到的RST BPDU，那么该端口会直接丢弃收到的RST BPDU，立即回应自身缓存的RST BPDU，从而加快收敛速度</p>
<ul>
<li>STP：      STP只有指定端口会立即处理次优BPDU，其他端口会忽略次优BPDU，等到Max Age计时器超时后，缓存的次优BPDU才会老化，然后发送自身更优的BPDU，进行新一轮的拓扑收敛。 </li>
<li>RSTP：   RSTP处理次优BPDU报文不再依赖于任何定时器，解决拓扑收敛，同时RSTP的任何端口角色都会处理次优BPDU，从而加快了拓扑收敛。</li>
</ul>
<h5 id="改进点5：快速收敛机制"><a href="#改进点5：快速收敛机制" class="headerlink" title="改进点5：快速收敛机制"></a>改进点5：快速收敛机制</h5><h6 id="快速收敛机制："><a href="#快速收敛机制：" class="headerlink" title="快速收敛机制："></a>快速收敛机制：</h6><ul>
<li>如果网络中一个根端口失效，那么网络中最优的Alternate端口将成为根端口，进入Forwarding状态。因为通过这个Alternate端口连接的网段上必然有个指定端口可以通往根桥 </li>
<li>如果网络中一指定端口失效，那么网络中最优的Backup端口将成为指定端口，进入Forwarding状态。因为Backup端口作为指定端口的备份，提供了另一条从根桥到相应网段的备份通路</li>
</ul>
<p> ##### 边缘端口 (Edge Port)机制：  </p>
<blockquote>
<p> 在RSTP里面，如果某一个端口位于整个网络的边缘，即不再与其他交换设备连接，而是直接与终端设备直连，这种端口可以设置为边缘端口 </p>
</blockquote>
<p>边缘端口不参与RSTP计算，可以由Discarding直接进入Forwarding状态，同时边缘端口的UP和Down，不会引起网络拓扑的变动</p>
<p>但是一旦边缘端口收到配置BPDU，就丧失了边缘端口属性，成为普通STP端口，并重新进行生成树计算，从而引起网络震荡</p>
<h6 id="Proposal-Agreement机制："><a href="#Proposal-Agreement机制：" class="headerlink" title="Proposal&#x2F;Agreement机制："></a>Proposal&#x2F;Agreement机制：</h6><p>简称P&#x2F;A机制，RSTP通过P&#x2F;A机制加快了上游端口进入Forwarding状态的速度。 当一个端口被选举成为指定端口之后,会先进入Discarding状态，再通过P&#x2F;A机制快速进入Forwarding状态</p>
<p>事实上对于STP，指定端口的选择可以很快完成，主要的速度瓶颈在于：为了避免环路，必须等待足够长的时间，使全网的端口状态全部确定，也就是说必须要等待至少一个Forward Delay所有端口才能进行转发。 而RSTP的主要目的就是消除这个瓶颈，通过阻塞自己的非根端口来保证不会出现环路。而使用P&#x2F;A机制加快了上游端口进入Forwarding状态的速度。</p>
<h5 id="改进点6：拓扑变更机制"><a href="#改进点6：拓扑变更机制" class="headerlink" title="改进点6：拓扑变更机制"></a>改进点6：拓扑变更机制</h5><p>在RSTP中检测拓扑是否发生变化只有一个标准：一个非边缘端口迁移到Forwarding状态。</p>
<p>一旦检测到拓扑发生变化，将进行如下处理： 为本交换设备的所有非边缘指定端口和根端口启动一个TC While Timer，该计时器值是Hello Time的两倍。在这个时间内，清空状态发生变化的端口上学习到的MAC地址。 同时，由非边缘指定端口和根端口向外发送RST BPDU，其中TC置位。一旦TC While Timer超时，则停止发送RST BPDU。 其他交换设备接收到RST BPDU后，清空所有端口（除了收到RST BPDU的端口和边缘端口）学习到MAC地址，然后也为自己所有的非边缘指定端口和根端口启动TC While Timer，重复上述过程。 如此，网络中就会产生RST BPDU的泛洪。</p>
<h4 id="RSTP与STP的兼容"><a href="#RSTP与STP的兼容" class="headerlink" title="RSTP与STP的兼容"></a>RSTP与STP的兼容</h4><blockquote>
<p> RSTP可以兼容STP：RSTP可以和STP互操作，但是此时会丧失快速收敛等RSTP优势。 </p>
</blockquote>
<p>当一个网段里既有运行STP的交换设备又有运行RSTP的交换设备，STP交换设备会忽略RSTP的BPDU</p>
<p>运行RSTP的交换设备在某端口上接收到运行STP的交换设备发出的配置BPDU，在两个Hello Time时间之后，便把自己的端口转换到STP工作模式，发送配置BPDU，从而实现了互操作。</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>stp拓扑变更</tag>
      </tags>
  </entry>
  <entry>
    <title>USG5500防火墙基础实验</title>
    <url>/2023/12/08/USG5500%E9%98%B2%E7%81%AB%E5%A2%99%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p><img src="/2023/12/08/USG5500%E9%98%B2%E7%81%AB%E5%A2%99%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/usg5500tuopi11.png" alt="usg5500tuopi11"></p>
<p>1、本实验中的防火墙为USG5500系列防火墙； </p>
<p>2、 防火墙三个接口的IP地址按照上图所示进行配置；将这三个接口划入相应的安全域； </p>
<p>3、配置防火墙的域间包过滤策略，使得PC1能够主动访问PC2，但是PC2无法主动访问PC1；PC2能够主动访问WebServer的WEB服务。</p>
<p>防火墙配置：</p>
<p>[FW] interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p>[FW-GigabitEthernet0&#x2F;0&#x2F;1] ip address 192.168.1.254 24 </p>
<p>[FW] interface GigabitEthernet0&#x2F;0&#x2F;2 </p>
<p>[FW-GigabitEthernet0&#x2F;0&#x2F;2] ip address 172.16.1.254 24 </p>
<p>[FW] interface GigabitEthernet0&#x2F;0&#x2F;3 </p>
<p>[FW-GigabitEthernet0&#x2F;0&#x2F;3] ip address 10.1.1.254 24 </p>
<p>将接口添加到相应的安全区域：</p>
<p>[FW] firewall zone trust </p>
<p>[FW-zone-trust] add interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p>[FW] firewall zone dmz </p>
<p>[FW-zone-dmz] add interface GigabitEthernet0&#x2F;0&#x2F;2 </p>
<p>[FW] firewall zone untrust </p>
<p>[FW-zone-untrust] add interface GigabitEthernet0&#x2F;0&#x2F;3 </p>
<p>配置域间策略，使得trust域的192.168.1.0&#x2F;24网段用户能够访问untrust区域的10.1.1.0&#x2F;24网段</p>
<p>[FW] policy interzone trust untrust outbound </p>
<p>[FW-policy-interzone-trust-untrust-outbound] policy 10 </p>
<p>[FW-policy-interzone-trust-untrust-outbound-10] policy destination 10.1.1.0 </p>
<p>0.0.0.255 </p>
<p>[FW-policy-interzone-trust-untrust-outbound-10] policy source 192.168.1.0 </p>
<p>0.0.0.255 </p>
<p>[FW-policy-interzone-trust-untrust-outbound-10] action permit </p>
<p>配置域间策略，使得untrust可以访问server</p>
<p>[FW] policy interzone dmz untrust inbound </p>
<p>[FW-policy-interzone-dmz-untrust-inbound] policy 10 </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] policy source 10.1.1.0 0.0.0.255 </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] policy destination 172.16.1.1 0 </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] policy service service-set http </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] action permit </p>
<p>完成上述配置后，PC1即可主动发起访问PC2，而PC2无法主动访问PC1；另外，PC2能够访问WebServer的HTTP服务</p>
<p>（ping不同，需要再配置一条允许icmp协议通过）</p>
<p>通过命令display zone，可以查看防火墙的安全区域、安全等级，以及每个安全区域下的接口.</p>
<p>使用<strong>display firewall packet-filter default</strong> 命令，能查看防火墙的缺省安全策略。当数据包经过防火墙且从一个安全域试图访问另一个安全域时，防火墙会根据数据包的流向首先检查用户定义的policy interzone，如果没有自定义的policy interone，则会看根据防火墙的缺省安全策略进行处理。例如从上面的显示中，我们可以看到local-trust的inbound及outbound都是permit，因此即使我们没有显式的配置local及trust安全区域的区域间策略，但是由于默认的策略就是放行，所以 trust区域的用户可以直接ping通防火墙的接口。</p>
<p>如果要让防火墙默认放行所有域间的流量，可以使用：firewall packet-filter default permit all命令，值得注意的是，在网络正式投入现网使用之前，此命令必须关闭（firewall packet-filter default deny all），针对需要放行的流量，需通过policy interzone的配置来放行，而不能鲁莽地将所有流量统统放行。</p>
<p>使用display policy命令，能查看我们定义的区域间安全策略，例如： </p>
<p>[FW] display policy interzone trust untrust outbound </p>
<h1 id="USG5500-nat实验"><a href="#USG5500-nat实验" class="headerlink" title="USG5500 nat实验"></a>USG5500 nat实验</h1><p><img src="/2023/12/08/USG5500%E9%98%B2%E7%81%AB%E5%A2%99%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/usg5500naty.png" alt="usg5500naty"></p>
<p>防火墙FW的配置如下：</p>
<p>[FW] interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p>[FW-GigabitEthernet0&#x2F;0&#x2F;1] ip address 192.168.1.254 24 </p>
<p>[FW] interface GigabitEthernet0&#x2F;0&#x2F;2 </p>
<p>[FW-GigabitEthernet0&#x2F;0&#x2F;2] ip address 172.16.1.254 24 </p>
<p>[FW] interface GigabitEthernet0&#x2F;0&#x2F;3 </p>
<p>[FW-GigabitEthernet0&#x2F;0&#x2F;3] ip address 200.1.1.1 24 </p>
<p>向安全域中添加接口</p>
<p>[FW] firewall zone trust </p>
<p>[FW-zone-trust] add interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p>[FW] firewall zone dmz </p>
<p>[FW-zone-dmz] add interface GigabitEthernet0&#x2F;0&#x2F;2 </p>
<p>[FW] firewall zone untrust </p>
<p>[FW-zone-untrust] add interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>配置域间包过滤策略，使得trust区域的192.168.1.0&#x2F;24网段用户能够访问Internet：</p>
<p>[FW] policy interzone trust untrust outbound </p>
<p>[FW-policy-interzone-trust-untrust-outbound] policy 10 </p>
<p>[FW-policy-interzone-trust-untrust-outbound-10] policy source 192.168.1.0 </p>
<p>0.0.0.255 </p>
<p>[FW-policy-interzone-trust-untrust-outbound-10] action permit </p>
<p>上述配置虽然放通了192.168.1.0&#x2F;24访问Internet的流量，但是由于192.168.1.0&#x2F;24是私有IP地址，不能直接进入公网，因此为了让这部分用户能够访问公网，还必须部署NAT源地址转换</p>
<p>[FW] nat address-group 1 200.1.1.10 200.1.1.20 </p>
<p>定义NAT地址池，该地址池使用的公网地址区间是200.1.1.10到200.1.1.20</p>
<p>[FW] nat-policy interzone trust untrust outbound </p>
<p>配置NAT策略</p>
<p>[FW-nat-policy-interzone-trust-untrust-outbound] policy 10 </p>
<p>[FW-nat-policy-interzone-trust-untrust-outbound-10] policy source 192.168.1.0  0.0.0.255 </p>
<p>[FW-nat-policy-interzone-trust-untrust-outbound-10] action source-nat &#x2F;&#x2F;对匹配的流量执行源地址转换</p>
<p>[FW-nat-policy-interzone-trust-untrust-outbound-10] address-group 1 &#x2F;&#x2F;关联nat地址池1</p>
<p>完成上述配置后，内网用户PC1即可访问公网用户PC2。接下来继续配置防火墙，使得公网用户PC2能够访问WebServer。 </p>
<p>配置域间包过滤策略，使得untrust区域的Internet用户能够访问DMZ区域的web服务</p>
<p>[FW] policy interzone dmz untrust inbound </p>
<p>[FW-policy-interzone-dmz-untrust-inbound] policy 10 </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] policy destination 172.16.1.1 0 </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] policy service service-set http </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] action permit </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] quit </p>
<p>[FW-policy-interzone-dmz-untrust-inbound] quit </p>
<p>完成上述配置后，Internet用户是依然无法访问WebServer的，因为WebServer是私有IP地址，因此还需要配置NAT server，将DMZ域内的WebServer映射到公网。</p>
<p>下面的命令，将内部IP地址172.16.1.1的80端口映射到了公网地址200.1.1.21的80端口，这样一来，当公网用户访问200.1.1.21的80端口服务时，实际上访问的就是内部服务器172.16.1.1的80端口。</p>
<p>[FW] nat server zone untrust protocol tcp global 200.1.1.21 80 inside 172.16.1.1 </p>
<p>80 </p>
<p>完成上述配置后，PC2即可使用目的地址200.1.1.21来访问WebServer。 </p>
<p>当PC1 ping PC2时，能够在FW上能看到如下会话： </p>
<p><FW>display firewall session table </FW></p>
<p>Current Total Sessions : 5 </p>
<p>icmp VPN:public –&gt; public 192.168.1.1:40373[<strong>200.1.1.15:2048</strong>]–&gt;200.1.1.2:2048 </p>
<p>icmp VPN:public –&gt; public 192.168.1.1:40885[200.1.1.15:2049]–&gt;200.1.1.2:2048</p>
<p>留意到中括号内的IP地址，便是被NAT转换后的IP地址。 </p>
<p>当PC2访问Server的WEB服务时，在FW上能看到如下会话： </p>
<p>[FW]display firewall session table </p>
<p>Current Total Sessions : 1 </p>
<p>http VPN:public –&gt; public 200.1.1.2:2055–&gt;200.1.1.21:80[<strong>172.16.1.1:80</strong>] </p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>USG5500</tag>
        <tag>防火墙nat</tag>
      </tags>
  </entry>
  <entry>
    <title>VRF</title>
    <url>/2024/06/23/VRF/</url>
    <content><![CDATA[<p><img src="/2024/06/23/VRF/20190301110350669.png" alt="20190301110350669"></p>
<p><img src="/2024/06/23/VRF/20190301110855304.png" alt="20190301110855304"></p>
<p>假设PC1与R2这一侧的网络属于一个独立的业务；PC2与R3这一侧的网络属于另一个独立的业务，由于设备资源有限或者其他方面的原因，这两个独立的业务的相关节点连接在R1上，也就是同一台设备上。那么在完成相关配置后，R1的路由表如上图所示。<br>现在如果PC1要发一个数据包到2.2.2.2，那么这个数据包在到达R1后，R1就会去查看自己的路由表，发现有一条2.2.2.0&#x2F;24的路由匹配，因此将这个IP包从GE0&#x2F;0&#x2F;2口转发给192.168.100.2。这是没有问题的，然而如果PC1要访问3.3.3.0&#x2F;24网络呢？也是无压力的，因为数据包到达R1后，她照样查找路由表结果发现有匹配的路由，因此将数据包转给R3。但是实际上，从业务的角度考虑，我们禁止PC1访问3.3.3.0&#x2F;24网络。<br>那么怎么办？</p>
<p><img src="/2024/06/23/VRF/20190301110351539.png" alt="20190301110351539"></p>
<p><img src="/2024/06/23/VRF/2019030111115184.png" alt="2019030111115184"></p>
<p>现在，我们在R1上创建两个VRF：VRF1及VRF2，创建完成后，我们可以理解为，拥有了两台虚拟路由器。当然，现在这两台虚拟路由器上啥也没有。<br>接下去我们将GE0&#x2F;0&#x2F;1口及GE0&#x2F;0&#x2F;2口绑定到VRF1；将GE0&#x2F;0&#x2F;3及GE0&#x2F;0&#x2F;4口绑定到VRF2。如此一来这两台虚拟路由器就各自拥有了两个物理接口。值得注意的是，这两台虚拟路由器是虽然都在同一台物理设备上，但是却是隔离的，他们将有自己的接口，自己的路由表，自己的ARP表等等相关的内容。我们的环境就变成有点像这样：</p>
<p><img src="/2024/06/23/VRF/20190301111226761.png" alt="20190301111226761"></p>
<p>我们看到，VRF1及VRF2有了自己的接口，也有了自己的路由表。并且相互之间是隔离的。<br>现在PC1要发送一个数据包到2.2.2.2，R1从接口GE0&#x2F;0&#x2F;1收到了这个数据包，由于此时GE0&#x2F;0&#x2F;1已经绑定到了VRF1，因此在执行目的IP的路由查找的时候，查的是VRF1的路由表，查找到匹配的路由条目后，间个数据包从其指示的GE0&#x2F;0&#x2F;1口转发给下一跳192.168.100.2。</p>
<p>那么如果PC1要访问3.3.3.3呢？数据包发到了R1，R1从接口GE0&#x2F;0&#x2F;1收到了这个数据包，于是它在做路由查找的时候，查的仍然是VRF1的路由表。经过查表后，它发现并无匹配的条目，因此将数据包丢弃。</p>
<p><img src="/2024/06/23/VRF/20190301111315435.png" alt="20190301111315435"></p>
<p>实验</p>
<img src="/2024/06/23/VRF/QQ截图20240623181526.png" alt="QQ截图20240623181526" style="zoom:80%;">

<p>如图，R2属于VPN实例aa，R3属于VPN实例bb，要求pc1可以访问R2，不能访问R3。PC2可以访问R3，不能访问R2.</p>
<p>R1下做单臂路由，创建VPN实例aa和bb，子接口分别绑定相应的VPN实例。g0&#x2F;0&#x2F;0绑定vpn实例aa，g0&#x2F;0&#x2F;1绑定vpn实例bb。</p>
<p>S1创建vlan，划分接口：略</p>
<p>注意：接口绑定VPN实例后，ip地址的配置会被移除，需要重新配置</p>
<p>创建vpn实例：</p>
<p>ip vpn-instance aa</p>
<p> ipv4-family #使能ipv4地址簇</p>
<p>接口绑定：ip binding vpn-instance aa</p>
<p>查看vpn路由表：dis ip routing-table vpn-instance aa</p>
<p>静态路由：ip route-static vpn-instance aa 2.2.2.2 32 192.168.10.1 </p>
<p>ping命令：ping -vpn-instance aa 192.168.10.1</p>
<p>R2上添加回程路由：略</p>
<p>至此，PC1可以ping通R2</p>
<p>R1上创建ospf：ospf 1 router-id 1.1.1.1 vpn-instance bb</p>
<p>宣告网段：略</p>
<p>R3上ospf宣告3.3.3.3</p>
<p>pc2ping通3.3.3.3</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>VRF</tag>
      </tags>
  </entry>
  <entry>
    <title>VRRP</title>
    <url>/2024/05/25/VRRP/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>虚拟路由冗余协议VRRP（Virtual Router Redundancy Protocol）通过把几台路由设备联合组成一台虚拟的路由设备，将虚拟路由设备的IP地址作为用户的默认网关实现与外部网络通信。当网关设备发生故障时，VRRP机制能够选举新的网关设备承担数据流量，从而保障网络的可靠通信。</p>
<p>随着网络的快速普及和相关应用的日益深入，各种增值业务（如IPTV、视频会议等）已经开始广泛部署，基础网络的可靠性日益成为用户关注的焦点，能够保证网络传输不中断对于终端用户非常重要。</p>
<p>通常，同一网段内的所有主机上都设置一条相同的、以网关为下一跳的缺省路由。主机发往其他网段的报文将通过缺省路由发往网关，再由网关进行转发，从而实现主机与外部网络的通信。当网关发生故障时，本网段内所有以网关为缺省路由的主机将无法与外部网络通信。增加出口网关是提高系统可靠性的常见方法，此时如何在多个出口之间进行选路就成为需要解决的问题。</p>
<p>VRRP的出现很好的解决了这个问题。VRRP能够在不改变组网的情况下，采用将多台路由设备组成一个虚拟路由器，通过配置虚拟路由器的IP地址为默认网关，实现默认网关的备份。当网关设备发生故障时，VRRP机制能够选举新的网关设备承担数据流量，从而保障网络的可靠通信。</p>
<img src="/2024/05/25/VRRP/QQ截图20240525184700.png" alt="QQ截图20240525184700" style="zoom:67%;">

<ul>
<li>VRRP路由器（VRRP Router）：运行VRRP协议的设备，它可能属于一个或多个虚拟路由器，如RouterA和RouterB。</li>
<li>虚拟路由器（Virtual Router）：又称VRRP备份组，由一个Master设备和多个Backup设备组成，被当作一个共享局域网内主机的缺省网关。如RouterA和RouterB共同组成了一个虚拟路由器。</li>
<li>Master路由器（Virtual Router Master）：承担转发报文任务的VRRP设备，如RouterA。</li>
<li>Backup路由器（Virtual Router Backup）：一组没有承担转发任务的VRRP设备，当Master设备出现故障时，它们将通过竞选成为新的Master设备，如RouterB。</li>
<li>VRID：虚拟路由器的标识。如RouterA和RouterB组成的虚拟路由器的VRID为1。</li>
<li>虚拟IP地址(Virtual IP Address)：虚拟路由器的IP地址，一个虚拟路由器可以有一个或多个IP地址，由用户配置。如RouterA和RouterB组成的虚拟路由器的虚拟IP地址为10.1.1.10&#x2F;24。</li>
<li><strong>IP地址拥有者（</strong>IP Address Owner）：如果一个VRRP设备将虚拟路由器IP地址作为真实的接口地址，则该设备被称为IP地址拥有者。如果IP地址拥有者是可用的，通常它将成为Master。如RouterA，其接口的IP地址与虚拟路由器的IP地址相同，均为10.1.1.10&#x2F;24，因此它是这个VRRP备份组的IP地址拥有者。</li>
<li>虚拟MAC地址（Virtual MAC Address）：虚拟路由器根据虚拟路由器ID生成的MAC地址。一个虚拟路由器拥有一个虚拟MAC地址，格式为：<strong>00-00-5E-00-01</strong>-{VRID}(VRRP for IPv4)；00-00-5E-00-02-{VRID}(VRRP for IPv6)。当虚拟路由器回应ARP请求时，使用虚拟MAC地址，而不是接口的真实MAC地址。如RouterA和RouterB组成的虚拟路由器的VRID为1，因此这个VRRP备份组的MAC地址为00-00-5E-00-01-01。</li>
</ul>
<p>0000-5e00-01xx   其中xx是vrid</p>
<h1 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h1><p>vrrp只有一种报文，Advertisement报文，基于组播方式发送，目的组播地址为224.0.0.18，ip协议号：112</p>
<img src="/2024/05/25/VRRP/QQ截图20240525185133.png" alt="QQ截图20240525185133" style="zoom:67%;">

<table>
<thead>
<tr>
<th>报文字段</th>
<th>含义</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>VRRPv2</td>
<td>VRRPv3</td>
<td></td>
</tr>
<tr>
<td>Version</td>
<td>VRRP协议版本号，取值为2。</td>
<td>VRRP协议版本号，取值为3。</td>
</tr>
<tr>
<td>Type</td>
<td>VRRP通告报文的类型，取值为1，表示Advertisement。</td>
<td>VRRP通告报文的类型，取值为1，表示Advertisement。</td>
</tr>
<tr>
<td>Virtual Rtr ID（VRID）</td>
<td>虚拟路由器ID，取值范围是1～255。</td>
<td>虚拟路由器ID，取值范围是1～255。</td>
</tr>
<tr>
<td>Priority</td>
<td>Master设备在备份组中的优先级，取值范围是0～255。0表示设备停止参与VRRP备份组，用来使备份设备尽快成为Master设备，而不必等到计时器超时；255则保留给IP地址拥有者。缺省值是100。</td>
<td>Master设备在备份组中的优先级，取值范围是0～255。0表示设备停止参与VRRP备份组，用来使备份设备尽快成为Master设备，而不必等到计时器超时；255则保留给IP地址拥有者。缺省值是100。</td>
</tr>
<tr>
<td>Count IP Addrs&#x2F;Count IPvX Addr</td>
<td>备份组中虚拟IPv4地址的个数。</td>
<td>备份组中虚拟IPv4或虚拟IPv6地址的个数。</td>
</tr>
<tr>
<td>Auth Type</td>
<td>VRRP报文的认证类型。协议中指定了3种类型：0：Non Authentication，表示无认证。1：Simple Text Password，表示明文认证方式。2：IP Authentication Header，表示MD5认证方式。</td>
<td>-</td>
</tr>
<tr>
<td>Adver Int&#x2F;Max Adver Int</td>
<td>VRRP通告报文的发送时间间隔，单位是秒，缺省值为1秒。</td>
<td>VRRP通告报文的发送时间间隔，单位是厘秒，缺省值为100厘秒（1秒）。</td>
</tr>
<tr>
<td>Checksum</td>
<td>16位校验和，用于检测VRRP报文中的数据破坏情况。</td>
<td>16位校验和，用于检测VRRP报文中的数据破坏情况。</td>
</tr>
<tr>
<td>IP Address&#x2F;IPvX Address(es)</td>
<td>VRRP备份组的虚拟IPv4地址，所包含的地址数定义在Count IP Addrs字段。</td>
<td>VRRP备份组的虚拟IPv4地址或者虚拟IPv6地址，所包含的地址数定义在Count IPvX Addrs字段。</td>
</tr>
<tr>
<td>Authentication Data</td>
<td>VRRP报文的认证字。目前只有明文认证和MD5认证才用到该部分，对于其它认证方式，一律填0。</td>
<td>-</td>
</tr>
<tr>
<td>rsvd</td>
<td>-</td>
<td>VRRP报文的保留字段，必须设置为0。</td>
</tr>
</tbody></table>
<ul>
<li><p>支持的网络类型不同。VRRPv3适用于IPv4和IPv6两种网络，而VRRPv2仅适用于IPv4网络。</p>
</li>
<li><p>认证功能不同。VRRPv3不支持认证功能，而VRRPv2支持认证功能。</p>
</li>
<li><p>发送通告报文的时间间隔的单位不同。VRRPv3支持的是厘秒级，而VRRPv2支持的是秒级。</p>
</li>
</ul>
<h1 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h1><p><img src="/2024/05/25/VRRP/QQ%E6%88%AA%E5%9B%BE20240525185814.png" alt="QQ截图20240525185814"></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Initialize</td>
<td>该状态为VRRP不可用状态，在此状态时设备不会对VRRP报文做任何处理。通常刚配置VRRP时或设备检测到故障时会进入Initialize状态。收到接口Up的消息后，如果设备的优先级为255，则直接成为Master设备；如果设备的优先级小于255，则会先切换至Backup状态。</td>
</tr>
<tr>
<td>Master</td>
<td>当VRRP设备处于Master状态时，它将会做下列工作：定时（Advertisement Interval）发送VRRP通告报文。以虚拟MAC地址响应对虚拟IP地址的ARP请求。转发目的MAC地址为虚拟MAC地址的IP报文。如果它是这个虚拟IP地址的拥有者，则接收目的IP地址为这个虚拟IP地址的IP报文。否则，丢弃这个IP报文。如果收到比自己优先级大的报文，立即成为Backup。如果收到与自己优先级相等的VRRP报文且本地接口IP地址小于对端接口IP，立即成为Backup。</td>
</tr>
<tr>
<td>Backup</td>
<td>当VRRP设备处于Backup状态时，它将会做下列工作：接收Master设备发送的VRRP通告报文，判断Master设备的状态是否正常。对虚拟IP地址的ARP请求，不做响应。丢弃目的IP地址为虚拟IP地址的IP报文。如果收到优先级和自己相同或者比自己大的报文，则重置Master_Down_Interval定时器，不进一步比较IP地址。Master_Down_Interval定时器：Backup设备在该定时器超时后仍未收到通告报文，则会转换为Master状态。计算公式如下：<em><em>Master_Down_Interval&#x3D;(3</em> Advertisement_Interval) + Skew_time。其中，Skew_Time&#x3D;(256–Priority)&#x2F;256。</em>*如果收到比自己优先级小的报文且该报文优先级是0时，定时器时间设置为Skew_time（偏移时间），如果该报文优先级不是0，丢弃报文，立刻成为Master。</td>
</tr>
</tbody></table>
<h1 id="VRRP工作过程"><a href="#VRRP工作过程" class="headerlink" title="VRRP工作过程"></a>VRRP工作过程</h1><ol>
<li>VRRP备份组中的设备根据<strong>优先级</strong>选举出Master。Master设备通过发送免费ARP报文，将虚拟MAC地址通知给与它连接的设备或者主机，从而承担报文转发任务。</li>
<li>Master设备周期性向备份组内所有Backup设备发送VRRP通告报文，以公布其配置信息（优先级等）和工作状况。</li>
<li>如果Master设备出现故障，VRRP备份组中的Backup设备将根据优先级重新选举新的Master。</li>
<li>VRRP备份组状态切换时，Master设备由一台设备切换为另外一台设备，新的Master设备会立即发送携带虚拟路由器的虚拟MAC地址和虚拟IP地址信息的免费ARP报文，刷新与它连接的主机或设备中的MAC表项，从而把用户流量引到新的Master设备上来，整个过程对用户完全透明。</li>
<li>原Master设备故障恢复时，若该设备为IP地址拥有者（优先级为255），将直接切换至Master状态。若该设备优先级小于255，将首先切换至Backup状态，且其优先级恢复为故障前配置的优先级。</li>
<li>Backup设备的优先级高于Master设备时，由Backup设备的工作方式（抢占方式和非抢占方式）决定是否重新选举Master。<ul>
<li><strong>抢占模式</strong>（默认）：在抢占模式下，如果Backup设备的优先级比当前Master设备的优先级高，则主动将自己切换成Master。</li>
<li>非抢占模式：在非抢占模式下，只要Master设备没有出现故障，Backup设备即使随后被配置了更高的优先级也不会成为Master设备。</li>
</ul>
</li>
</ol>
<p>由此可见，为了保证Master设备和Backup设备能够协调工作，VRRP需要实现以下功能：</p>
<ul>
<li>Master设备的选举。</li>
<li>Master设备状态的通告。</li>
</ul>
<p>下面将从上述两个方面详细介绍VRRP的工作过程。</p>
<ul>
<li><p><strong>Master设备的选举</strong></p>
<p>VRRP根据优先级来确定虚拟路由器中每台设备的角色（Master设备或Backup设备）。优先级越高，则越有可能成为Master设备。</p>
<p>初始创建的VRRP设备工作在Initialize状态，收到接口Up的消息后，如果设备的优先级为255，则直接成为Master设备；如果设备的优先级小于255，则会先切换至Backup状态，待Master_Down_Interval定时器超时后再切换至Master状态。首先切换至Master状态的VRRP设备通过VRRP通告报文的交互获知虚拟设备中其他成员的优先级，进行Master的选举：</p>
<ul>
<li>如果VRRP报文中Master设备的优先级高于或等于自己的优先级，则Backup设备保持Backup状态。</li>
<li>如果VRRP报文中Master设备的优先级低于自己的优先级，采用抢占方式的Backup设备将切换至Master状态，采用非抢占方式的Backup设备仍保持Backup状态。</li>
<li>如果多个VRRP设备同时切换到Master状态，通过VRRP通告报文的交互进行协商后，优先级较低的VRRP设备将切换成Backup状态，优先级最高的VRRP设备成为最终的Master设备；优先级相同时，VRRP设备上VRRP备份组所在接口主IP地址较大的成为Master设备。</li>
<li>如果创建的VRRP设备为IP地址拥有者，收到接口Up的消息后，将会直接切换至Master状态。</li>
</ul>
</li>
<li><p><strong>Master设备状态的通告</strong></p>
<p>Master设备周期性地发送VRRP通告报文，在VRRP备份组中公布其配置信息（优先级等）和工作状况。Backup设备通过接收到VRRP报文的情况来判断Master设备是否工作正常。</p>
<ul>
<li>当Master设备主动放弃Master地位（如Master设备退出备份组）时，会发送优先级为0的通告报文，用来使Backup设备快速切换成Master设备，而不用等到Master_Down_Interval定时器超时。这个切换的时间称为Skew time，计算方式为：（256－Backup设备的优先级）&#x2F;256，单位为秒。</li>
<li>当Master设备发生网络故障而不能发送通告报文的时候，Backup设备并不能立即知道其工作状况。等到Master_Down_Interval定时器超时后，才会认为Master设备无法正常工作，从而将状态切换为Master。其中，Master_Down_Interval定时器取值为：3×Advertisement_Interval＋Skew_time，单位为秒。</li>
</ul>
</li>
</ul>
<h1 id="VRRP负载分担"><a href="#VRRP负载分担" class="headerlink" title="VRRP负载分担"></a>VRRP负载分担</h1><p>负载分担是指多个VRRP备份组同时承担业务，VRRP负载分担与VRRP主备备份的基本原理和报文协商过程都是相同的。同样对于每一个VRRP备份组，都包含一个Master设备和若干Backup设备。与主备备份方式不同点在于：负载分担方式需要建立多个VRRP备份组，各备份组的Master设备可以不同；同一台VRRP设备可以加入多个备份组，在不同的备份组中具有不同的优先级。</p>
<h4 id><a href="#" class="headerlink" title></a><img src="/2024/05/25/VRRP/QQ截图20240525190602.png" alt="QQ截图20240525190602" style="zoom:67%;"></h4><p>配置两个VRRP备份组。</p>
<ul>
<li>VRRP备份组1：RouterA为Master设备，RouterB为Backup设备。</li>
<li>VRRP备份组2：RouterB为Master设备，RouterA为Backup设备。</li>
</ul>
<p>一部分用户将VRRP备份组1作为网关，另一部分用户将VRRP备份组2作为网关。这样既可实现对业务流量的负载分担，同时，也起到了相互备份的作用。</p>
<h1 id="VRRP监视上行端口"><a href="#VRRP监视上行端口" class="headerlink" title="VRRP监视上行端口"></a>VRRP监视上行端口</h1><img src="/2024/05/25/VRRP/QQ截图20240525190751.png" alt="QQ截图20240525190751" style="zoom:67%;">

<p>命令：上行接口视图，vrrp vrid 1 track interface  g 0&#x2F;0&#x2F;1 increased(或者reduced) 30（增加或减少优先级）</p>
<p>VRRP备份组只能感知其所在接口状态的变化，当VRRP设备上行接口或直连链路发生故障时，VRRP无法感知，此时会引起业务流量中断。通过部署VRRP与接口状态联动监视上行接口可以有效地解决上述问题，当Master设备的上行接口或直连链路发生故障时，通过调整自身优先级，触发主备切换，确保流量正常转发。</p>
<p>VRRP可以通过Increased和Reduced方式来监视接口状态：</p>
<ul>
<li>如果VRRP设备上配置以Increased方式监视一个接口，当被监视的接口状态变成Down后，该VRRP设备的优先级增加指定值。</li>
<li>如果VRRP设备上配置以Reduced方式监视一个接口，当被监视的接口状态变为Down后，该VRRP设备的优先级降低指定值。</li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>VRRP</tag>
      </tags>
  </entry>
  <entry>
    <title>VRRP基础实验</title>
    <url>/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>设备连接方式如图所示，网络中存在VLAN10、20，每个VLAN中部署一组VRRP，使用与VLAN ID相同的数值作为VRID，将S1配置为VLAN10的VRRP Master，将S2配置为VLAN20的VRRP Master。</p>
<p>同时在S1、S2、S3上部署MSTP，创建Instance 1、2，将VLAN10映射到MSTI 1、VLAN20映射到MSTI 2，将S1配置为MSTI 1的主根桥、MSTI 2的备份根桥，而将S2配置为MSTI 1的备份根桥、MSTI 2的主根桥。</p>
<p>VLANIF接口地址使用10.0.x.y&#x2F;24，其中x为VRID组号，y为设备编号，VRIP使用10.0.x.254&#x2F;24。</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/vrrptuopu29210315.png" alt="vrrptuopu29210315"></p>
<p>#创建VLAN</p>
<p>[S1]vlan batch 10 20</p>
<p>[S2]vlan batch 10 20 </p>
<p>[S3]vlan batch 10 20 </p>
<p>[S4]vlan batch 10 20 </p>
<p>#将所有互联接口配置为Trunk接口，放通对应VLAN</p>
<p>略</p>
<p>#修改STP模式为MSTP</p>
<p>[S1]stp mode mstp</p>
<p>[S2]stp mode mstp</p>
<p>[S3]stp mode mstp</p>
<p>#配置MSTP</p>
<p>[S1]stp region-configuration</p>
<p>[S1-mst-region] region-name hcip</p>
<p>[S1-mst-region] revision-level 1</p>
<p>[S1-mst-region] instance 1 vlan 10 </p>
<p>[S1-mst-region] instance 2 vlan 20</p>
<p>[S1-mst-region] active region-configuration</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S1-mst-region] quit</p>
<p>[S2]stp region-configuration</p>
<p>[S2-mst-region] region-name hcip</p>
<p>[S2-mst-region] revision-level 1</p>
<p>[S2-mst-region] instance 1 vlan 10 </p>
<p>[S2-mst-region] instance 2 vlan 20 </p>
<p>[S2-mst-region] active region-configuration</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S2-mst-region] quit</p>
<p>[S3]stp region-configuration</p>
<p>[S3-mst-region] region-name hcip</p>
<p>[S3-mst-region] revision-level 1</p>
<p>[S3-mst-region] instance 1 vlan 10 </p>
<p>[S3-mst-region] instance 2 vlan 20 </p>
<p>[S3-mst-region] active region-configuration</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S3-mst-region] quit</p>
<p>#配置SW1为MSTI1的根桥、MSTI2的备份根桥</p>
<p>[S1]stp instance 1 root primary </p>
<p>[S1]stp instance 2 root secondary</p>
<p>#配置SW2为MSTI2的根桥、MSTI1的备份根桥</p>
<p>[S2]stp instance 1 root secondary </p>
<p>[S2]stp instance 2 root primary</p>
<p>#在S1上查看MSTI1的状态和统计信息摘要</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/shili1129211309.png" alt="shili1129211309"></p>
<p>S1上所有接口都是指定接口，S1为MSTI1的根桥。</p>
<p>#在S2上查看MSTI2的状态和统计信息摘要</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/shili229211338.png" alt="shili229211338"></p>
<p>S2上所有接口都是指定接口，S2为MSTI1的根桥。</p>
<h2 id="VRRP基础配置"><a href="#VRRP基础配置" class="headerlink" title="VRRP基础配置"></a>VRRP基础配置</h2><p>在S1、S2均创建VLANIF 10、20，分别加入VRRP组10、20，手动配置VRRP优先级，使得S1的VLAN10成为VRRP Master、S2的VLAN20成为VRRP Master。</p>
<p>#创建VLANIF</p>
<p>[S1]interface Vlanif10</p>
<p>[S1-Vlanif10] ip address 10.0.10.1 255.255.255.0</p>
<p>[S1-Vlanif10] quit</p>
<p>[S1]interface Vlanif20</p>
<p>[S1-Vlanif20] ip address 10.0.20.1 255.255.255.0</p>
<p>[S1-Vlanif20] quit</p>
<p>[S2]interface Vlanif10</p>
<p>[S2-Vlanif10] ip address 10.0.10.2 255.255.255.0</p>
<p>[S2-Vlanif10] quit</p>
<p>[S2]interface Vlanif20</p>
<p>[S2-Vlanif20] ip address 10.0.20.2 255.255.255.0</p>
<p>[S2-Vlanif20] quit</p>
<p>#S1上配置VRRP</p>
<p>[S1]interface Vlanif 10</p>
<p>[S1-Vlanif10] vrrp vrid 10 virtual-ip 10.0.10.254</p>
<p>[S1-Vlanif10] vrrp vrid 10 priority 120</p>
<p>[S1-Vlanif10] quit</p>
<p>[S1]interface Vlanif 20</p>
<p>[S1-Vlanif20] vrrp vrid 20 virtual-ip 10.0.20.254</p>
<p>[S1-Vlanif20] quit</p>
<p>配置VLAN10的VRRP优先级为120，VLAN20保持默认的100。</p>
<p>#S2上配置VRRP</p>
<p>[S2]interface Vlanif10</p>
<p>[S2-Vlanif10] vrrp vrid 10 virtual-ip 10.0.10.254</p>
<p>[S2-Vlanif10] quit</p>
<p>[S2]interface Vlanif20</p>
<p>[S2-Vlanif20] vrrp vrid 20 virtual-ip 10.0.20.254</p>
<p>[S2-Vlanif20] vrrp vrid 20 priority 120</p>
<p>[S2-Vlanif20] quit</p>
<p>配置VLAN20的VRRP优先级为120，VLAN10保持默认的100。</p>
<p>#查看VRRP组状态</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/chakanvrrp1914.png" alt="chakanvrrp1914"></p>
<h2 id="配置VRRP与BFD联动进行快速切换"><a href="#配置VRRP与BFD联动进行快速切换" class="headerlink" title="配置VRRP与BFD联动进行快速切换"></a>配置VRRP与BFD联动进行快速切换</h2><p>在S1、S2上配置BFD单跳检测，检测VLANIF接口之间的连通性，将VRRP与BFD联动，当BFD会话状态Down时，增加VRRP Backup设备的优先级。</p>
<p>#在S1上配置BFD会话</p>
<p>[S1]bfd</p>
<p>[S1-bfd] quit</p>
<p>[S1]bfd vlanif10 bind peer-ip 10.0.10.2 interface Vlanif10</p>
<p>[S1-bfd-session-vlanif10] discriminator local 1</p>
<p>[S1-bfd-session-vlanif10] discriminator remote 2</p>
<p>[S1-bfd-session-vlanif10] min-tx-interval 100</p>
<p>[S1-bfd-session-vlanif10] min-rx-interval 100</p>
<p>[S1-bfd-session-vlanif10] commit</p>
<p>[S1-bfd-session-vlanif10] quit</p>
<p>[S1]bfd vlanif20 bind peer-ip 10.0.20.2 interface Vlanif20</p>
<p>[S1-bfd-session-vlanif20] discriminator local 11</p>
<p>[S1-bfd-session-vlanif20] discriminator remote 22</p>
<p>[S1-bfd-session-vlanif20] min-tx-interval 100</p>
<p>[S1-bfd-session-vlanif20] min-rx-interval 100</p>
<p>[S1-bfd-session-vlanif20] commit</p>
<p>[S1-bfd-session-vlanif20] quit</p>
<p>#在S2上配置BFD会话</p>
<p>[S2]bfd</p>
<p>[S2-bfd] quit</p>
<p>[S2]bfd vlanif10 bind peer-ip 10.0.10.1 interface Vlanif10</p>
<p>[S2-bfd-session-vlanif10] discriminator local 2</p>
<p>[S2-bfd-session-vlanif10] discriminator remote 1</p>
<p>[S2-bfd-session-vlanif10] min-tx-interval 100</p>
<p>[S2-bfd-session-vlanif10] min-rx-interval 100</p>
<p>[S2-bfd-session-vlanif10] commit</p>
<p>[S2-bfd-session-vlanif10] quit</p>
<p>[S2]bfd vlanif20 bind peer-ip 10.0.20.1 interface Vlanif20</p>
<p>[S2-bfd-session-vlanif20] discriminator local 22</p>
<p>[S2-bfd-session-vlanif20] discriminator remote 11</p>
<p>[S2-bfd-session-vlanif20] min-tx-interval 100</p>
<p>[S2-bfd-session-vlanif20] min-rx-interval 100</p>
<p>[S2-bfd-session-vlanif20] commit</p>
<p>[S2-bfd-session-vlanif20] quit</p>
<p>#检查BFD会话状态</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/bfdahakan737.png" alt="bfdahakan737"></p>
<p>此时S1、S2上BFD会话状态都为Up。</p>
<p>#配置VRRP与BFD联动</p>
<p>[S1]interface Vlanif20</p>
<p>[S1-Vlanif20] vrrp vrid 20 track bfd-session 11 increased 30</p>
<p>[S1-Vlanif20] quit</p>
<p>[S2]interface Vlanif10</p>
<p>[S2-Vlanif10] vrrp vrid 10 track bfd-session 2 increased 30</p>
<p>[S2-Vlanif10] quit</p>
<p>注意，此处的bfd-session号为本地的BFD discriminator，只需要在Backup状态的接口上配置联动，BFD会话Down时增加本地的VRRP优先级。</p>
<p>#关闭S1上所有接口，模拟链路故障</p>
<p>[S1]interface GigabitEthernet0&#x2F;0&#x2F;10</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;10] shutdown</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;10] quit</p>
<p>[S1]interface GigabitEthernet0&#x2F;0&#x2F;11</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11] shutdown</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11] quit</p>
<p>[S1]interface GigabitEthernet0&#x2F;0&#x2F;12</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12] shutdown</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12] quit</p>
<p>#在S2上查看BFD会话状态</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/yichang13038.png" alt="yichang13038"></p>
<p>此时两个BFD会话状态立马变为Down。</p>
<p>#在S2上查看VRRP组状态</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/shuangzhu129213128.png" alt="shuangzhu129213128"></p>
<p>VRRP组10、20的Master此时都是S2。</p>
<p>#在S2上查看VRRP组的状态和配置参数信息</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/canshufiejo9213200.png" alt="canshufiejo9213200"></p>
]]></content>
      <tags>
        <tag>VRRP</tag>
        <tag>BFD</tag>
      </tags>
  </entry>
  <entry>
    <title>WLAN基础配置（ap上线）</title>
    <url>/2023/12/20/WLAN%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%EF%BC%88ap%E4%B8%8A%E7%BA%BF%EF%BC%89/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="CAPWAP协议"><a href="#CAPWAP协议" class="headerlink" title="CAPWAP协议"></a>CAPWAP协议</h2><p>CAPWAP是基于UDP进行传输的应用层协议，CAPWAP协议在传输层运输两种类型的消息：</p>
<ul>
<li>业务数据流量，封装转发无线数据帧 。——通过CAPWAP数据隧道。</li>
<li>管理流量，管理AP和AC之间交换的管理消息 。——通过CAPWAP控制隧道。</li>
</ul>
<p>CAPWAP数据和控制报文基于不同的UDP端口发送：</p>
<ul>
<li>管理流量端口为UDP端口5246。</li>
<li>业务数据流量端口为UDP端口5247。</li>
</ul>
<h2 id="AC连接方式"><a href="#AC连接方式" class="headerlink" title="AC连接方式"></a>AC连接方式</h2><p>直连模式下AC部署在用户的转发路径上，采用这种组网方式，对AC的吞吐量以及处理数据能力要求比较高，否则AC会是整个无线网络带宽的瓶颈。但用此种组网，组网架构清晰，组网实施起来简单</p>
<p>在旁挂式组网中，AC只承载对AP的管理功能，管理流封装在CAPWAP隧道中传输。数据业务流可以通过CAPWAP数据隧道经AC转发，也可以不经过AC转发直接转发，后者无线用户业务流经汇聚交换机由汇聚交换机传输至上层网络。</p>
<h2 id="WLAN的基本概念"><a href="#WLAN的基本概念" class="headerlink" title="WLAN的基本概念"></a>WLAN的基本概念</h2><ol>
<li><p>BSS：一个AP所覆盖的范围，在一个BSS的服务区域内，STA可以相互通信。</p>
</li>
<li><p>BSSID：是无线网络的一个身份标识，用AP的MAC地址表示。</p>
</li>
<li><p>SSID：表示无线网络的标识，用来区分不同的无线网络。例如，当我们在笔记本电脑上搜索可接入无线网络时，显示出来的网络名称就是SSID。</p>
</li>
<li><p>VAP<br>早期的AP只支持1个BSS，如果要在同一空间内部署多个BSS，则需要安放多个AP，这不但增加了成本，还占用了信道资源。为了改善这种状况，现在的AP通常支持创建出多个虚拟AP (Virtual Access Point, VAP)。如图16-13所示，它相当于交换机中的VLAN</p>
</li>
<li><p>ESS</p>
</li>
</ol>
<p>为了满足实际业务的需求，需要对BSS的覆盖范围进行扩展。同时用户从一个BSS移动到另一个BSS时，不能感知到SSID的变化，则可以通过扩展服务集ESS (Extend Service Set)实现。如图6-14所示，这是由多个使用相同SSID的BSS组成，是采用相同的SSID的多个BSS组成的更大规模的虚拟BSS。</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p><img src="/2023/12/20/WLAN%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%EF%BC%88ap%E4%B8%8A%E7%BA%BF%EF%BC%89/tuopoa182409.png" alt="tuopoa182409"></p>
<ol>
<li>实验步骤</li>
<li>步骤1：基本配置<br>LSW2的配置<br><Huawei>system-view<br>[Huawei]undo info-center enable<br>[Huawei]sysname LSW2<br>[LSW2]vlan 100<br>[LSW2-vlan100]quit<br>[LSW2]interface e0&#x2F;0&#x2F;1<br>[LSW2-Ethernet0&#x2F;0&#x2F;1]port link-type trunk<br>[LSW2-Ethernet0&#x2F;0&#x2F;1]port trunk allow-pass vlan 100<br>[LSW2-Ethernet0&#x2F;0&#x2F;1]port trunk pvid vlan 100<br>[LSW2-Ethernet0&#x2F;0&#x2F;1]quit<br>[LSW2]interface e0&#x2F;0&#x2F;2<br>[LSW2-Ethernet0&#x2F;0&#x2F;2]port link-type trunk<br>[LSW2-Ethernet0&#x2F;0&#x2F;2]port trunk allow-pass vlan 100<br>[LSW2-Ethernet0&#x2F;0&#x2F;2]port trunk pvid vlan 100<br>[LSW2-Ethernet0&#x2F;0&#x2F;2]quit<br>[LSW2]interface e0&#x2F;0&#x2F;3<br>[LSW2-Ethernet0&#x2F;0&#x2F;3]port link-type trunk<br>[LSW2-Ethernet0&#x2F;0&#x2F;3]port trunk allow-pass vlan 100<br>[LSW2-Ethernet0&#x2F;0&#x2F;3]quit<br>【思考1】：为什么LSW2只创建VLAN100，不用创建VLAN101？<br>解析：因为我们用的是隧道转发，数据到达AC1后，才会打上101标记然后发给LSW1<br>【思考2】：为什么连接AP的接口要打port trunk pvid vlan 100?<br>解析：交换机收到AP的数据帧打上100的tag发送<br>把带上100tag的数据帧去掉然后发给AP<br>LSW1的配置<br><Huawei>system-view<br>[Huawei]undo info-center enable<br>[Huawei]sysname LSW1<br>[LSW1]vlan batch 100 101<br>[LSW1]interface g0&#x2F;0&#x2F;1<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;1]port link-type trunk<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;1]port trunk allow-pass vlan 100<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;1]quit<br>[LSW1]interface g0&#x2F;0&#x2F;3<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;3]port link-type trunk<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;3]port trunk allow-pass vlan 100 101<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;3]quit<br>[LSW1]interface g0&#x2F;0&#x2F;2<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;2]port link-type access<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;2]port default vlan 101<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;2]quit<br>[LSW1]interface Vlanif 101<br>[LSW1-Vlanif101]ip address 192.168.101.1 24<br>[LSW1-Vlanif101]undo shutdown<br>[LSW1-Vlanif101]quit<br>AC1的配置<br><AC6005>system-view<br>[AC6005]undo info-center enable<br>[AC6005]sysname AC1<br>[AC1]vlan batch 100 101<br>[AC1]interface g0&#x2F;0&#x2F;1<br>[AC1-GigabitEthernet0&#x2F;0&#x2F;1]port link-type trunk<br>[AC1-GigabitEthernet0&#x2F;0&#x2F;1]port trunk allow-pass vlan 100 101<br>[AC1-GigabitEthernet0&#x2F;0&#x2F;1]quit<br>[AC1]interface Vlanif 100<br>[AC1-Vlanif100]ip address 192.168.100.1 24<br>[AC1-Vlanif100]undo shutdown<br>[AC1-Vlanif100]quit<br>R1的配置<br><Huawei>system-view<br>[Huawei]undo info-center enable<br>[Huawei]sysname R1<br>[R1]interface g0&#x2F;0&#x2F;0<br>[R1-GigabitEthernet0&#x2F;0&#x2F;0]ip address 192.168.101.2 24<br>[R1-GigabitEthernet0&#x2F;0&#x2F;0]undo shutdown<br>[R1-GigabitEthernet0&#x2F;0&#x2F;0]quit</Huawei></AC6005></Huawei></Huawei></li>
<li>步骤2：设置DHCP<br>创建VLAN设置TRUNK<br>业务DHCP-让STA获得IP地址<br>[LSW1]dhcp enable<br>[LSW1]interface Vlanif 101<br>[LSW1-Vlanif101]dhcp select interface<br>[LSW1-Vlanif101]quit<br>管理DHCP-让AP获得IP地址<br><AC1>system-view<br>[AC1]dhcp enable<br>[AC1]interface Vlanif 100<br>[AC1-Vlanif100]dhcp select interface<br>[AC1-Vlanif100]quit</AC1></li>
<li>步骤3：AC的配置</li>
<li>AP上线<br>第一步：创建AP组<br><AC1>system-view<br>[AC1]wlan<br>[AC1-wlan-view]ap-group name x &#x2F;&#x2F;创建AP组名字叫x<br>[AC1-wlan-ap-group-x]quit<br>第二步：创建域管理模板并关联到AP组<br>[AC1]wlan<br>[AC1-wlan-view]regulatory-domain-profile name x1 &#x2F;&#x2F;创建域管理模板，名字叫x1<br>[AC1-wlan-regulate-domain-x1]country-code cn &#x2F;&#x2F;国家代码选择中国<br>[AC1-wlan-regulate-domain-x1]quit<br>[AC1-wlan-view]ap-group name x<br>[AC1-wlan-ap-group-x]regulatory-domain-profile x1 &#x2F;&#x2F;AP组的域管理模板是x1<br>Warning: Modifying the country code will clear channel, power and antenna gain c<br>onfigurations of the radio and reset the AP. Continue?[Y&#x2F;N]:y<br>[AC1-wlan-ap-group-x]quit<br>第三步：配置AC的接口源地址<br>[AC1]capwap source interface Vlanif 100 &#x2F;&#x2F;AC的接口源地址为VLAN100<br>第四步：离线导入AP<br>[AC1]wlan<br>[AC1-wlan-view]ap auth-mode mac-auth &#x2F;&#x2F;AP的认证模式为MAC认证<br>[AC1-wlan-view]ap-id 1 ap-mac 00e0-fcd5-1c70 &#x2F;&#x2F;AP的编号和MAC地址<br>[AC1-wlan-ap-1]ap-name ds &#x2F;&#x2F;AP的名字为ds<br>[AC1-wlan-ap-1]ap-group x &#x2F;&#x2F;AP属于AP组x<br>[AC1-wlan-view]ap-id 2 ap-mac 00e0-fc1e-3670 &#x2F;&#x2F;AP的编号和MAC地址<br>[AC1-wlan-ap-2]ap-name xs &#x2F;&#x2F;Ap的名字<br>[AC1-wlan-ap-2]ap-group x &#x2F;&#x2F;AP属于AP组x<br>Warning: This operation may cause AP reset. If the country code changes, it will<br>clear channel, power and antenna gain configurations of the radio, Whether to c<br>ontinue? [Y&#x2F;N]:y<br>思考：AP的MAC地址是怎么知道的？<br>读者可以通过在ap上使用命令“display interface Vlanif 1”查看当前ap的mac地址，然后再将mac地址进行绑定。<br>查看命令：<br>[AC1]display ap all<br>Info: This operation may take a few seconds. Please wait for a moment.done.<br>Total AP information:<br>nor : normal [2]<br>-—————————————————————————————–<br>ID MAC Name Group IP Type State STA Uptime<br>-—————————————————————————————–<br>1 00e0-fcd5-1c70 ds x 192.168.100.137 AP2050DN nor 0 11M:2S<br>2 00e0-fc1e-3670 xs x 192.168.100.42 AP2050DN nor 0 54S<br>-—————————————————————————————–<br>可以看到两个AP都获取了IP地址，<br>思考：以上过程一共几包？<br>AP获取IP地址4个包：discovery、offer、request、ack<br>CAPWAP的建立2个包：discovery request(udp 目的端口5246广播找AC) discovery response(单播回应AP)<br>AP接入控制2个包：join request(udp 5246端口 单播) join response<br>隧道维持2个包：数据隧道：keepalive(udp 5247) 控制隧道：echo(udp 5246)</AC1></li>
<li>配置VLAN业务参数<br>第一步：创建安全模板<br>[AC1]wlan<br>[AC1-wlan-view]security-profile name y1 &#x2F;&#x2F;安全模板的名字叫y1<br>[AC1-wlan-sec-prof-y1]security wpa-wpa2 psk pass-phrase huawei@123 aes &#x2F;&#x2F;密码是huawei@123，用AES加密。<br>[AC1-wlan-sec-prof-y1]quit<br>第二步：创建SSID模板<br>[AC1]wlan<br>[AC1-wlan-view]ssid-profile name y2 &#x2F;&#x2F;ssid的模板名字叫y2<br>[AC1-wlan-ssid-prof-y2]ssid hcia &#x2F;&#x2F;ssid的名称叫hcia<br>[AC1-wlan-ssid-prof-y2]quit<br>[AC1-wlan-view]quit<br>第三步：创建VAP模板<br>[AC1]wlan<br>[AC1-wlan-view]vap-profile name y &#x2F;&#x2F;vap模板的名字叫y<br>[AC1-wlan-vap-prof-y]forward-mode tunnel &#x2F;&#x2F;转发模式为隧道<br>[AC1-wlan-vap-prof-y]service-vlan vlan-id 101 &#x2F;&#x2F;服务的VLAN为101<br>[AC1-wlan-vap-prof-y]security-profile y1 &#x2F;&#x2F;调用安全模板y1<br>[AC1-wlan-vap-prof-y]ssid-profile y2 &#x2F;&#x2F;调用SSID模板y2<br>[AC1-wlan-vap-prof-y]quit<br>第四步：在AP组里面调用VAP模板<br>[AC1-wlan-view]ap-group name x<br>[AC1-wlan-ap-group-x]vap-profile y wlan 1 radio 0 &#x2F;&#x2F;调用VAP模板y<br>[AC1-wlan-ap-group-x]vap-profile y wlan 1 radio 1 &#x2F;&#x2F;<br>思考：radio0 1 2 是什么意思？<br>思考：这相过程要几个包？<br>WLAN业务配置下发2个包：Configuration Update Request Configuration Update Response</li>
<li>STA接入，可以看到有两个ssid为hcia的无线网络，在之前的配置中配置了radio 0 、1就是为了释放两个不同的射频信号，选择其中一个，输入之前创建的密码huawei@123</li>
</ol>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>ap上线</tag>
        <tag>wlan</tag>
      </tags>
  </entry>
  <entry>
    <title>mpls实验</title>
    <url>/2023/12/05/mpls%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>MPLS（Multiprotocol Label Switching）多协议标签转发复习总结<br>首先我们要先知道MPLS是为何出现的？<br>MPLS是基于传统IP网络（RIP，OSPF等）的缺陷由IETF确定的</p>
<p><strong>顺便先复习一下路由器查路由表 转发的过程：</strong></p>
<p>传统的IP转发中，物理层从交换机的一个端口收到一个报文，上送到数据链路层。数据链路层去掉链路层封装，根据报文的协议域上送给相应的网络层。网络层首先看报文是否是送给本机的，若是，去掉网络层封装，上送给它的上层协议。若不是，则根据报文的目的地址查找路由表，若找到路由，将报文送给相应端口的数据链路层，数据链路层封装后，发送报文。若找不到路由，将报文丢弃。传统的IP转发采用的是逐跳转发，数据报文经过每一台交换机，都要执行上述过程（如图中SWA收到目的地址为10.2.0.1的数据包，SWA会依次查找路由表，根据匹配的路由表项的进行转发，SWB、SWC、SWD都会进行类似的处理），所以速度缓慢。并且所有的交换机需要知道全网的路由或者默认路由。另外，由于传统IP转发是面向无连接的，所以无法提供好的Qos保证。</p>
<p>传统IP网络基于IGP Metric计算最优路径，这是远远不够的，往往在现实网络中还需考虑带宽、链路属性等其他因素；基于IP的流量工程是基于IGP面向目的地址的转发，是hop-by-hop（逐跳）的转发，无法实现根据来源来控制流量转发；另外基于IP的流量工程是面向无连接的，不能实现显式路径（Explicit Routing）。<br>上图中，SWB和SWD之间存在两条路径。传统的IP转发中IGP根据Metric选择最优的路由SWB-SWC-SWD转发所有从Network A和Network B到Network C的IP报文，而SWB-SWG-SWH-SWD链路则闲置，当网络中流量过大，有可能导致最优路径拥塞，但次优路径却空载没有被充分利用。</p>
<p>MPLS的出现<br>从A到走到B有三种方法：<br><strong>1.广播</strong>（如以太网）：直接把数据发给每一个地方<br><strong>2.逐跳寻径</strong>：走到一个地方，问一下路接下来该怎么走（也就是上面说的根据路由协议，查路由表）<br><strong>3.源路由</strong>：提前规划好路线，到哪里怎么走，不常用。</p>
<p>而<strong>MPLS</strong>是第四种走法：<br>跟在“向导”后面走，向导在走过的路上做好标记，你只要沿着标记的指示走就可以了。这也就是“标签交换”</p>
<p>MPLS结合了三层路由技术与二层交换技术，所以可以把它看成“<strong>2.5层</strong>”的<br>其中的MP多协议指的是支持多种网络协议，如ipv4，ipv6，CLNP，IPX等</p>
<p>MPLS是一种标签转发技术，它采用无连接的控制平面和面向连接的数据平面（具体的MPLS架构下面还有介绍），无连接的控制平面实现路由信息的传递和标签的分发，面向连接的数据平面实现报文在建立的标签转发路径上传送。MPLS域内，交换机不需要查看每个报文的目的IP地址，只需要根据封装在IP头外面的标签进行转发即可，这样可以大大提高效率</p>
<p>MPLS转发与IP逐跳转发的关系<br>MPLS是IP的承载层：MPLS转发与IP转发不冲突，它们的关系是如果能够使用MPLS转发，那么IP包会先封装成MPLS数据帧来转发。如果不能MPLS转发，就还是原来的ip逐跳转发。<br><strong>（也就是尽量优先MPLS，因为它会更快）</strong></p>
<p><img src="/2023/12/05/mpls%E5%AE%9E%E9%AA%8C/mnvc7761.png" alt="mnvc7761"></p>
<p>看上面的图，我们需要理解：整个MPLS域（可以进行MPLS转发的区域）是嵌在IP域上的，也就是MPLS域外部是IP域，它本身也运行IP域。</p>
<p><strong>MPLS中一些基本概念，名词</strong><br>标签（Label）：是一个定长的，比较短的，只具有本地意义的标识。<br><strong>FEC（转发等价类）</strong>：一组或一类数据，这组数据分配的标签相同<br><strong>LSP（标签交换通道）</strong>：一个FEC的数据流，在不同的节点被赋予确定的标签,数据转发按照<br>这些标签进行。数据流所走的路径就是LSP。<br><strong>LSR（Label Switching Router</strong>）： LSR是MPLS的网络的核心交换机，它提供标签交<br>换和标签分发功能。<br><strong>LER（Label Switching Edge Router）</strong>：在MPLS的网络边缘，进入到MPLS网络的流量由LER分为不同的FEC，并为这些FEC请求相应的标签。它提供流量分类和标签的映射、标签的移除功能。</p>
<p>从IP域进入MPLS域的时候，LER（标记边缘路由器）要做一个压入（push），出MPLS域的时候做一个弹出（pop），而LSR（标记交换路由器）负责转发。所以LER实际工作量比LSR大很多。LSP（标记交换路径）就是从进入到离开 走的路径。这条路径是在转发报文之前就已经通过各种协议确定并建立的，报文会在特定的LSP上传递。（也可以把LSP看成一个隧道）</p>
<p>标签报文格式：</p>
<p>MPLS Header长度为<strong>32bits</strong>，包括长度为<strong>20bits的标签（Label）</strong>，该标签用于报文转发；长度为3bits的EXP通常用来承载IP报文中的优先级；长度为<strong>1bit的栈底标志S</strong>用来表明是否是最后一个标签（MPLS标签可以多层嵌套）；长度为<strong>8bits的TTL</strong>，作用类似IP头部的TTL，用来防止报文环路等。</p>
<p>事实上MPLS封装有两种方式，上面说的是帧模式，Ethernet和PPP都是帧模式封装；还有一个信元封装模式（ATM采用）。<br>MPLS的 LSP 与标签转发表</p>
<p><strong>MPLS转发过程</strong></p>
<p><img src="/2023/12/05/mpls%E5%AE%9E%E9%AA%8C/mplszfgc813341.png" alt="mplszfgc813341"></p>
<p>1.Push：首先从IP数据包从ip域进入MPLS域，入口LER做 push 操作，分析转发等价类，为数据包“打上标签”，绑定LSP通道；图中A的标签转发表内容大概如下：</p>
<p><img src="/2023/12/05/mpls%E5%AE%9E%E9%AA%8C/a008298.png" alt="a008298"></p>
<p>2.Swap：B，C两个LSR根据标签转发表，用下一跳分配的标签，替换MPLS报文的标签并转发</p>
<p><img src="/2023/12/05/mpls%E5%AE%9E%E9%AA%8C/bc66327448.png" alt="bc66327448"></p>
<p>3.Pop：转发到出口LER D时，进行pop弹出操作，去掉标签</p>
<p>MPLS转发的过程到这里结束。</p>
<p><img src="/2023/12/05/mpls%E5%AE%9E%E9%AA%8C/d4kg2110.png" alt="d4kg2110"></p>
<p><strong>PHP</strong>（倒数第二跳弹出。Penultimate Hop Popping ，和web开发的php可没关系）：上面的过程我们可以发现，C在发给D时，其实带标签的数据已经没有意义，因为下一跳就要弹出标签了，所以完全可以在C就把标签弹出，然后以ip报文形式转发给D。<br>这样可以大大降低最后的出口LER的工作量，是现在MPLS普遍采用的方法。<br>默认情况下，设备支持PHP特性，支持PHP的Egress节点即出口LER 分配给倒数第二跳节点的标签值为3。</p>
<p><strong>MPLS标签转发表与LDP</strong></p>
<p>我们知道，<br>交换机中的MAC地址表是通过逆向学习法产生的；<br>路由器中的路由表是通过路由协议学习或自己配置静态路由产生的。<br>那么MPLS中标签转发表是怎么产生的呢？</p>
<p>答案是也会有一个类似的路由器学习的协议，这个协议叫做LDP（Label Distribution Protocol 标签分发协议），这个也是MPLS技术的核心协议之一。LDP来完成标签的分配控制和保持</p>
<p>从整个MPLS架构看这个协议的位置：</p>
<p><img src="/2023/12/05/mpls%E5%AE%9E%E9%AA%8C/jiegoutu666299.png" alt="jiegoutu666299"></p>
<p>以上是MPLS架构图<br>MPLS包括两个平面：控制平面和数据平面。<br>控制平面负责产生和维护路由信息以及标签信息。数据平面负责普通IP报文的转发以及带MPLS标签报文的转发。<br>控制平面中路由协议模块（Routing Protocol）用来传递路由信息，生成路由信息表；标签分发协议模块（Label Distribution Protocol）用来完成标签信息的交换，建立标签转发路径。<br>数据平面包括IP转发表和标签转发表，当收到普通IP报文时（Incoming IP Packets），如果是普通IP转发，则查找IP路由表转发，如果需要标签转发，则按照标签转发表转发；当收到带有标签的报文时（Incoming Labeled Packets）时，如果需要按照标签转发，根据标签转发表转发，如果需要转发到IP网络，则去掉标签后根据IP转发表转发。</p>
<p>LDP的标签管理与保留方式主要内容有下面三部分</p>
<ol>
<li><strong>标签分配模式</strong></li>
</ol>
<p>DoD：下游按需标记分发<br>DU：下游自主标记分发<br>2. <strong>标签控制模式</strong></p>
<p>有序方式<br>独立方式</p>
<ol start="3">
<li><strong>标签保持模式</strong></li>
</ol>
<p>保守模式<br>自由模式<br>最常用的组合是 <strong>下游自主（DU） + 有序 + 自由</strong></p>
<p>下面来具体介绍什么意思</p>
<p><img src="/2023/12/05/mpls%E5%AE%9E%E9%AA%8C/shangxiayou6291.png" alt="shangxiayou6291"></p>
<p>这里先要理解上游，下游的概念，MPLS入口出为最上游；出口处为最下游。标签的产生可以理解为是下游为上游产生的，下游产生的IN标签作为上游的OUT标签（比如图中R3左边要接收的IN标签为100，那么R2向右的OUT标签就要是100，因为R3只要为100的标签）</p>
<p>然后具体介绍上面的三个部分：<br><strong>Ⅰ.标签的控制模式</strong>（即标签是怎么产生的）：<br>有序（常用）：只有最下游路由器才能产生标签，最下游的上游收到最下游的标签映射消息后，然后才能再往自己的上游发送标签映射关系。<br>独立：中间的路由器也可以直接产生标签</p>
<p><strong>Ⅱ.标签的分发模式：</strong><br>下游按需 ：需要的时候上游再向下游询问标签信息；<br>下游自主：不管有没有问，下游路由器都自主的向上游发送标签映射信息（主动向上汇报）<br><strong>Ⅲ.标签的保留模式</strong>：如果有两条路径，也就会有两个标签，那么路由器保留哪个。<br>保守：只保留路由表中的”最佳路径“，跳数比较少的；<br>自由：保留所有的标签，虽然占用了更多的标签空间，但是收敛会快</p>
<h1 id="基础实验"><a href="#基础实验" class="headerlink" title="基础实验"></a>基础实验</h1><p><img src="/2023/12/05/mpls%E5%AE%9E%E9%AA%8C/tuoputump181224.png" alt="tuoputump181224"></p>
<p><strong>配置步骤：</strong></p>
<p>完成ip和ospf配置：</p>
<p>R1的配置如下： </p>
<p>[R1] interface GigabitEthernet0&#x2F;0&#x2F;0 </p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;0] ip address 12.1.1.1 24 </p>
<p>[R1] interface loopback0</p>
<p>[R1-Loopback0] ip address 1.1.1.1 32 </p>
<p>[R1] ospf 1 router-id 1.1.1.1 </p>
<p>[R1-ospf-1] area 0 </p>
<p>[R1-ospf-1-0.0.0.0] network 12.1.1.0 0.0.0.255 </p>
<p>[R1-ospf-1-0.0.0.0] network 1.1.1.1 0.0.0.0 </p>
<p>R2的配置如下： </p>
<p>[R2] interface GigabitEthernet0&#x2F;0&#x2F;0 </p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;0] ip address 12.1.1.2 24 </p>
<p>[R2] interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1] ip address 23.1.1.2 24 </p>
<p>[R2] interface loopback0 </p>
<p>[R2-Loopback0] ip address 2.2.2.2 32 </p>
<p>[R2] ospf 1 router-id 2.2.2.2 </p>
<p>[R2-ospf-1] area 0 </p>
<p>[R2-ospf-1-0.0.0.0] network 12.1.1.0 0.0.0.255 </p>
<p>[R2-ospf-1-0.0.0.0] network 23.1.1.0 0.0.0.255 </p>
<p>[R2-ospf-1-0.0.0.0] network 2.2.2.2 0.0.0.0 </p>
<p>R3的配置如下： </p>
<p>[R3] interface GigabitEthernet0&#x2F;0&#x2F;0 </p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;0] ip address 23.1.1.3 24 </p>
<p>[R3] interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;1] ip address 34.1.1.3 24 </p>
<p>[R3] interface loopback0 </p>
<p>[R3-Loopback0] ip address 3.3.3.3 32 </p>
<p>[R3] ospf 1 router-id 3.3.3.3 </p>
<p>[R3-ospf-1] area 0 </p>
<p>[R3-ospf-1-0.0.0.0] network 23.1.1.0 0.0.0.255 </p>
<p>[R3-ospf-1-0.0.0.0] network 34.1.1.0 0.0.0.255 </p>
<p>[R3-ospf-1-0.0.0.0] network 1.1.1.1 0.0.0.0 </p>
<p>R4的配置如下： </p>
<p>[R4] interface GigabitEthernet0&#x2F;0&#x2F;0</p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;0] ip address 34.1.1.4 24 </p>
<p>[R4] interface loopback0 </p>
<p>[R4-Loopback0] ip address 4.4.4.4 32 </p>
<p>[R4] ospf 1 router-id 4.4.4.4 </p>
<p>[R4-ospf-1] area 0 </p>
<p>[R4-ospf-1-0.0.0.0] network 34.1.1.0 0.0.0.255 </p>
<p>[R4-ospf-1-0.0.0.0] network 4.4.4.4 0.0.0.0 </p>
<p><strong>激活mpls并激活ldp</strong></p>
<p>（全局和接口下都需要激活）</p>
<p>R1的配置如下： </p>
<p>[R1] mpls lsr-id 1.1.1.1 </p>
<p>#配置MPLS LSR ID </p>
<p>[R1] mpls </p>
<p>#全局激活MPLS </p>
<p>[R1-mpls] quit </p>
<p>[R1] mpls ldp </p>
<p>#全局激活LDP </p>
<p>[R1-mpls-ldp] quit </p>
<p>[R1] Interface GigabitEthernet 0&#x2F;0&#x2F;0 </p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;0] mpls </p>
<p>#在接口上激活MPLS </p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;0] mpls ldp </p>
<p>#在接口上激活LDP </p>
<p>R2的配置如下： </p>
<p>[R2] mpls lsr-id 2.2.2.2 </p>
<p>[R2] mpls </p>
<p>[R2-mpls] quit </p>
<p>[R2] mpls ldp </p>
<p>[R2-mpls-ldp] quit </p>
<p>[R2] Interface GigabitEthernet 0&#x2F;0&#x2F;0 </p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;0] mpls</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;0] mpls ldp </p>
<p>[R2] Interface GigabitEthernet 0&#x2F;0&#x2F;1 </p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1] mpls </p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1] mpls ldp </p>
<p>R3的配置如下： </p>
<p>[R3] mpls lsr-id 3.3.3.3 </p>
<p>[R3] mpls </p>
<p>[R3-mpls] quit </p>
<p>[R3] mpls ldp </p>
<p>[R3-mpls-ldp] quit </p>
<p>[R3] Interface GigabitEthernet 0&#x2F;0&#x2F;0 </p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;0] mpls </p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;0] mpls ldp </p>
<p>[R3] Interface GigabitEthernet 0&#x2F;0&#x2F;1 </p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;1] mpls </p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;1] mpls ldp </p>
<p>R4的配置如下： </p>
<p>[R4] mpls lsr-id 4.4.4.4 </p>
<p>[R4] mpls </p>
<p>[R4-mpls] quit </p>
<p>[R4] mpls ldp </p>
<p>[R4-mpls-ldp] quit </p>
<p>[R4] Interface GigabitEthernet 0&#x2F;0&#x2F;0 </p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;0] mpls </p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;0] mpls ldp</p>
<p><strong>验证</strong>： </p>
<p><R1>display mpls ldp peer</R1></p>
<p> LDP Peer Information in Public network</p>
<p> A ‘*’ before a peer means the peer is being deleted.</p>
<p> -—————————————————————————–</p>
<p> PeerID         TransportAddress  DiscoverySource</p>
<p> -—————————————————————————–</p>
<p> 2.2.2.2:0        2.2.2.2       GigabitEthernet0&#x2F;0&#x2F;0</p>
<p> -—————————————————————————–</p>
<p> TOTAL: 1 Peer(s) Found.</p>
<p>以上输出的是R1的LDP邻居表，从表中可以看出R1已经发现了一个LDP邻居，那就是R2。</p>
<p><R1>disp mpls ldp session  verbose </R1></p>
<p> LDP Session(s) in Public Network</p>
<p> -—————————————————————————–</p>
<p> Peer LDP ID   : 2.2.2.2:0      Local LDP ID  : 1.1.1.1:0</p>
<p> TCP Connection  : 1.1.1.1 &lt;- 2.2.2.2</p>
<p> Session State  : Operational    Session Role  : Passive</p>
<p> Session FT Flag : Off         MD5 Flag    : Off</p>
<p> Reconnect Timer : —         Recovery Timer : —</p>
<p> Keychain Name  : —</p>
<p> Negotiated Keepalive Hold Timer  : 45 Sec</p>
<p> Configured Keepalive Send Timer  : —</p>
<p> Keepalive Message Sent&#x2F;Rcvd    : 153&#x2F;153 (Message Count)</p>
<p> Label Advertisement Mode      : Downstream Unsolicited</p>
<p> Label Resource Status(Peer&#x2F;Local) : Available&#x2F;Available</p>
<p> Session Age            : 0000:00:38 (DDDD:HH:MM)</p>
<p> Session Deletion Status      : No</p>
<p> Capability:</p>
<p>  Capability-Announcement     : Off</p>
<p>  P2MP Capability         : Off</p>
<p> Outbound&amp;Inbound Policies applied : NULL</p>
<p> Addresses received from peer: (Count: 3)</p>
<p> 2.2.2.2       12.1.1.2       23.1.1.2      </p>
<p> -—————————————————————————–</p>
<p>以上输出的是LDP会话的详细信息，邻居的状态必须为<strong>Operational</strong>才是最终的稳态，另外从TCP连接1.1.1.1 &lt; 2.2.2.2可以验证一点，LDP的会话建立是由传输地址大的一方发起的。</p>
<p><R1>display mpls ldp lsp </R1></p>
<p> LDP LSP Information</p>
<p> -——————————————————————————</p>
<p> DestAddress&#x2F;Mask  In&#x2F;OutLabel   UpstreamPeer   NextHop     OutInterface</p>
<p> -——————————————————————————</p>
<p> 1.1.1.1&#x2F;32     3&#x2F;NULL     2.2.2.2     127.0.0.1    InLoop0</p>
<p>*1.1.1.1&#x2F;32     Liberal&#x2F;1026          DS&#x2F;2.2.2.2</p>
<p> 2.2.2.2&#x2F;32     NULL&#x2F;3     -        12.1.1.2     GE0&#x2F;0&#x2F;0</p>
<p> 2.2.2.2&#x2F;32     1026&#x2F;3     2.2.2.2     12.1.1.2     GE0&#x2F;0&#x2F;0</p>
<p> 3.3.3.3&#x2F;32     NULL&#x2F;1024    -        12.1.1.2     GE0&#x2F;0&#x2F;0</p>
<p> 3.3.3.3&#x2F;32     1024&#x2F;1024    2.2.2.2     12.1.1.2     GE0&#x2F;0&#x2F;0</p>
<p> 4.4.4.4&#x2F;32     NULL&#x2F;1025    -        12.1.1.2     GE0&#x2F;0&#x2F;0</p>
<p> 4.4.4.4&#x2F;32     1025&#x2F;1025    2.2.2.2     12.1.1.2     GE0&#x2F;0&#x2F;0</p>
<p> -——————————————————————————</p>
<p> TOTAL: 7 Normal LSP(s) Found.</p>
<p> TOTAL: 1 Liberal LSP(s) Found.</p>
<p> TOTAL: 0 Frr LSP(s) Found.</p>
<p> A ‘*’ before an LSP means the LSP is not established</p>
<p> A ‘*’ before a Label means the USCB or DSCB is stale</p>
<p> A ‘*’ before a UpstreamPeer means the session is stale</p>
<p> A ‘*’ before a DS means the session is stale</p>
<p> A ‘*’ before a NextHop means the LSP is FRR LSP</p>
<p>以上输出的是R1的LFIB（标签转发信息库），可以看到已经建立好的LSP。 </p>
<p>实际上，当我们再R1、R2、R3、R4上运行OSPF后，全网的路由已经被打通，也就是每台路由器都拥有全网的路由，其中包括互联网段的路由，以及各设备的Loopback路由。随后我们激活各设备的MPLS和LDP，每台设备会基于自己的路由表中的路由前缀进行标签捆绑，并且将为路由前缀（FEC）所捆绑的标签分发给自己的LDP邻居。默认情况下在我司的设备上，仅为&#x2F;32的主机路由分发标签，并且默认水平分割规则并未打开。</p>
<p>现在，来测试一下，从R1去tracert 4.4.4.4： </p>
<p><R1>tracert lsp ip 4.4.4.4 32</R1></p>
<p> LSP Trace Route FEC: IPV4 PREFIX 4.4.4.4&#x2F;32 , press CTRL_C to break.</p>
<p> TTL  Replier       Time   Type    Downstream </p>
<p> 0                 Ingress  12.1.1.2&#x2F;[1025 ]</p>
<p> 1   12.1.1.2      20 ms  Transit  23.1.1.3&#x2F;[1024 ]</p>
<p> 2   23.1.1.3      20 ms  Transit  34.1.1.4&#x2F;[3 ]</p>
<p> 3   4.4.4.4       20 ms  Egress </p>
<p>从tracert的结果我们可以看到数据包行走的路径，以及被压入的标签。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>mpls</tag>
      </tags>
  </entry>
  <entry>
    <title>nat实验</title>
    <url>/2023/11/25/nat%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="静态nat"><a href="#静态nat" class="headerlink" title="静态nat"></a>静态nat</h1><p>静态NAT实现了私有地址和公有地址的一对一映射。如果希望一台主机优先使用某个关联地址，或者想要外部网络使用一个指定的公网地址访问内部服务器时，可以使用静态NAT。但是在大型网络中，这种一对一的IP地址映射无法缓解公用地址短缺的问题。</p>
<span id="more"></span>

<p>静态NAT实现了私有地址和共有地址一对一的映射（一个私有地址对应一个共有地址），并没有做到缓解地址短缺的问题，只是做到了地址转换。</p>
<p>一个公网地址只会分配给唯一且固定的内网地址</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/jingttuopu4509.png" alt="jingttuopu4509"></p>
<p>如图配置ip地址和网关</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/jingta15204327.png" alt="jingta15204327"></p>
<p>r1上配置静态nat（注意是在公网的接口上，出接口）</p>
<p>注意配置一条静态路由，不然没有路由的下一跳会被丢弃</p>
<p>在r1上查看nat映射关系：dis nat static</p>
<p>验证一下：<img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/jingtainatjg25204222.png" alt="jingtainatjg25204222"></p>
<p>发现去往2.2.2.2的源地址变为2.2.2.3，说明nat完成转换。</p>
<p>静态nat两种配置方式：</p>
<p>1.接口下（上述实验采用这种方式）：进入到连接外网路由器的出接口下，然后在接口视图下配置nat映射关系</p>
<p>2.全局：在全局视图下，配置好nat映射关系，再进入到出接口，执行：nat static enable</p>
<h1 id="动态nat"><a href="#动态nat" class="headerlink" title="动态nat"></a>动态nat</h1><p>动态NAT通过使用地址池来实现。</p>
<p>如上图，当内部主机A和主机B需要与公网中的目的主机通信时，网关RTA会从配置的公网地址池中选择一个未使用的公网地址与之做映射。每台主机都会分配到地址池中的一个唯一地址。当不需要此连接时，对应的地址映射将会被删除，公网地址也会被恢复到地址池中待用。当网关收到回复报文后，会根据之前的映射再次进行转换之后转发给对应主机。</p>
<p>注意：</p>
<p>动态NAT实际上实现的还是私有地址和公有地址一对一的关系，但是共有地址不再绑定给特定的内网地址。实现了一定程度的缓解地址短缺问题。<br>动态NAT地址池中的地址用尽以后，只能等待被占用的公用IP被释放后，其他主机才能使用它来访问公网。<img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/dongtaitu00800.png" alt="dongtaitu00800"></p>
<h2 id="动态NAT转换流程："><a href="#动态NAT转换流程：" class="headerlink" title="动态NAT转换流程："></a>动态NAT转换流程：</h2><p>1）路由器上配置一个内部地址池（公司内部所有主机用到的私有IP）动态映射一个外部地址池（所购买的公有IP）。<br>2）当有一个内网主机访问外网时，路由器首先查看NAT地址转换表；<br>3）若无，则再查看是否配置了动态NAT映射，若配置，则将IP包头中的源IP与内部地址池进行匹配，若有匹配项，则将该内网IP从内部地址池中取出，同时取出外部地址池中的一个IP地址，动态形成NAT地址转换表。注意，外部地址池的公网IP地址取出后，外部地址池中将没有该公网IP了。<br>4）默认当该主机24小时没有联系外网时，该动态NAT条目会自动消失，所被取出的公私有地址重新回到地址池中。</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/tuopudawda12714.png" alt="tuopudawda12714"></p>
<p>ip如图，pc的网关192.168.1.254</p>
<p>r1上配置默认路由，ip route-static 0.0.0.0 0 172.16.1.2</p>
<p>r1上配置动态地址池：</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/acldongtai2005212357.png" alt="acldongtai2005212357"></p>
<p>地址池验证：</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/dizhichi1201.png" alt="dizhichi1201"></p>
<p>配置acl策略：</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/acl55da612432.png" alt="acl55da612432"></p>
<p>在r1的外网出接口上调用：</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/natout25212448.png" alt="natout25212448"></p>
<p>验证：</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/dongtaijiegy12547.png" alt="dongtaijiegy12547"></p>
<p>其中源IP为3、4、5不定，说明是在动态分配外网地址。动态NAT配置完成。</p>
<p>在动态NAT实验中，最后利用PC1测试连通性时，间歇性会丢包</p>
<p>可能的原因：ping的时候默认按地址池中可用地址顺序从1~254进行地址转换，放大nat地址池可解决。</p>
<h1 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h1><p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/NApttu39.png" alt="NApttu39"></p>
<p>如上图，RTA收到一个私网主机发送的报文，源IP地址是192.168.1.1，源端口号是1025，目的IP地址是100.1.1.1，目的端口是80。RTA会从配置的公网地址池中选择一个空闲的公网IP地址和端口号，并建立相应的NAPT表项。这些NAPT表项指定了报文的私网IP地址和端口号与公网IP地址和端口号的映射关系。之后，RTA将报文的源IP地址和端口号转换成公网地址200.10.10.1和端口号2843，并转发报文到公网。当网关RTA收到回复报文后，会根据之前的映射表再次进行转换之后转发给主机A。主机B同理。</p>
<p>注意：</p>
<p>NAPT技术允许多个内部地址映射到同一个公有地址的不同端口。<br>NAPT实现了私有地址对共有地址多对一</p>
<p>相当于一种特殊的动态nat</p>
<p>1、端口NAT和动态NAT的配置过程基本一致，只是在应用到接口时，配置命令少no-pat<br>2、端口NAT一个地址可以给多个源地址转换，不是单对单的转换，所以节省了nat地址！<br>3、端口NAT实际应用较多，静态NAT和动态NAT因为地址不能节约，所以实际应用少</p>
<h1 id="Easy-IP"><a href="#Easy-IP" class="headerlink" title="Easy IP"></a>Easy IP</h1><p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/easydahwka5.png" alt="easydahwka5"></p>
<p>Easy IP本质上是NAPT（所以原理与NAPT大致相似）<br>由于网关设备出接口IP地址为公网地址，所以可以利用该<strong>出接口地址</strong>来作为地址转换的公有地址。<br>Easy IP适用于小规模局域网中的主机访问Internet的场景。小规模局域网通常部署在小型的网吧或者办公室中，这些地方内部主机不多，出接口可以通过拨号方式获取一个临时公网IP地址。Easy IP可以实现内部主机使用这个临时公网IP地址访问Internet。</p>
<p>Easy IP适用于小规模局域网中的主机访问Internet的场景。小规模局域网通常部署在小型的网吧或者办公室中，这些地方内部主机不多，出接口可以通过拨号方式获取一个临时公网IP地址。Easy IP可以实现内部主机使用这个临时公网IP地址访问Internet。</p>
<h2 id="Easy-IP的配置："><a href="#Easy-IP的配置：" class="headerlink" title="Easy IP的配置："></a>Easy IP的配置：</h2><p>1.创建ACL：acl 2000</p>
<p>2.允许1.0的数据进行转换：rule 5 permit source 192.168.1.0 0 .0.0.255</p>
<p>3.进入公网出接口</p>
<p>4.应用acl：nat outbound 2000</p>
<p>（相较于napt少了地址池）</p>
<p>验证：</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/easadwaawh215116.png" alt="easadwaawh215116"></p>
<p>源地址为出接口地址172.16.1.1，只是端口不同</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>nat</tag>
      </tags>
  </entry>
  <entry>
    <title>opsf总结</title>
    <url>/2024/04/18/opsf%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="ospf协议工作原理"><a href="#ospf协议工作原理" class="headerlink" title="ospf协议工作原理"></a>ospf协议工作原理</h1><p>工作过程：①建立邻居关系（hello   2-way状态）每台路由器都会产生lsa，路由器将接收到的lsa放入自己的lsdb中；②同步LSDB（DD、LSR、LSU、LSACK    full状态）；③计算路由（本路由器通过自己的LSDB，以自己为根节点，计算最短路径树，最终得到路由）SPF算法；</p>
<p>ospf支持的网络类型：广播、NBMA、点到点、点到多点</p>
<p>ospf计算；计算路由+计算拓扑</p>
<p>ospf报文采用IP封装，协议号89，</p>
<p>ospfv2（ipv4），ospfv3（ipv6）</p>
<p>ospf组播更新</p>
<p>224.0.0.5（所有运行ospf协议的路由器侦听）</p>
<p>224.0.0.6（DR和BDR侦听）</p>
<h1 id="Router-id"><a href="#Router-id" class="headerlink" title="Router id"></a>Router id</h1><p>在自治系统中唯一标识一台运行ospf的路由器，32位无符号整数</p>
<p>选举规则：手动配置（建议），如果没有手动配置，则路由器使用Loopback接口中最大的IP地址作为Router id，如果没有配置Loopback接口，则使用物理接口中最大的IP地址</p>
<h1 id="Cost值"><a href="#Cost值" class="headerlink" title="Cost值"></a>Cost值</h1><p>缺省接口cost&#x3D;（100mib&#x2F;s）&#x2F; 接口带宽，修改100mid&#x2F;s改变cost</p>
<p>也可以直接修改</p>
<p>累计cost作为开销值，流量从源网络到目的网络所经过所有路由器的出接口的cost总和</p>
<h1 id="Hello报文"><a href="#Hello报文" class="headerlink" title="Hello报文"></a>Hello报文</h1><p><img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%871.png" alt="图片1"></p>
<p>发送间隔10s，失效40s，修改发送，失效也变，失效始终为发送的4倍</p>
<p>命令：接口视图下，ospf timer hello 10</p>
<p>ospf邻居建立失败 ，可能原因：①物理链路故障；②ospf版本不一致；③区域ID不一致；④认证类型不一致；⑤认证数据不一致；⑥掩码不一致；（只出现在广播型网络中，点到点网络不检查掩码信息）⑦hello报文间隔不一致；⑧router id一致；（华为设备遇到router id一致，会重新配置router id）</p>
<h1 id="DD报文"><a href="#DD报文" class="headerlink" title="DD报文"></a>DD报文</h1><p>DD报文部分字段解释<br>I：当发送连续多个DD报文时，如果这是第一个DD报文，则置为1，否则置为0。<br>M (More)：当发送连续多个DD报文时，如果这是最后一个DD报文，则置为0。否则置为1，表示后面还有其他的DD报文。<br>MS (Master&#x2F;Slave)：当两台OSPF路由器交换DD报文时，首先需要确定双方的主从关系，Router ID大的一方会成为Master。当值为1时表示发送方为Master。<br>DD sequence number：DD报文序列号。主从双方利用序列号来保证DD报文传输的可靠性和完整性。</p>
<p><img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%872.png" alt="图片2"></p>
<p>链路状态类型、链路状态ID、通告路由器三元组唯一地标识了一个LSA。<br>链路状态老化时间 、链路状态序列号 、校验和用于判断LSA的新旧</p>
<h1 id="ospf状态机"><a href="#ospf状态机" class="headerlink" title="ospf状态机"></a>ospf状态机</h1><p>之前的手写笔记😍</p>
<p><img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ%E5%9B%BE%E7%89%8720240418204859.jpg" alt="QQ图片20240418204859"></p>
<p><img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ%E5%9B%BE%E7%89%8720240418204932.jpg" alt="QQ图片20240418204932"></p>
<p><img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ%E5%9B%BE%E7%89%8720240418204926.jpg" alt="QQ图片20240418204926"></p>
<h1 id="DR和BDR"><a href="#DR和BDR" class="headerlink" title="DR和BDR"></a>DR和BDR</h1><p>既侦听224.0.0.5也侦听224.0.0.6</p>
<p>每个网段选举一个</p>
<p>DR：指定路由器，负责在MA网络中建立和维护邻接关系，并负责lsa同步</p>
<p>DR和其他所有路由器形成邻接关系，其他路由器之间不直接交换链路状态信息</p>
<p>在DR失效时候，BDR接替</p>
<p>DR默认优先级1（0-255）越大越优，非抢占，优先级为0的不参与选举</p>
<h1 id="Router-LSA（1类）"><a href="#Router-LSA（1类）" class="headerlink" title="Router LSA（1类）"></a>Router LSA（1类）</h1><p>单区域中会用到1类、2类LSA</p>
<p>Router LSA—1类LSA  <strong>所有的路由器都会产生</strong>，描述本路由器的信息  泛洪区域：本区域</p>
<p>Router LSA使用Link来承载路由器直连接口的信息。<br>每条Link均包含“链路类型”、“链路ID”、“链路数据”以及“度量值”这几个关键信息。<br>路由器可能会采用一个或者多个Link来描述某个接口。<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%873.png" alt="图片3"></p>
<p>广播型网络中链路类型：TransNet</p>
<p>点到点网络中链路类型：point-to-point  （拓扑信息）、stubnet（网络信息）</p>
<p>Router LSA中链路状态类型、链路状态ID、通告路由器用谁表示：</p>
<p>链路状态类型：router</p>
<p>链路状态ID：本路由器的router id</p>
<p>通告路由器：本路由</p>
<h1 id="Network-LSA（2类）"><a href="#Network-LSA（2类）" class="headerlink" title="Network LSA（2类）"></a>Network LSA（2类）</h1><p>Network  LSA–2类LSA  DR路由器   泛洪区域：本区域</p>
<p>Network LSA中链路状态类型、链路状态ID、通告路由器用谁表示：</p>
<p>链路状态类型：network</p>
<p>链路状态ID：DR路由器的接口IP地址</p>
<p>通告路由器：DR路由器的router id</p>
<h1 id="Network-LSA（3类）"><a href="#Network-LSA（3类）" class="headerlink" title="Network LSA（3类）"></a>Network LSA（3类）</h1><p>3类LSA   ABR产生，泛洪范围本区域  作用：用于向一个区域通告到达另一个区域的路由</p>
<p><img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%874.png" alt="图片4"></p>
<p><strong>区域间防环</strong>：</p>
<p>1）非骨干区必须和骨干区area0相连，非骨干区不能直接进行通信</p>
<p>2）三类LSA传递是 单向的</p>
<p>3）从非骨干区域收到的3类LSA不能用于区域间路由的计算。</p>
<h1 id="AS-External-LSA（5类）"><a href="#AS-External-LSA（5类）" class="headerlink" title="AS External LSA（5类）"></a>AS External LSA（5类）</h1><p>AS-external LSA（5类LSA）：由ASBR产生，描述到达AS外部的路由，该LSA会被通告到所有的区域</p>
<p>LS Type：取值5，代表AS-external-LSA。<br>Link State ID：外部路由的目的网络地址。<br>Advertising Router：生成该LSA的Router ID。<br>Network Mask：网络掩码。</p>
<h1 id="ASBR-Summary-LSA（4类）"><a href="#ASBR-Summary-LSA（4类）" class="headerlink" title="ASBR-Summary LSA（4类）"></a>ASBR-Summary LSA（4类）</h1><p>ASBR-Summary LSA（4类LSA）：由ABR产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。</p>
<p>LS Type：取值4，代表ASBR-Summary LSA。<br>Link State ID ：ASBR的Router ID。<br>Advertising Router:生成LSA的Router ID。 </p>
<p>ospf外部路由在引入时，开销值类型有两种：默认情况是type-2</p>
<p><img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/wps1.jpg" alt="img"> </p>
<p>配置：[R7-ospf-1]import-route direct type 1</p>
<p>OSPF路由遵循以下优先级顺序，区域内路由&gt;区域间路由&gt;Metric-Type-1外部路由&gt;Metric-Type-2外部路由。</p>
<h1 id="ospf路由汇总"><a href="#ospf路由汇总" class="headerlink" title="ospf路由汇总"></a>ospf路由汇总</h1><p>OSPF路由汇总的类型：<br>在ABR执行路由汇总：对区域间的路由执行路由汇总。<br>在ASBR执行路由汇总：对引入的外部路由执行路由汇总。</p>
<p>区域间路由汇总在ABR设备上配置：</p>
<p>[R6-ospf-1-area-0.0.0.3]abr-summary 172.16.0.0 255.255.252.0</p>
<p>外部路由汇总在ASBR上配置：</p>
<p>[R8-ospf-1]asbr-summary 10.1.0.0 255.255.240.0</p>
<h1 id="ospf认证"><a href="#ospf认证" class="headerlink" title="ospf认证"></a>ospf认证</h1><p>OSPF支持报文认证功能，只有通过认证的OSPF报文才能被接收。<br>路由器支持两种OSPF报文认证方式，当两种认证方式都存在时，优先使用接口认证方式：<br>区域认证方式：一个OSPF区域中所有的路由器在该区域下的认证模式和口令必须一致。</p>
<p>[R6-ospf-1-area-0.0.0.3]authentication-mode md5 1 cipher huawei</p>
<p>该区域中所有路由器都要配置<br>接口认证方式：相邻路由器直连接口下的认证模式和口令必须一致。<br>[R2-GigabitEthernet0&#x2F;0&#x2F;0]ospf authentication-mode md5 1 cipher huawei</p>
<p>在一条链路上的所有接口下配置</p>
<h1 id="stub区域"><a href="#stub区域" class="headerlink" title="stub区域"></a>stub区域</h1><p>1、2、3、3类缺省LSA（ABR产生的）</p>
<p>Stub区域的ABR不向Stub区域内传播它接收到的AS外部路由（也就是4类、5类LSA），Stub区域中路由器的LSDB、路由表规模都会大大减小。<br>为保证Stub区域能够到达AS外部，Stub区域的ABR将生成一条缺省路由（使用3类LSA描述）。</p>
<p>配置Stub区域时需要注意下列几点：<br>骨干区域不能被配置为Stub区域。<br>Stub区域中的所有路由器都必须将该区域配置为Stub。<br>Stub区域内不能引入也不接收AS外部路由。<br>虚连接不能穿越Stub区域。</p>
<h1 id="Totally-Stub区域"><a href="#Totally-Stub区域" class="headerlink" title="Totally Stub区域"></a>Totally Stub区域</h1><p>1、2、3类缺省LSA（ABR产生的）</p>
<p>Totally Stub区域既不允许AS外部路由在本区域内传播，也不允许区域间路由在本区域内传播。<br>Totally Stub区域内的路由器通过本区域ABR下发的缺省路由（使用3类LSA描述）到达其他区域，以及AS外部<br>配置Totally Stub区域时需要注意：<br>与Stub区域配置的区别在于，在ABR上需要追加no-summary关键字。</p>
<h1 id="NSSA"><a href="#NSSA" class="headerlink" title="NSSA"></a>NSSA</h1><p>1、2、3、7类、7类缺省LSA（ABR产生的）</p>
<p>NSSA区域 相对于stub区别在于，可以引入外部路由，外部路由引入后，会以7类LSA在NSSA区域中泛洪，然后 在ABR设备上将7类LSA转化成5类LSA在其他区域 泛洪</p>
<p>Totally  NSSA：1、2、3缺省（ABR产生）、7类、7类缺省LSA（ABR产生的）</p>
<h1 id="Silent-Interface"><a href="#Silent-Interface" class="headerlink" title="Silent-Interface"></a>Silent-Interface</h1><p>Silent-Interface有以下特性：<br>Silent-Interface不会接收和发送OSPF报文。<br>Silent-Interface的直连路由仍可以发布出去。</p>
<p>通常我们会 将连接终端或者服务器的接口设置成Silent-Interface</p>
<p>[R1]ospf<br>[R1-ospf-1]area 0<br>[R1-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255<br>[R1-ospf-1]silent-interface GigabitEthernet 0&#x2F;0&#x2F;1</p>
<h1 id="路由器对lsa处理流程"><a href="#路由器对lsa处理流程" class="headerlink" title="路由器对lsa处理流程"></a>路由器对lsa处理流程</h1><p><img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ%E5%9B%BE%E7%89%8720240418211229.jpg" alt="QQ图片20240418211229"></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>ospf</tag>
      </tags>
  </entry>
  <entry>
    <title>rstp和mstp</title>
    <url>/2023/12/07/rstp%E5%92%8Cmstp/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>STP三个版本：</strong><br>STP（802.1d）<br>RSTP（802.1w）<br>MSTP （802.1s）<br>作用：打破二层环路，实现设备或者链路的冗余<br><strong>STP的计算过程</strong><br>①选举根桥<br>BID&#x3D;优先级+MAC，优先级值越小越优，如果优先级相等，MAC小的成为根桥<br>②选举根端口<br>RPC（小的越优）+上行交换机的BID+上行交换机的PID（优先级和接口ID，越小越优）+本地的PID<br>③选举指定接口<br>RPC（小的越优）+本端的BID+本端的PID（小的越优）<br>④非指定接口</p>
<p><strong>端口优先级</strong></p>
<p>端口ID（pid）&#x3D; 端口优先级（Port Priority）4 bit+ 端口编号12 bit 构成； 缺省情况下，端口优先级是128；端口优先级取值范围是0到240，取值必须为16的整数倍。</p>
<p><strong>优先级</strong></p>
<p>默认32768</p>
<p>越小越优</p>
<p>必须是4096倍数</p>
<p>0-65535</p>
<p><strong>接口根路径开销：</strong></p>
<p>1、dot1t<br>G：20000<br>E：200000</p>
<p>PRC&#x3D;根桥到非根桥经过所有的入方向接口的cost累加</p>
<p><strong>STP的收敛时间：</strong></p>
<p>①根桥故障<br>50s<br>②直连链路发生故障<br>30s<br>③非直连链路故障<br>50s</p>
<p>转发延迟计时器：15s<br>BPDU发送时间：2s<br>老化时间：20s</p>
<p><strong>端口状态：</strong><br>disable:未启用<br>blocking：阻塞<br>listening:侦听<br>learning:学习<br>forwarding：转发</p>
<p><strong>RSTP:</strong><br><strong>一、端口角色：</strong><br>根端口<br>指定端口<br>A:根端口的备份端口，提供了指定桥到达根的另一条路径<br>Backup:<br>作为指定接口的备份，提供了另一条从根桥到相应网段的备份链路</p>
<p><strong>二、端口状态</strong><br>Discarding状态：不转发用户流量也不学习MAC地址；<br>Learning状态：不转发用户流量但是学习MAC地址；<br>Forwarding状：既转发用户流量又学习MAC地址<br><strong>三、配置BPDU</strong><br>BPDU类型和flag字段<br><strong>四、配置BPDU的处理</strong><br>拓扑稳定后，运行RSTP协议的非根桥设备会定期的发送配置BPDU<br>RSTP的任何端口角色都会处理次优BPDU，从而加快拓扑收敛<br><strong>五、P&#x2F;A</strong><br>作用：保证一个指定接口从discarding—&gt;forwarding<br>触发：只有指定discarding状态下才可以触发P&#x2F;A机制，必须是根端口在forwarding状态下回复一个A&#x3D;1的一个BPDU</p>
<p>① 选举根桥、根接口、指定接口，然后根接口、指定接口处于discarding<br>②根桥的指定接口处于discarsing，触发到P&#x2F;A，根桥会从指定接口发送P&#x3D;1BPDU；<br>③非根桥的根接口收到P&#x3D;1的BPDU，会启动一个同步过程，将非边缘接口全部阻塞，同步完成之后，根接口切换到转发状态，并且从根接口发送A&#x3D;1 BPDU<br>④根桥收到A&#x3D;1 BPDU，立即切换为转发状态，实现指定接口的快速收敛</p>
<p><strong>保护功能：</strong><br><strong>1、BPDU保护</strong><br>存在问题：边缘端口收到BPDU之后，接口会变成普通接口，那么会引起网络中生成树重新计算，对网络造成影响。<br>解决：开启BPDU保护功能，只要边缘端口收到BPDU，交换机立即把接口置位Error-down，同时会产生告警。（接口恢复两种方式：手工恢复、自动恢复）</p>
<p><strong>2、根保护</strong></p>
<p>存在问题：加入在一个稳定的STP网络，此时根桥连接一台交换机，该交换机支持生成树，发送BPDU，STP网络重新计算；如果新加入的交换机比根桥优先级更优，会抢占根桥的位置，从而引起网络震荡<br>解决：根桥的指定接口下激活跟保护功能，如何接口收到了更优的BPDU，会忽略并且切换到discarding。<br>注意：跟保护只能在指定接口下激活。<br>状态恢复：如果接口不再收到更优的BPDU，在一段时间后（2*转发延迟时间）自动恢复转发状态。</p>
<p><strong>3、环路保护</strong><br>存在问题：<br>AP单向故障：假如交换机之间通过光纤（一收一发），链路发生单向故障，AP接口老化时间后没有收到BPDU,接口会成为DP并切换到转发状态，并转发流量，环路产生<br>RP单向故障：假如交换机之间通过光纤（一收一发），链路发生单向故障，导致DP到RP的单向故障，RP在一段时间没有收到BPDU，AP会切换到RP角色，RP切换到DP，收敛完成，DP开始转发业务流量，环路产生。<br>解决：在AP接口下开启环路保护功能，如何接口长时间没有BPDU	,那么AP接口切换成DP，端口状态保持discarding状态，避免环路。</p>
<p>在RP接口下开启环路保护功能，如何接口长时间没有BPDU，那么会重新计算选举根端口，并将原端口调整为DP，接口状态保持discarding状态，避免环路。</p>
<p><strong>4、拓扑变更保护（TC protection）</strong><br>存在问题：假如网络中存在攻击者，会仿冒TC置位为1的BPDU报文发送大量的TC BPDU，交换机收到BPDU之后，会删除mac地址表项，会消耗大量的设备资源。<br>解决：默认情况交换机开启了拓扑变更保护，缺省2s只会处理异常TC BPDU，超出的部分等待一段时间处理</p>
<p><strong>如何生成STP树？</strong><br>主要通过比较4个参数：根桥ID、根路径开销、网桥ID和端口ID，值越小，越优先。而这些参数，都是报文BPDU中的字段。<br>根桥选举：比较根桥ID，最小胜出。<br>根端口选举：依次比较RPC、对端BID、对端PID和本端PID，最小胜出。<br>指定端口选举：依次比较RPC、本端BID和本端PID，最小胜出。</p>
<p><strong>在确定了根端口和指定端口之后，交换机上所有剩余的非根端口和非指定端口被阻塞。</strong></p>
<p><strong>MSTP：</strong><br><strong>一、概念</strong><br>MST Region：Multiple Spanning Tree Region，多生成树域），也可简称MST域<br>MSTI（Multiple Spanning Tree Instance，多生成树实例）：MSTI使用Instance ID标识，为0~4094。<br>Instance0是缺省存在的，而且缺省时，华为交换机上所有的VLAN都映射到了Instance0。<br>通过设置VLAN映射表（即VLAN和MSTI的对应关系表），把VLAN和MSTI联系起来。<br>每个VLAN只能对应一个MSTI，即同一VLAN的数据只能在一个MSTI中传输，而一个MSTI可能对应多个VLAN。<br>CST公共生成树：是连接交换网络内所有MST域的一棵生成树<br>IST（内部生成树）是各MST域内的一棵生成树。<br>CIST（公共和内部生成树）<br>通过生成树协议计算生成的，连接一个交换网络内所有交换设备的单生成树<br>SST（Single Spanning Tree，单生成树）有两种情况：<br>运行生成树协议的交换设备只能属于一个生成树。<br>MST域中只有一个交换设备，这个交换设备构成单生成树。</p>
<p>总根（CIST Root）是CIST的根桥</p>
<p>域根（Regional Root）<br>分为IST域根和MSTI域根。<br>IST域根，在MST域中IST生成树中距离总根最近的交换设备是IST域根，<br>MSTI域根是每个多生成树实例的树根</p>
<p>主桥（Master Bridge）是IST Master，它是域内距离总根最近的交换设备，如果总根在MST域中，则总根为该域的主桥</p>
<p><strong>新增的端口角色：</strong><br>①Master端口</p>
<p>Master端口是MST域和总根相连的所有路径中最短路径上的端口，它是交换设备上连接MST域到总根的端口。<br>Master端口是域中的报文去往总根的必经之路。<br>Master端口是特殊域边缘端口，Master端口在CIST上的角色是Root Port，在其它各实例上的角色都是Master端口。</p>
<p>②域边缘端口<br>域边缘端口是指位于MST域的边缘并连接其它MST域或SST的端口</p>
<p>MSTP计算<br>优先级向量说明：<br>根交换设备ID：根交换设备ID用于选择CIST中的根交换设备。<br>根交换设备ID &#x3D; Priority(16 bit) + MAC(48 bit)。<br>其中Priority为MSTI0的优先级。<br>外部路径开销（External Root Path Cost，ERPC）：从CIST的域根到达总根的路径开销。<br>MST域内所有交换设备上保存的外部路径开销相同。<br>若CIST根交换设备在域中，则域内所有交换设备上保存的外部路径开销为0。<br>域根ID：域根ID用于选择MSTI中的域根。<br>域根ID &#x3D; Priority(16 bit) + MAC(48 bit)。<br>其中Priority为MSTI0的优先级。<br>内部路径开销（Internal Root Path Cost，IRPC）：本桥到达域根的路径开销。<br>域边缘端口保存的内部路径开销大于非域边缘端口保存的内部路径开销。<br>指定交换设备ID：CIST或MSTI实例的指定交换设备是本桥通往域根的最邻近的上游桥。<br>如果本桥就是总根或域根，则指定交换设备为自己。<br>指定端口ID：指定交换设备上同本设备上根端口相连的端口。<br>Port ID &#x3D; Priority(4 bit) + 端口号（12 bit）。<br>端口优先级必须是16的整数倍。<br>接收端口ID：接收到BPDU报文的端口。<br>Port ID &#x3D; Priority(4 bit) + 端口号（12 bit）。</p>
<p><strong>端口优先级必须是16的整数倍。</strong></p>
<p>优先级向量比较原则：<br>同一向量比较，值最小的向量具有最高优先级。<br>优先级向量比较原则如下<br>首先，比较根交换设备ID。<br>如果根交换设备ID相同，再比较外部路径开销。<br>如果外部路径开销相同，再比较域根ID。<br>如果域根ID仍然相同，再比较内部路径开销。<br>如果内部路径仍然相同，再比较指定交换设备ID。<br>如果指定交换设备ID仍然相同，再比较指定端口ID。<br>如果指定端口ID还相同，再比较接收端口ID。<br>如果端口接收到的BPDU内包含的配置消息优于端口上保存的配置消息，则端口上原来保存的配置消息被新收到的配置消息替代。端口同时更新交换设备保存的全局配置消息。反之，新收到的BPDU被丢弃。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><img src="/2023/12/07/rstp%E5%92%8Cmstp/rstptuopu7180923.png" alt="rstptuopu7180923"></p>
<ol>
<li>开启STP，修改STP模式为RSTP。</li>
<li>手动指定S1为RSTP根桥、S2为RSTP备份根桥。</li>
<li>通过修改接口开销值，使得S4的GE0&#x2F;0&#x2F;1接口成为根端口。</li>
<li>通过修改S1的GE0&#x2F;0&#x2F;11接口优先级，使得S2的GE0&#x2F;0&#x2F;11接口成为根端口。</li>
<li>修改STP模式为MSTP，创建Instance1、2，指定SW1为MSTI1的根桥、MSTI2的备份根桥，指定SW2为MSTI2的根桥、MSTI1的备份根桥。</li>
</ol>
<h2 id="RSTP基础配置"><a href="#RSTP基础配置" class="headerlink" title="RSTP基础配置"></a>RSTP基础配置</h2><p>#S1-s4 上都配置</p>
<p>stp enable</p>
<p>stp mode rstp</p>
<p>#查看STP的状态和统计信息摘要</p>
<p>dis stp brief</p>
<p>接口都为指定端口的是根桥，本实验中s4是根桥</p>
<p> 根桥选举控制</p>
<p>#手动调整STP优先级，指定S1为主根桥、S2为备份根桥</p>
<p>[S1]stp priority 4096</p>
<p>[S2]stp priority 8192</p>
<p>在另外两台交换机保持默认桥优先级（32768）的情况下，S1拥有最小的桥优先级，S2次之。</p>
<p>此时s1变为根桥，s2备份根桥</p>
<p>dis stp可以看到优先级已经改变</p>
<p>#取消S1、S2上手动调整桥优先级的配置，使用<strong>stp root</strong>命令指定根桥、备份根桥</p>
<p>[S1]undo stp priority</p>
<p>[S1]stp root primary</p>
<p>[S2]undo stp priority</p>
<p>[S2]stp root secondary</p>
<p>#S1、S2上查看STP的状态和统计信息，可以看到如下内容</p>
<p>s1：</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/s1dis182725.png" alt="s1dis182725"></p>
<p>s2:</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/s2disgg182834.png" alt="s2disgg182834"></p>
<p>S1的桥优先级为0，而S2的桥优先级为4096，此时S1为根桥，S2为备份根桥。</p>
<p>修改接口开销值控制根端口选举</p>
<p>#在S4上查看STP的状态和统计信息摘要</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/s4disg83008.png" alt="s4disg83008"></p>
<p>S4上GE0&#x2F;0&#x2F;2拥有更小的RPC（根路径开销），从而成为根端口。</p>
<p>#在S4上查看GE0&#x2F;0&#x2F;2接口的STP的状态和统计信息</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/s4disint232.png" alt="s4disint232"></p>
<p>此时路径开销计算方法为Dot1t，接口的STP cost值为20000。</p>
<p>#修改S4的GE0&#x2F;0&#x2F;2接口的STP cost值为40001</p>
<p>[S4]interface GigabitEthernet 0&#x2F;0&#x2F;2</p>
<p>[S4-GigabitEthernet0&#x2F;0&#x2F;2] stp cost 40001</p>
<p>#再次在S4上查看STP的状态和统计信息摘要</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/s4gen333559.png" alt="s4gen333559"></p>
<p>此时GE0&#x2F;0&#x2F;1接口的RPC为20000，小于GE0&#x2F;0&#x2F;2接口的RPC 40001，S4的GE0&#x2F;0&#x2F;1接口成为根端口。</p>
<p>修改接口优先级控制根端口选举</p>
<p>#在S2上查看STP的状态和统计信息摘要</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/s2disf83853.png" alt="s2disf83853"></p>
<p>S2上GE0&#x2F;0&#x2F;10、GE0&#x2F;0&#x2F;11接口收到的BPDU拥有相同的RPC、上行交换机BID，此时比较上行交换机PID（优先级+接口id），接口优先级一样，接口id小的优，所以g0&#x2F;0&#x2F;10小，所以是根端口</p>
<p>#在S1上修改GE0&#x2F;0&#x2F;11的STP接口优先级，使其发送的BPDU优于 GE0&#x2F;0&#x2F;10发送的BPDU</p>
<p>（修改上行交换机的PID）</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;11</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11] stp port priority 64</p>
<p>端口ID&#x3D; 端口优先级（Port Priority）4 bit+ 端口编号12 bit 构成； 缺省情况下，端口优先级是128；端口优先级取值范围是<strong>0到240</strong>，取值必须为<strong>16</strong>的整数倍。</p>
<p>#再次查看S2上的STP状态和统计信息摘要</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/g0011gen759.png" alt="g0011gen759"></p>
<p>此时S2的GE0&#x2F;0&#x2F;1接口成为根端口。</p>
<h2 id="MSTP基础配置"><a href="#MSTP基础配置" class="headerlink" title="MSTP基础配置"></a>MSTP基础配置</h2><p>在所有交换机上创建VLAN10、20、30、40、50、60、70、80，配置MSTP域hcip，并创建两个新的实例：Instance 1、Instance 2，将VLAN10、30、50、70映射到Instance 1，将VLAN20、40、60、80映射到Instance 2，同时将SW1规划为MSTI1的主根桥、MSTI2的备份根桥，将SW2规划为MSTI2的主根桥、MSTI1的备份根桥。</p>
<p>#创建VLAN</p>
<p>[S1]vlan batch 10 20 30 40 50 60 70 80</p>
<p>[S2]vlan batch 10 20 30 40 50 60 70 80</p>
<p>[S3]vlan batch 10 20 30 40 50 60 70 80</p>
<p>[S4]vlan batch 10 20 30 40 50 60 70 80</p>
<p>#将所有互联接口配置为Trunk接口，放通所有VLAN</p>
<p>略</p>
<p>#修改STP模式为MSTP</p>
<p>[S1]stp mode mstp</p>
<p>[S2]stp mode mstp</p>
<p>[S3]stp mode mstp</p>
<p>[S4]stp mode mstp</p>
<p>#配置MSTP</p>
<p>[S1]stp region-configuration</p>
<p>[S1-mst-region] region-name hcip &#x2F;&#x2F;域名为hcip</p>
<p>[S1-mst-region] revision-level 1 &#x2F;&#x2F;版本1</p>
<p>[S1-mst-region] instance 1 vlan 10 30 50 70 实例1映射vlan 10 30 50 70</p>
<p>[S1-mst-region] instance 2 vlan 20 40 60 80</p>
<p>[S1-mst-region] active region-configuration &#x2F;&#x2F;生效</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S1-mst-region] quit</p>
<p>（s2，s3，s4同理配置）</p>
<p>#在S1检查MSTP实例和VLAN的映射关系</p>
<p>[S1]display stp region-configuration </p>
<p>#配置SW1为MSTI1的根桥、MSTI2的备份根桥</p>
<p>[S1]stp instance 1 root primary </p>
<p>[S1]stp instance 2 root secondary</p>
<p>#配置SW2为MSTI2的根桥、MSTI1的备份根桥</p>
<p>[S2]stp instance 1 root secondary </p>
<p>[S2]stp instance 2 root primary</p>
<p>#在S1上查看MSTI1的状态和统计信息摘要</p>
<p>[S1]display stp instance 1 brief</p>
<p> MSTID  Port           Role  STP State      Protection</p>
<p>  1   GigabitEthernet0&#x2F;0&#x2F;10    DESI  FORWARDING    NONE</p>
<p>  1   GigabitEthernet0&#x2F;0&#x2F;11    DESI  FORWARDING    NONE</p>
<p>  1   GigabitEthernet0&#x2F;0&#x2F;12    DESI  FORWARDING    NONE</p>
<p>  1   GigabitEthernet0&#x2F;0&#x2F;13    DESI  FORWARDING    NONE</p>
<p>S1上所有接口都是指定接口，S1为MSTI1的根桥。</p>
<p>#在S2上查看MSTI2的状态和统计信息摘要</p>
<p>[S2]display stp instance 2 brief </p>
<p> MSTID  Port           Role  STP State    	 Protection</p>
<p>  2   GigabitEthernet0&#x2F;0&#x2F;10    DESI  FORWARDING    NONE</p>
<p>  2   GigabitEthernet0&#x2F;0&#x2F;11    DESI  FORWARDING    NONE</p>
<p>  2   GigabitEthernet0&#x2F;0&#x2F;12    DESI  FORWARDING    NONE</p>
<p>  2   GigabitEthernet0&#x2F;0&#x2F;13    DESI  FORWARDING    NONE</p>
<p>S2上所有接口都是指定接口，S2为MSTI2的根桥。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>rstp</tag>
        <tag>mstp</tag>
      </tags>
  </entry>
  <entry>
    <title>telnet</title>
    <url>/2023/12/02/telnet/</url>
    <content><![CDATA[<h1 id="两种配置方法"><a href="#两种配置方法" class="headerlink" title="两种配置方法"></a>两种配置方法</h1><h2 id="1-仅密码登录验证"><a href="#1-仅密码登录验证" class="headerlink" title="1.仅密码登录验证"></a>1.仅密码登录验证</h2><p>代码如下（示例）：<br><Quidway>system-view —–进入配置模式<br>[Quidway]interface vlan 1 —–进入管理vlan<br>[Quidway-Vlanif1]ip address 192.168.28.49 255.255.255.0 —–配置管理ip地址<br>[Quidway-Vlanif1]quit —–退出<br>[Quidway]telnet server enable —–打开telnet服务 （一般默认开启）<br>[Quidway]user-interface vty 0 4 —–用户指定虚拟用户终端接口<br>[Quidway-ui-vty0-4]authentication-mode password —–配置用户终端接口认证方式 密码验证<br>[Quidway-ui-vty0-4]set authentication password cipher huawei123 —–设置接口验证密码,密码为huawei123<br>[Quidway-ui-vty0-4]user privilege level 15 —–设置用户优先级 （可选）<br>[Quidway-ui-vty0-4]idle-timeout 1 —–设置登陆超时为一分钟 （可选）<br>[Quidway-ui-vty0-4]return —–返回用户视图<br><Quidway>save —–保存</Quidway></Quidway></p>
<h2 id="2-配置AAA登录"><a href="#2-配置AAA登录" class="headerlink" title="2.配置AAA登录"></a>2.配置AAA登录</h2><p>代码如下（示例）：<br><Quidway>system-view —–进入配置模式<br>[Quidway]interface vlan 1 —–进入管理vlan<br>[Quidway-Vlanif1]ip address 192.168.28.49 255.255.255.0 —–配置管理ip地址<br>[Quidway-Vlanif1]quit —–退出<br>[Quidway]telnet server enable —–打开telnet服务 （一般默认开启）<br>[Quidway]user-interface vty 0 4 —–用户指定虚拟用户终端接口<br>[Quidway-ui-vty0-4]authentication-mode aaa —–配置用户终端接口认证方式 aaa验证<br>[Quidway-ui-vty0-4]user privilege level 15 —–设置用户优先级<br>[Quidway-ui-vty0-4]idle-timeout 1 —–设置登陆超时为一分钟<br>[Quidway-ui-vty0-4]quit —–退出<br>[Quidway]aaa —–进入aaa<br>[Quidway-aaa]local-user huawei password cipher huawei123 —–创建用户名huawei 密码huawei123<br>[Quidway-aaa]local-user huawei privilege level 15 —–设置用户优先级<br>[Quidway-aaa]local-user huawei service-type telnet —–授权用户使用telnet<br>[Quidway-ui-vty0-4]return —–返回用户视图<br><Quidway>save —–保存</Quidway></Quidway></p>
<h2 id="user-interface-vty-0-4-详解"><a href="#user-interface-vty-0-4-详解" class="headerlink" title="user-interface vty 0 4 详解"></a>user-interface vty 0 4 详解</h2><p>Quidway]user-interface vty 0 4                    ；进入虚拟终端<br>[S3026-ui-vty0-4]authentication-mode password           ；设置口令模式<br>[S3026-ui-vty0-4]set authentication-mode password simple 222 ；设置口令<br>[S3026-ui-vty0-4]user privilege level 3 </p>
<p>一、第一句的意思是：进入到vty 终端，在华为的交换机里，vty就是人家用telnet远程进入到你交换机的界面，最多有五个，所以说你可以vty 0  vty 1 vty… vty 4交换机最多可以允许五个人同时在线进到交换机里去配置命令的。vty0 4 就是说把这五个界面一起配置了，这五个界面进去的话，都是使用以下的配置。<br>二、用的认证模式是密码认证，可以使用scheme模式来，也可以用password来，用password的话，是要密码的，就是说你telnet的话，要输入密码才能登陆到包交换机里去的。<br>二、设置密码为明文密码，密码是123 ，如果是密文的话，就是cipher<br>四、用户等级为3，也就是最高的，华为的命令级别很多，分为四级，0 1 2 3 ，0是参观级，只能看，1比0要高，可以使用一些命令，2 是可以配置了，3可以备份与删除IOS啦，呵呵，这个命令就是说用这个123密码，进来就是最高级别的，不用换级别。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>telnet</tag>
        <tag>aaa</tag>
      </tags>
  </entry>
  <entry>
    <title>vlan间通信</title>
    <url>/2023/11/24/vlan%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="VLAN间通信"><a href="#VLAN间通信" class="headerlink" title="VLAN间通信"></a>VLAN间通信</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>划分VLAN后，不同VLAN的用户间不能二层互访，这样能起到隔离广播的作用。但实际应用中，不同VLAN的用户又常有互访的需求，此时就需要实现不同VLAN的用户互访，简称VLAN间互访。</p>
<span id="more"></span>

<h2 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h2><p><img src="/2023/11/24/vlan%E9%97%B4%E9%80%9A%E4%BF%A1/vlantx001.png" alt="vlantx001"></p>
<p>详解：R2划入vlan2，R3划入vlan3，与交换机之间采用access口，由于交换机g0&#x2F;0&#x2F;1需要通过多个vlan，所以配成trunk口。R2和R3相当于主机，发送和接受的数据都不带标签，交换机g0&#x2F;0&#x2F;2收到R2发送的数据，打上标签vlan2，然后发出去；交换机g0&#x2F;0&#x2F;1收到数据后，发现vlan的标签允许通过，则数据带着vlan2的标签通过；然后交换机g0&#x2F;0&#x2F;3口转发数据时，发现自己的pvid是vlan3，和vlan2不一样，所以不接受，则vlan2和vlan3不能通信。</p>
<p>在某些场景下，需要特定vlan之间通信</p>
<p>方法一：dot1q接口</p>
<p>在r1上配置两个dot1q接口，g0&#x2F;0&#x2F;1.1和g0&#x2F;0&#x2F;1.2，分别对应vlan2和vlan3，作用就是可以终结vlan标签（剥离），vlan2的标签到r1后，被剥离掉vlan2的标签，然后转发时又被g0&#x2F;0&#x2F;1.2打上vlan3的标签，交换机g0&#x2F;0&#x2F;1通过，到g0&#x2F;0&#x2F;3，access口发现和自己的pvid一样，然后剥离掉标签，转发数据帧给r3.</p>
<p>方法二：vlanif接口：交换机上配置vlanif2和vlanif3，ip地址配成192.168.2.254和192.168.3.254</p>
<p>其实就是相当于两个不同网段的网关，然后实现三层的转发</p>
<h2 id="Access接口"><a href="#Access接口" class="headerlink" title="Access接口"></a>Access接口</h2><p>交换机上常用来连接用户PC、服务器等终端设备的接口。Access接口所连接的这些设备的网卡往往只收发无标记帧。Access接口只能加入一个VLAN。只能允许一个VLAN通过。</p>
<p><strong>转发原则</strong></p>
<p>接收原则：</p>
<p>①收到不带标签的数据帧，打上标签，vlan id&#x3D;端口的PVID</p>
<p>②收到带标签的数据帧，检查数据帧vlan id是否和端口的PVID相同，相同直接接收；不同拒绝接收</p>
<p>发送原则：</p>
<p>①数据帧vlan id和端口PVID 相同，剥离标签发送；</p>
<p>②数据帧vlan id和端口PVID 不同，禁止发送。</p>
<h2 id="Trunk接口"><a href="#Trunk接口" class="headerlink" title="Trunk接口"></a>Trunk接口</h2><p>Trunk接口允许多个VLAN的数据帧通过，这些数据帧通过802.1Q Tag实现区分。Trunk接口常用于交换机之间的互联，也用于连接路由器、防火墙等设备的</p>
<p>子接口</p>
<p><strong>转发原则</strong></p>
<p>接收原则：</p>
<p>①收到不带标签的数据帧，打上标签，vlan id&#x3D;端口的PVID，然后查看该vlanid是否在允许列表中，是–接收，不是–拒绝</p>
<p>②收到带标签的数据帧，查看该vlan id是否在允许列表中，是–接收，不是–拒绝</p>
<p>发送原则：</p>
<p>查看vlan id是否在允许列表中，I:不是–拒绝发送；II：是，查看接口的PVID和vlan id是否相同，相同–剥标签发送；不同–直接发送。</p>
<h2 id="Hybrid接口"><a href="#Hybrid接口" class="headerlink" title="Hybrid接口"></a>Hybrid接口</h2><p>Hybrid接口与Trunk接口类似，也允许多个VLAN的数据帧通过，这些数据帧通过802.1Q Tag实现区分。用户可以灵活指定Hybrid接口在发送某个（或某些）VLAN的数据帧时是否携带Tag</p>
<p><strong>转发原则</strong></p>
<p>接收原则：</p>
<p>①收到不带标签的数据帧，打上标签，vlan id&#x3D;端口的PVID，然后查看该vlanid是否在允许列表中，是–接收，不是–拒绝</p>
<p>②收到带标签的数据帧，查看该vlan id是否在允许列表中，是–接收，不是–拒绝发送原则：查看vlan id是否在允许列表中，I:不是–拒绝发送；II：是，是否带标签发送取决于接口的配置。</p>
<h2 id="PVID"><a href="#PVID" class="headerlink" title="PVID"></a>PVID</h2><p>可以手工修改，默认是1，access口的就是本身的vlan号，trunk可以有一个主vlan和多个副vlan，收到的数据和主vlan相同就剥离转发，收到和主vlan不一样的标签，查表，看看是不是在允许通过的列表，如果有，就带着原来的转发，要是没有，就不让过去啦。</p>
<h2 id="实验配置过程"><a href="#实验配置过程" class="headerlink" title="实验配置过程"></a>实验配置过程</h2><p># R2和R3的IP地址及网关配置</p>
<p><R2> system-view</R2></p>
<p>Enter system view, return user view with Ctrl+Z.</p>
<p>[R2]interface GigabitEthernet 0&#x2F;0&#x2F;1</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1]ip address 192.168.2.1 24</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1]quit	</p>
<p>[R2]ip route-static 0.0.0.0 0 192.168.2.254</p>
<p>配置默认路由，相当于给设备配置了网关。</p>
<p><R3>system-view </R3></p>
<p>Enter system view, return user view with Ctrl+Z.</p>
<p>[R3]interface GigabitEthernet 0&#x2F;0&#x2F;1</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;1]ip address 192.168.3.1 24</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;1]quit</p>
<p>[R3]ip route-static 0.0.0.0 0 192.168.3.254</p>
<p># 在S1上对R2和R3进行VLAN划分</p>
<p>[S1]vlan batch 2 3</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;2</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;2]port link-type access </p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;2]port default vlan 2</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;2]quit</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;3</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;3]port link-type access </p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;3]port default vlan 3</p>
<p>步骤 1 通过Dot1q终结子接口实现VLAN间互访 </p>
<p># 配置S1上的Trunk接口</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;1</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;1]port trunk allow-pass vlan 2 3</p>
<p><em>因为VLAN间<strong>互访数据要</strong>由R1来终结VLAN<strong>，</strong>所以S1和R1之间<strong>的链路要允许</strong>VLAN2和VLAN3通过**。</em></p>
<p># 在R1上创建并配置Dot1q终结子接口</p>
<p>[R1]interface GigabitEthernet 0&#x2F;0&#x2F;1.2 </p>
<p>创建并进入子接口视图。2代表子接口的编号，一般建议子接口编号与VLAN ID相同，方便记忆。</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.2]dot1q termination vid 2 </p>
<p><strong>dot1q termination vid</strong> <em>vlan-id</em>命令用来配置子接口Dot1q终结的VLAN ID。</p>
<p>以此配置为例：当GigabitEthernet0&#x2F;0&#x2F;1接口收到带有VLAN 2标签的数据之后，会交由2号子接口进行VLAN终结操作并做后续处理。从2号子接口发出的数据也会带上VLAN 2的标签。</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.2]arp broadcast enable </p>
<p>终结子接口不能转发广播报文，在收到广播报文后它们直接把该报文丢弃。为了允许终结子接口能转发广播报文，可以通过在子接口上执行命令<strong>arp broadcast enable</strong>使能终结子接口的ARP广播功能。部分设备默认使能该功能，此命令的配置根据设备而定。</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.2]ip address 192.168.2.254 24 </p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.2]quit</p>
<p>[R1]interface GigabitEthernet 0&#x2F;0&#x2F;1.3</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.3]dot1q termination vid 3</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.3]arp broadcast enable</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.3]ip address 192.168.3.254 24</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.3]quit</p>
<p># 检测VLAN间互访联通性 </p>
<p><R2>ping 192.168.3.1</R2></p>
<p> PING 192.168.3.1: 56  data bytes, press CTRL_C to break</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;1 ttl&#x3D;254 time&#x3D;60 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;2 ttl&#x3D;254 time&#x3D;40 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;3 ttl&#x3D;254 time&#x3D;110 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;4 ttl&#x3D;254 time&#x3D;70 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;5 ttl&#x3D;254 time&#x3D;100 ms</p>
<p> — 192.168.3.1 ping statistics —</p>
<p>  5 packet(s) transmitted</p>
<p>  5 packet(s) received</p>
<p>  0.00% packet loss</p>
<p>  round-trip min&#x2F;avg&#x2F;max &#x3D; 40&#x2F;76&#x2F;110 ms</p>
<p><R2>tracert 192.168.3.1 </R2></p>
<p> traceroute to  192.168.3.1(192.168.3.1), max hops: 30 ,packet length: 40,press CTRL_C to break </p>
<p> 1 192.168.2.254 30 ms  50 ms  50 ms </p>
<p> 2 192.168.3.1 70 ms  60 ms  60 ms </p>
<p>此时VLAN2和VLAN3之间已经可以正常的互访。</p>
<p>步骤 2 通过VLANIF接口实现VLAN间互访</p>
<p># 清除上一步配置</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;1</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;1]undo port trunk allow-pass vlan 2 3</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;1]undo port link-type</p>
<p>[R1]undo interface GigabitEthernet 0&#x2F;0&#x2F;1.2 </p>
<p>[R1]undo interface GigabitEthernet 0&#x2F;0&#x2F;1.3</p>
<p># 在S1上创建相应的VLANIF接口 </p>
<p>[S1]interface Vlanif 2</p>
<p><strong>interface vlanif</strong> <em>vlan-id</em>命令用来创建VLANIF接口并进入VLANIF接口视图。只有先通过命令创建VLAN后，才能执行interface vlanif命令创建VLANIF接口。</p>
<p>[S1-Vlanif2]ip address 192.168.2.254 24</p>
<p>[S1-Vlanif2]quit</p>
<p>[S1]interface Vlanif 3</p>
<p>[S1-Vlanif3]ip address 192.168.3.254 24 </p>
<p>[S1-Vlanif3]quit</p>
<p># 检测VLAN间互访联通性</p>
<p><R2>ping 192.168.3.1 </R2></p>
<p> PING 192.168.3.1: 56  data bytes, press CTRL_C to break</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;1 ttl&#x3D;254 time&#x3D;100 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;2 ttl&#x3D;254 time&#x3D;50 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;3 ttl&#x3D;254 time&#x3D;50 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;4 ttl&#x3D;254 time&#x3D;60 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;5 ttl&#x3D;254 time&#x3D;70 ms</p>
<p> — 192.168.3.1 ping statistics —</p>
<p>  5 packet(s) transmitted</p>
<p>  5 packet(s) received</p>
<p>  0.00% packet loss</p>
<p>  round-trip min&#x2F;avg&#x2F;max &#x3D; 50&#x2F;66&#x2F;100 ms</p>
<p><R2>tracert 192.168.3.1 </R2></p>
<p> traceroute to  192.168.3.1(192.168.3.1), max hops: 30 ,packet length: 40,press CTRL_C to break </p>
<p> 1 192.168.2.254 40 ms  30 ms  20 ms </p>
<p> 2 192.168.3.1 40 ms  30 ms  40 ms</p>
<p>此时VLAN2和VLAN3之间已经可以正常的互访。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>vlan间通信</tag>
        <tag>dot1q</tag>
        <tag>vlanif</tag>
      </tags>
  </entry>
  <entry>
    <title>交换机工作原理</title>
    <url>/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/1jhjgzyl938.png" alt="1jhjgzyl938"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2jhjgzyl0011038.png" alt="2jhjgzyl0011038"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/3jhjgzyl011116.png" alt="3jhjgzyl011116"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/4jhjgzyl135.png" alt="4jhjgzyl135"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/5jhjgzyl330011154.png" alt="5jhjgzyl330011154"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/6jhjgzyl0011208.png" alt="6jhjgzyl0011208"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7jhjgzyl1222.png" alt="7jhjgzyl1222"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/8jhjgzyl240.png" alt="8jhjgzyl240"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/9jhjadji11254.png" alt="9jhjadji11254"></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>交换机工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title>大型WLAN技术(1)</title>
    <url>/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/</url>
    <content><![CDATA[<h1 id="VLAN-Pool"><a href="#VLAN-Pool" class="headerlink" title="VLAN Pool"></a>VLAN Pool</h1><p>通过vlan pool把接入的用户分配到不同的vlan，减少广播域，减少网络中的广播报文，提升网络性能。</p>
<p>由于无线终端的移动性，在无线网络中经常有大量用户从某个区域接入后，随着用的移动，再漫游到其他区域，导致该区域的用户接入多，对IP地址数目要求大。比如：场馆入口、酒店的大堂等。目前一个SSID只能对应一个VLAN，一个VLAN对应一个子网，如果大量用户</p>
<p>从某一区域接入，只能扩大VLAN的子网，保证用户能够获取到IP地址。这样带来的问题就是广播域扩大，导致大量的广播报文（如ARP、DHCP等）带来严重的网络拥塞。基于此问题考虑，一个SSID需要能够对应多个VLAN，把大量用户分散到不同的VLAN减少广播域。VLAN Pool提供多个VLAN的管理和分配算法，实现SSID对应多个VLAN的方案。</p>
<h2 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h2><p>• 顺序分配算法：把用户按上线顺序依次划分到不同的VLAN中，用户上下线用户VLAN容易</p>
<p>变化，IP地址变更。</p>
<p>• HASH分配算法：根据用户MAC地址HASH值分配VLAN，用户分配的VLAN固定，可能导致</p>
<p>VLAN间用户划分不均匀，有的VLAN用户较多，有的较少。</p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240526151755.png" alt="QQ截图20240526151755"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240526151911.png" alt="QQ截图20240526151911"></p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526152035.png" alt="QQ截图20240526152035" style="zoom:50%;">

<p>如图，管理vlan10，业务vlan 20 30 40，网络可达，dhcp配置，capwap隧道，wlan基础配置（vap模板里业务vlan选择绑定vlan pool）</p>
<p>创建vlan pool，把业务vlan 20 30 40 加入进来，分配算法这里选择顺序分配</p>
<p>终端连接后，查看ip，发现分别接入vlan20 30 40</p>
<h1 id="AC的DHCP技术"><a href="#AC的DHCP技术" class="headerlink" title="AC的DHCP技术"></a>AC的DHCP技术</h1><p>随着网络规模的不断扩大，网络设备不断增多，企业内不同的用户可能分布在不同的网段，一台DHCP服务器在正常情况下无法满足多个网段的地址分配需求。企业内网各个网段通常都没有与DHCP Server在同一个二层广播域内，如果还需要通过DHCP服务器分配IP地址，则需要跨网段发送DHCP协议报文。</p>
<p>案例1</p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240526162219.png" alt="QQ截图20240526162219"></p>
<p>AC和AP在二层，DHCP服务器和AC不在同一网段，DHCP服务器给STA和AP分配ip地址，由于跨网段，所以在AC上配置中继</p>
<p>配置端口：略</p>
<p><strong>AR1：</strong></p>
<p>int g 0&#x2F;0&#x2F;1 </p>
<p>ip ad 172.168.12.1</p>
<p>dhcp enable</p>
<p>[Huawei-GigabitEthernet0&#x2F;0&#x2F;1]dhcp select global </p>
<p>配置地址组</p>
<p>ip pool 10<br> gateway-list 10.0.10.254<br> network 10.0.10.0 mask 255.255.255.0</p>
<p>ip pool 11<br> gateway-list 10.0.11.254<br> network 10.0.11.0 mask 255.255.255.0</p>
<p>配置静态路由</p>
<p>[Huawei]ip route-static 10.0.10.0 24 172.168.12.2<br>[Huawei]ip route-static 10.0.11.0 24 172.168.12.2</p>
<p><strong>AC：</strong></p>
<p>vlan b 10 11</p>
<p>int vlanif 10</p>
<p>ip ad 10.0.10.254 24</p>
<p>int vlanif 11</p>
<p>ip ad 10.0.11.254 24</p>
<p>int vlanif 1</p>
<p>ip ad 172.168.12.2 24 (与路由器相连接口ip)</p>
<p>配置中继：</p>
<p>interface Vlanif10<br> ip address 10.0.10.254 255.255.255.0<br> dhcp select relay<br> dhcp relay server-ip 172.168.12.1</p>
<p>interface Vlanif11<br> ip address 10.0.11.254 255.255.255.0<br> dhcp select relay<br> dhcp relay server-ip 172.168.12.1</p>
<p>capwap source interface vlanif 10（隧道）</p>
<p>此时ap可以获取ip地址</p>
<p>WLAN配置：略</p>
<p>sta查看ip</p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240526163258.png" alt="QQ截图20240526163258"></p>
<p>可以获取ip地址</p>
<p>案例2</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526171030.png" alt="QQ截图20240526171030" style="zoom:67%;">

<p>• 在AC和AP间是二层组网的情况下，也可以配置Option43，AP会根据Option43的内容先向</p>
<p>指定IP地址的AC发送单播请求报文，如果发送十次报文，AP都没有收到回应，则AP会继续</p>
<p>以广播的方式来发现同一网段的AC。所以在二层组网的情况下Option 43不是必配的参数，</p>
<p>但在三层组网的情况下则是必配的。</p>
<p>• Option 43即为Type值为43（0x2B）的Option字段，又称为厂商特定信息选项，DHCP服务</p>
<p>器和DHCP客户端通过Option43交换厂商特定的信息。当DHCP服务器接收到请求Option43</p>
<p>信息的DHCP请求报文后，将在回复报文中携带Option43，为DHCP客户端分配厂商指定的</p>
<p>信息（本文中特指AC的IP地址）。</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526171112.png" alt="QQ截图20240526171112" style="zoom:50%;">

<p>拓扑</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526171137.png" alt="QQ截图20240526171137" style="zoom:67%;">

<p>如图</p>
<p>AC和AP不在同一网段，S3作为relay给STA分配ip，AC2作为DHCP服务器给AP分配ip地址</p>
<p>配置：</p>
<p>配置端口：略</p>
<p><strong>S3：</strong></p>
<p>vlan b 20 21 100</p>
<p>int g 0&#x2F;0&#x2F;2</p>
<p>p l t</p>
<p>p t a v 100</p>
<p>int vlanif 100</p>
<p>ip add 192.168.100.3 (S3和AC之间通过vlanif100连接)</p>
<p>dhcp配置：</p>
<p>dhcp enable</p>
<p>interface Vlanif20<br> ip address 10.0.20.254 255.255.255.0<br> dhcp select relay<br> dhcp relay server-ip 192.168.100.2</p>
<p>interface Vlanif21<br> ip address 10.0.21.254 255.255.255.0<br> dhcp select interface</p>
<p>（给sta分配选择接口地址池）</p>
<p><strong>AC：</strong></p>
<p>vlan 100</p>
<p>配置dhcp：</p>
<p>dhcp enable</p>
<p>ip pool 20<br> gateway-list 10.0.20.254<br> network 192.168.100.0 mask 255.255.255.0<br> option 43 sub-option 3 ascii 192.168.100.2 （设置option43字段，ac的地址）</p>
<p>interface Vlanif100<br> ip address 192.168.100.2 255.255.255.0<br> dhcp select global</p>
<p>int g 0&#x2F;0&#x2F;1</p>
<p>p l t</p>
<p>p t a v 100</p>
<p>配置静态路由：</p>
<p> ip route-static 10.0.20.0 24 192.168.100.3</p>
<p>capwap隧道：</p>
<p>capwap source interface vlanif 100</p>
<p>此时ap可以获取ip</p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240526172328.png" alt="QQ截图20240526172328"></p>
<p>wlan配置：略</p>
<p>此时sta可以获取地址</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526172359.png" alt="QQ截图20240526172359" style="zoom:67%;">



<h1 id="漫游"><a href="#漫游" class="headerlink" title="漫游"></a>漫游</h1><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526202411.png" alt="QQ截图20240526202411" style="zoom:67%;">

<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526202604.png" alt="QQ截图20240526202604" style="zoom:67%;">

<p>• 二层漫游：1个无线客户端在2个AP（或多个AP）之间来回切换连接无线，前提是这些AP都</p>
<p>绑定的是同1个SSID并且业务VLAN都在同1个VLAN内（在同一个IP地址段），漫游切换的</p>
<p>过程中，无线客户端的接入属性（比如无线客户端所属的业务VLAN、获取的IP地址等属性）</p>
<p>不会有任何变化，直接平滑过渡，在漫游的过程中不会有丢包和断线重连的现象。</p>
<p>• 三层漫游：漫游前后SSID的业务VLAN不同，AP所提供的业务网络为不同的三层网络，对</p>
<p>应不同的网关。此时，为保持漫游用户IP地址不变的特性，需要将用户流量迂回到初始接入</p>
<p>网段的AP，实现跨VLAN漫游。</p>
<p>• 网络中有时候会出现以下情况：两个业务VLAN的VLAN ID相同，但是这两个子网又属于不</p>
<p>同的子网。此时为了避免系统仅仅依据VLAN ID将用户在两个子网间的漫游误判为二层漫</p>
<p>游，需要通过漫游域来确定设备是否在同一个子网内，只有当VLAN相同且漫游域也相同的</p>
<p>时候才是二层漫游，否则是三层漫游。</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526202744.png" alt="QQ截图20240526202744" style="zoom: 67%;">

<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526202850.png" alt="QQ截图20240526202850" style="zoom:67%;">

<p>• 配置漫游组。</p>
<p>▫ 如果指定了漫游组服务器，则需要在漫游组服务器上配置漫游组。</p>
<p>▫ 如果没有指定漫游组服务器，则各成员AC均需配置漫游组。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526203311.png" alt="QQ截图20240526203311" style="zoom:50%;">

<p>设备连接方式如图所示，AP1被AC1纳管，AP2被AC2纳管，所有AP都采用直接转发模式。</p>
<p>S4交换机二层透传AP2的管理、业务报文，S3作为AP管理流量、业务流量的网关。</p>
<p>S3开启DHCP服务为AP1、AP2分配管理地址、为无线终端分配业务地址，AP通过DHCP报文中的Option 43获取AC地址。</p>
<h4 id="1-1-1-1-数据规划"><a href="#1-1-1-1-数据规划" class="headerlink" title="1.1.1.1 数据规划"></a>1.1.1.1 数据规划</h4><table>
<thead>
<tr>
<th>配置项</th>
<th>配置参数</th>
</tr>
</thead>
<tbody><tr>
<td>AP管理VLAN</td>
<td>VLAN10、20</td>
</tr>
<tr>
<td>STA业务VLAN</td>
<td>VLAN11、21</td>
</tr>
<tr>
<td>DHCP服务器</td>
<td>S3作为DHCP服务器为AP分配IP地址</td>
</tr>
<tr>
<td>S3作为DHCP服务器为STA分配IP地址</td>
<td></td>
</tr>
<tr>
<td>AP的IP地址池</td>
<td>10.0.10.0&#x2F;24、10.0.20.0&#x2F;24</td>
</tr>
<tr>
<td>STA的IP地址池</td>
<td>10.0.11.0&#x2F;24、10.0.21.0&#x2F;24</td>
</tr>
<tr>
<td>AC的源接口IP地址</td>
<td>VLANIF100（10.0.100.254）、VLANIF200（10.0.200.254）</td>
</tr>
<tr>
<td>AP组</td>
<td>名称：ap-group1、ap-group2</td>
</tr>
<tr>
<td>引用模板：VAP模板departX</td>
<td></td>
</tr>
<tr>
<td>域管理模板</td>
<td>名称：default</td>
</tr>
<tr>
<td>国家码：中国（CN）</td>
<td></td>
</tr>
<tr>
<td>SSID模板</td>
<td>名称：departX</td>
</tr>
<tr>
<td>SSID名称：roam</td>
<td></td>
</tr>
<tr>
<td>安全模板</td>
<td>名称：departX</td>
</tr>
<tr>
<td>安全策略：WPA-WPA2+PSK+AES</td>
<td></td>
</tr>
<tr>
<td>密码：huawei123</td>
<td></td>
</tr>
<tr>
<td>VAP模板</td>
<td>名称：departX</td>
</tr>
<tr>
<td>转发模式：直接转发</td>
<td></td>
</tr>
<tr>
<td>业务VLAN：VLAN11、21</td>
<td></td>
</tr>
<tr>
<td>引用模板：SSID模板departX、安全模板departX</td>
<td></td>
</tr>
</tbody></table>
<p>DepartX中的X代表AC编号，即AC1上为depart1、AC2上为depart2。</p>
<p>S3设备配置</p>
<p>#</p>
<p>sysname S3</p>
<p>#</p>
<p>vlan batch 10 to 11 20 to 21 100 200</p>
<p>#</p>
<p>dhcp enable</p>
<p>#</p>
<p>ip pool ap1</p>
<p> gateway-list 10.0.10.1</p>
<p> network 10.0.10.0 mask 255.255.255.0</p>
<p> option 43 sub-option 3 ascii 10.0.100.254</p>
<p>#</p>
<p>ip pool ap2</p>
<p> gateway-list 10.0.20.1</p>
<p> network 10.0.20.0 mask 255.255.255.0</p>
<p> option 43 sub-option 3 ascii 10.0.200.254</p>
<p>#</p>
<p>ip pool service_a</p>
<p> gateway-list 10.0.11.1</p>
<p> network 10.0.11.0 mask 255.255.255.0</p>
<p> dns-list 10.0.11.1</p>
<p>#</p>
<p>ip pool service_b</p>
<p> gateway-list 10.0.21.1</p>
<p> network 10.0.21.0 mask 255.255.255.0</p>
<p> dns-list 10.0.21.1</p>
<p>#</p>
<p>interface Vlanif10</p>
<p> description ap1_mgnt</p>
<p> ip address 10.0.10.1 255.255.255.0</p>
<p> dhcp select global</p>
<p>#</p>
<p>interface Vlanif11</p>
<p> description ap1_service</p>
<p> ip address 10.0.11.1 255.255.255.0</p>
<p> dhcp select global</p>
<p>#</p>
<p>interface Vlanif20</p>
<p> description ap2_mgnt</p>
<p> ip address 10.0.20.1 255.255.255.0</p>
<p> dhcp select global</p>
<p>#</p>
<p>interface Vlanif21</p>
<p> description ap2_service</p>
<p> ip address 10.0.21.1 255.255.255.0</p>
<p> dhcp select global</p>
<p>#</p>
<p>interface Vlanif100</p>
<p> description to_AC1</p>
<p> ip address 10.0.100.1 255.255.255.0</p>
<p>#</p>
<p>interface Vlanif200</p>
<p> description to_AC2</p>
<p> ip address 10.0.200.1 255.255.255.0</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1</p>
<p> port link-type trunk</p>
<p> port trunk allow-pass vlan 100</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;2</p>
<p> port link-type trunk</p>
<p> port trunk allow-pass vlan 200</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p> port link-type trunk</p>
<p> port trunk allow-pass vlan 20 to 21</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;4</p>
<p> port link-type trunk</p>
<p> port trunk pvid vlan 10</p>
<p> port trunk allow-pass vlan 10 to 11</p>
<p>#</p>
<p>return</p>
<p>S4设备配置</p>
<p>#</p>
<p>sysname S4</p>
<p>#</p>
<p>vlan batch 20 to 21 </p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p> port link-type trunk</p>
<p> port trunk allow-pass vlan 20 to 21</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;4</p>
<p> port link-type trunk</p>
<p> port trunk pvid vlan 20</p>
<p> port trunk allow-pass vlan 20 to 21</p>
<p>#</p>
<p>return</p>
<p>AC1设备配置</p>
<p>#</p>
<p> sysname AC1</p>
<p>#</p>
<p>vlan batch 100</p>
<p>#</p>
<p>interface Vlanif100</p>
<p> description to_S3_CAPWAP</p>
<p> ip address 10.0.100.254 255.255.255.0</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;12</p>
<p> port link-type trunk</p>
<p> port trunk allow-pass vlan 100</p>
<p>#</p>
<p>ip route-static 10.0.10.0 255.255.255.0 10.0.100.1</p>
<p>ip route-static 10.0.200.0 255.255.255.0 10.0.100.1</p>
<p>#</p>
<p>capwap source interface vlanif100</p>
<p>#</p>
<p>wlan</p>
<p> security-profile name depart1</p>
<p> security wpa2 psk pass-phrase huawei123 aes</p>
<p> aes</p>
<p> ssid-profile name depart1</p>
<p> ssid roam</p>
<p> vap-profile name depart1</p>
<p> service-vlan vlan-id 11</p>
<p> ssid-profile depart1</p>
<p> security-profile depart1</p>
<p> regulatory-domain-profile name default</p>
<p> mobility-group name mobility（<strong>漫游组名称必须一致</strong>）</p>
<p> member ip-address 10.0.100.254</p>
<p> member ip-address 10.0.200.254</p>
<p> ap-group name depart1</p>
<p> radio 0</p>
<p>  vap-profile depart1 wlan 1</p>
<p> radio 1</p>
<p>  vap-profile depart1 wlan 1</p>
<p> radio 2</p>
<p>  vap-profile depart1 wlan 1</p>
<p>ap-id 0 type-id 56 ap-mac 00e0-fc6e-2890 ap-sn 210235448310F30CF56D</p>
<p> ap-name ap1</p>
<p> ap-group depart1</p>
<p> provision-ap</p>
<p>#</p>
<p>return</p>
<p>AC2设备配置</p>
<p>#</p>
<p> sysname AC2</p>
<p>#</p>
<p>vlan batch 200</p>
<p>#</p>
<p>interface Vlanif200</p>
<p> description to_S3_CAPWAP</p>
<p> ip address 10.0.200.254 255.255.255.0</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;13</p>
<p> port link-type trunk</p>
<p> port trunk allow-pass vlan 200</p>
<p>#</p>
<p>ip route-static 10.0.20.0 255.255.255.0 10.0.200.1</p>
<p>ip route-static 10.0.100.0 255.255.255.0 10.0.200.1</p>
<p>#</p>
<p>capwap source interface vlanif200</p>
<p>#</p>
<p>wlan</p>
<p> security-profile name depart2</p>
<p> security wpa-wpa2 psk pass-phrase huawei123 aes</p>
<p> ssid-profile name default</p>
<p> ssid-profile name depart2</p>
<p> ssid roam</p>
<p> vap-profile name depart2</p>
<p> service-vlan vlan-id 21</p>
<p> ssid-profile depart2</p>
<p> security-profile depart2</p>
<p> regulatory-domain-profile name default</p>
<p> mobility-group name mobility</p>
<p> member ip-address 10.0.100.254</p>
<p> member ip-address 10.0.200.254</p>
<p> ap-group name depart2</p>
<p> radio 0</p>
<p>  vap-profile depart2 wlan 1</p>
<p> radio 1</p>
<p>  vap-profile depart2 wlan 1</p>
<p> radio 2</p>
<p>  vap-profile depart2 wlan 1</p>
<p> ap-id 0 type-id 56 ap-mac 00e0-fcde-1990 ap-sn 210235448310FA145341</p>
<p> ap-name ap2</p>
<p> ap-group depart2</p>
<p> provision-ap</p>
<p>#</p>
<p>Return</p>
<h2 id="漫游注意事项"><a href="#漫游注意事项" class="headerlink" title="漫游注意事项"></a>漫游注意事项</h2><ul>
<li><p>实现WLAN漫游的两个AP必须使用<strong>相同的SSID和安全模板</strong>（安全模板名称可以不同，但是安全模板下的配置必须相同），认证模板的认证方式和认证参数也要配置相同。</p>
</li>
<li><p>漫游组内最多<strong>可以添加16个AC成员</strong>，AC一次只能加入到一个漫游组中，不可以同时加入多个漫游组。在高密等可能频繁发生AC间漫游的场景中，如果漫游组成员数过多，可能导致频繁出现漫游失败。对于此类场景，建议调整组网规划，使漫游组中存在4个以内成员AC。</p>
</li>
<li><p>同一漫游组内的AC必须使用相同的<strong>软件C版本</strong>，否则可能会导致AC间漫游失败。</p>
</li>
<li><p>AC间漫游建议采用规格相近的AC。不同型号AC的用户接入能力相差较大，当大规格AC的接入用户大量向小规格AC漫游时，超出小规格AC接入能力的部分用户会漫游失败。</p>
</li>
<li><p>配置漫游组时，需确保AC已配置CAPWAP源地址，否则漫游组不生效。</p>
</li>
<li><p><strong>AC间漫游与双链路热备功能互斥</strong>。</p>
</li>
<li><p>AGV漫游功能与空口扫描功能互斥。开启AGV功能后，AP上的对应射频将不支持空口扫描功能，依赖于扫描的业务如智能漫游、频谱导航、负载均衡等均不可用。</p>
</li>
<li><p>AC间<strong>漫游组名称必须一致</strong>。</p>
</li>
<li><p>WLAN AC和交换机之间不支持AC间漫游。</p>
</li>
<li><p>802.11r功能支持的安全策略包括开放式系统认证、WPA2+PSK+AES、WPA2+PPSK+AES和WPA2+802.1X+AES。</p>
</li>
<li><p>802.11r功能与PMF功能互斥，即如果已配置了802.11r功能，不能再配置PMF功能。</p>
</li>
<li><p>802.11r使用802.1X认证时，如果开启了802.1X重认证功能，部分终端可能因兼容性问题，在重认证阶段掉线后重新上线。</p>
</li>
<li><p>部分终端可能与802.11r漫游功能存在兼容性问题，导致漫游失败。不建议开启802.11r漫游功能。</p>
</li>
<li><p>如果两个AC上的PPSK配置保持一致，则PPSK用户支持AC间802.11r快速漫游；如果两个AC上的PPSK配置不一致，则PPSK用户不支持AC间802.11r快速漫游。</p>
</li>
<li><p>相同或不同漫游组成员（含漫游组服务器）的IP版本必须保持一致。如果配置了Navi AC，则漫游组成员与Navi AC成员（Navi AC和Local AC）的IP版本也必须保持一致。</p>
</li>
</ul>
<p>相同的SSID。</p>
<p>相同的VAP模板，且VAP ID必须相同。</p>
<p>相同的安全策略。</p>
<h1 id="高可靠性技术"><a href="#高可靠性技术" class="headerlink" title="高可靠性技术"></a>高可靠性技术</h1><p>• 热备份是指，当两台设备在确定主用（Master）设备和备用（Backup）设备后，由主用设</p>
<p>备进行业务的转发，而备用设备处于监控状态，同时主用设备实时向备用设备发送状态信</p>
<p>息和需要备份的信息，当主用设备出现故障后，备用设备及时接替主用设备的业务运行。</p>
<p><strong>• VRRP双机热备份</strong></p>
<p>▫ 主备AC两个独立的IP地址，通过VRRP对外虚拟为同一个IP地址，单个AP和虚拟IP建</p>
<p>立一条CAPWAP链路。</p>
<p>▫ 主AC备份AP信息、STA信息和CAPWAP链路信息，并通过HSB主备服务将信息同步给</p>
<p>备AC。主AC故障后，备AC直接接替工作。</p>
<p><strong>• 双链路热备份</strong></p>
<p>▫ 单个AP分别和主备AC建立CAPWAP链路，一条主链路，一条备链路。</p>
<p>▫ 主AC仅备份STA信息，并通过HSB主备服务将信息同步给备AC。主AC故障后，AP切</p>
<p>换到备链路上，备AC接替工作。</p>
<p><strong>• 双链路冷备份</strong></p>
<p>▫ 单个AP分别和主备AC建立CAPWAP链路，一条主链路，一条备链路。</p>
<p>▫ AC不备份同步信息。主AC故障后，AP切换到备链路上，备AC接替工作。</p>
<p><strong>• N+1备份</strong></p>
<p>▫ 单个AP只和一个AC建立CAPWAP链路。</p>
<p>▫ AC不备份同步信息。主AC故障后，AP重新与备AC建链CAPWAP链路，备AC接替工</p>
<p>作。</p>
<h2 id="VRRP双机热备"><a href="#VRRP双机热备" class="headerlink" title="VRRP双机热备"></a>VRRP双机热备</h2><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528173423.png" alt="QQ截图20240528173423" style="zoom:50%;">

<p><strong>AC目前支持VRRP单实例整机热备，不支持负载均衡。</strong></p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528173624.png" alt="QQ截图20240528173624" style="zoom:50%;">

<p>基于VRRP 的双机热备，热备相关的业务都注册到同一个HSB备份组，HSB备份组内部绑定</p>
<p>HSB服务，同时HSB备份组与一个VRRP实例绑定，从而业务通过HSB备份组获知当前用户</p>
<p>的主备状态、以及主备切换等事件，并通过HSB组的接口进行备份数据的接收和发送。</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528173733.png" alt="QQ截图20240528173733" style="zoom:67%;">

<p>HSB业务实时备份：</p>
<p>▫ 用户数据信息备份</p>
<p>▫ CAPWAP隧道信息备份</p>
<p>▫ AP表项备份</p>
<p>▫ DHCP地址信息备份</p>
<p>配置：</p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240528173854.png" alt="QQ截图20240528173854"></p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240528173925.png" alt="QQ截图20240528173925"></p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240528173944.png" alt="QQ截图20240528173944"></p>
<p>配置案例</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174047.png" alt="QQ截图20240528174047" style="zoom:67%;">

<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174108.png" alt="QQ截图20240528174108" style="zoom:67%;">

<p>AC2配置与AC1相同，此处不再赘述。</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174137.png" alt="QQ截图20240528174137" style="zoom:67%;">

<p>capwap隧道使用virtual-ip，capwap source ip-address 10.0.10.X</p>
<h2 id="双链路双机热备"><a href="#双链路双机热备" class="headerlink" title="双链路双机热备"></a>双链路双机热备</h2><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174326.png" alt="QQ截图20240528174326" style="zoom:67%;">

<p>该方案除了支持主备备份之外，还支持负载分担模式。负载分担模式下可以指定一部分AP</p>
<p>的主AC为AC1，与其建立CAPWAP主链路，一部分AP的主AC为AC2，与其建立CAPWAP主</p>
<p>链路。</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174415.png" alt="QQ截图20240528174415" style="zoom:67%;">

<p>• 建立主链路时，除了Discovery阶段要优选出主AC，其他过程跟正常情况下的CAPWAP隧道</p>
<p>建立过程一致。</p>
<p>• 在Discovery阶段，使能双链路备份功能后，AP开始发送Discovery Request报文，分为单播</p>
<p>方式和广播方式：</p>
<p>▫ 如果预先通过静态方式、DHCP服务器方式或DNS方式指定了主备AC的IP地址，AP向</p>
<p>AC发送单播Discovery Request报文请求与主备AC关联。</p>
<p>▫ 如果没有配置AC的静态IP地址或者单播没有回应时，AP将发送广播Discovery </p>
<p>Request报文请求同网段内可关联的AC。</p>
<p>• 不管是单播发现还是广播发现，如果主备AC都正常，都会回应Discovery Response报文，</p>
<p>并在该报文中携带双链路特性开关、优先级、负载情况以及IP地址。</p>
<p>• AP收集到主备AC回应的Discovery Response报文后，根据AC的优先级、设备的负载情况以</p>
<p>及AC IP地址来选择主AC并开始与其建立CAPWAP主链路，优选顺序如下：</p>
<p>▫ 比较AC的优先级，优先级值小的为主AC，默认优先级为0，最大值为7，优先级取值</p>
<p>越小，优先级越高。；</p>
<p>▫ 优先级相同情况下，比较AC设备的负载情况，即AP个数和STA个数，负载轻的为主</p>
<p>AC。优先选择当前可接入AP数大的AC为主AC，如果当前可接入AP数相同，则选择当</p>
<p>前可接入STA数大的AC为主AC；</p>
<p>▫ 负载相同情况下，比较IP地址，IP地址小的为主AC。</p>
<p>• 说明：当前可接入AP数&#x3D;可接入的最大AP数-当前已接入的AP数，当前可接入STA数&#x3D;可接</p>
<p>入的最大STA数-当前已接入的STA数</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174704.png" alt="QQ截图20240528174704" style="zoom:50%;">

<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174712.png" alt="QQ截图20240528174712" style="zoom:50%;">

<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174540.png" alt="QQ截图20240528174540" style="zoom: 67%;">

<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174548.png" alt="QQ截图20240528174548" style="zoom:67%;">

<h2 id="N-1备份"><a href="#N-1备份" class="headerlink" title="N+1备份"></a>N+1备份</h2><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174837.png" alt="QQ截图20240528174837" style="zoom:67%;">

<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240528174910.png" alt="QQ截图20240528174910"></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>vlan pool</tag>
        <tag>option 43</tag>
        <tag>漫游</tag>
      </tags>
  </entry>
  <entry>
    <title>子网划分</title>
    <url>/2024/03/24/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h1 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h1><p>首先为什么要子网划分？</p>
<p>有类IP地址规划的缺陷：使用默认掩码的问题：地址范围过大或过小，导致IP地址的浪费！</p>
<p>在一个网络地址中，主机数：2的n次方，可用的主机数：2*n-2（这里n是主机数）</p>
<p>如果这个网段只用于一个小型局域网，例如一个实验室，只有几十台主机，那么大大浪费了ip地址</p>
<p>所以，子网划分给这个网络地址分成若干个，减少浪费</p>
<p>相当于把主机数均匀的分配给若干个（网络号借位，主机号减少）</p>
<p>例如网络地址：192.168.1.0&#x2F;24，网络号24位，主机号8位，如果划成两个子网，网络号借1位</p>
<p>借的1位是1或者是0</p>
<p>192.168.1.<strong>0</strong>0000000（前25位变成网络号）子网1：192.168.1.0&#x2F;25</p>
<p>192.168.1.<strong>1</strong>0000000                                       子网2：192.168.128.0&#x2F;25</p>
<p>例：192.168.1.0  分配三个部门，每个部门30台主机</p>
<p>要借2位</p>
<p>00</p>
<p>01</p>
<p>10</p>
<p>11</p>
<p>这四种排列组合，分为四个子网</p>
<p>192.168.1.<strong>00</strong>  000000  –192.168.1.0&#x2F;26</p>
<p>192.168.1.<strong>01</strong>  000000   –192.168.1.64&#x2F;26</p>
<p>192.168.1.<strong>10</strong>  000000   –192.168.1.128&#x2F;26</p>
<p>192.168.1.<strong>11</strong>  000000   –192.168.1.192&#x2F;26</p>
<p><strong>子网划分的原理</strong></p>
<p>IP地址由网络位+主机位组成，子网划分就是借用现有网段的主机位的最左边某几位作为子网位，划分出多个子网。</p>
<p>①把原来有类网络IPv4地址中的“网络号”部分向“主机号”部分借位</p>
<p>②把一部分原来属于“主机号”部分的位变成“网络号”的一部分（通常称之为“子网号”）。</p>
<p>因此IP地址进行转变：网络号+主机号 变成 网络号+子网号（m）+主机号（n）</p>
<p>划分后子网数量：2*m</p>
<p>划分后每个子网可用主机数：2*n-2（主机号全为0和全为1（指二进制）的ip地址分别为网络地址与广播地址，是不能分配给某个特定的主机使用的）</p>
<p><strong>子网划分的步骤</strong></p>
<p>①　确定所需子网数2*m，</p>
<p>②　确定每个子网可用主机数2*n-2</p>
<p>③　确定需像主机号部分借多少位（m），才能满足需要求</p>
<p>④　根据主机数可得知子网地址空间大小2*n</p>
<p>⑤　进行地址划分</p>
<p>子网划分示例</p>
<p>某公司有四个部门，每个部门拥有50台主机，分配一个C类地址200.161.30.0&#x2F;24,请问如何进行网络地址规划？</p>
<p>a.确定子网数：四个部门，2*m&gt;&#x3D;4</p>
<p>b.确定主机数：30台主机，2*n-2&gt;&#x3D;30</p>
<p>c.C类地址网络号位24位，主机位8位，向第四段主机位借位，由上可知子网位m&#x3D;2，主机位n&#x3D;6</p>
<p>d.子网空间为64，子网数为4，根据原主机位八位则原网络空间为0-255，共256个，此时我们算出子网空间为64，可得出四个子网范围0-63、64-127、127-192、192-255</p>
<p>e. 第一个子网200.161.30.0&#x2F;26-200.161.30.63&#x2F;26</p>
<p>第二个子网200.161.30.64&#x2F;26-200.161.30.127&#x2F;26</p>
<p>第三个子网200.161.30.128&#x2F;26-200.161.30.191&#x2F;26</p>
<p>第四个子网200.161.39.192&#x2F;26-200.161.30.255&#x2F;26</p>
<p>f.主机位全为0和1的地址分别为网络地址与广播地址，不能分配给主机使用，则</p>
<p>部门1地址范围：200.161.30.1-62&#x2F;26</p>
<p>部门2地址范围：200.161.30.65-12&#x2F;26</p>
<p>部门3地址范围：200.161.30.129-190&#x2F;26</p>
<p>部门4地址范围：200.161.30.193-254&#x2F;26</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>子网划分</tag>
      </tags>
  </entry>
  <entry>
    <title>链路聚合</title>
    <url>/2023/12/07/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="什么是链路聚合"><a href="#什么是链路聚合" class="headerlink" title="什么是链路聚合"></a>什么是链路聚合</h2><p>在现网中，设备间如果通过一条链路连接，<strong>如果这条链路故障了，那么设备两端的终端就不能够通信了</strong>。有什么办法可以解决该问题呢？答案是——<strong>链路聚合</strong>。</p>
<p><strong>从端口的角度定义：</strong></p>
<p><strong>链路聚合（Link Aggregation）</strong>是指将<strong>多个物理端口</strong>汇聚在一起，形成一个<strong>逻辑端口</strong>，以实现出&#x2F;入流量吞吐量在各<strong>成员端口</strong>的负荷分担，交换机根据用户配置的端口负载分担方式决定数据包从哪个成员端口发送到对端的交换机。</p>
<p><strong>从链路的角度定义：</strong></p>
<p>链路聚合（Link Aggregation）是把两台设备之间的<strong>多条物理链路聚</strong>合在一起，当做一条<strong>逻辑链路</strong>来使用。这两台设备可以是一对路由器，一对交换机，或者是一台路由器和一台交换机。一条聚合链路可以包含多条成员链路，默认最多为<strong>8</strong>条。</p>
<h2 id="链路聚合的作用"><a href="#链路聚合的作用" class="headerlink" title="链路聚合的作用"></a>链路聚合的作用</h2><ul>
<li>链路聚合能够<strong>提高链路带宽</strong>。理论上，通过聚合几条链路，一个聚合口的带宽可以扩展为所有成员口带宽的总和，这样就有效地增加了逻辑链路的带宽。</li>
<li>链路聚合<strong>为网络提供了高可靠性</strong>。配置了链路聚合之后，如果一个成员接口发生故障，该成员口的物理链路会把流量切换到另一条成员链路上。</li>
<li>链路聚合<strong>在一个聚合口上实现负载均衡。</strong>一个聚合口可以把流量分散到多个不同的成员口上，通过成员链路把流量发送到同一个目的地，将网络产生拥塞的可能性降到最低。</li>
</ul>
<h2 id="三-链路聚合的工作原理："><a href="#三-链路聚合的工作原理：" class="headerlink" title="三. 链路聚合的工作原理："></a><strong>三. 链路聚合的工作原理：</strong></h2><p><strong>应用场景：</strong></p>
<p>链路聚合一般部署在核心结点，以便提升整个网络的数据吞吐量。</p>
<p>链路聚合能够提高链路带宽，增强网络可靠、可用性，支持负载分担。</p>
<p><strong>链路聚合模式:</strong></p>
<p>链路聚合包含两种模式：<strong>手动负载均衡模式</strong>和<strong>静态LACP（Link Aggregation Control Protocol）模式。</strong></p>
<ol>
<li><strong>手工负载分担模式：</strong></li>
</ol>
<ul>
<li>手工负载分担模式下，Eth-Trunk的建立、<strong>成员接口</strong>的加入由<strong>手工配置</strong>，没有链路聚合控制协议的参与。</li>
<li>该模式下所有<strong>活动链路</strong>都参与数据的转发，平均分担流量，因此称为<strong>负载分担模式</strong>。如果某条活动链路故障，链路聚合组自动在剩余的活动链路中平均分担流量。</li>
</ul>
<p><strong>使用场景：</strong></p>
<p>当需要在两个直连设备间提供<strong>一个较大的链路带宽而设备又不支持LACP协议</strong>时，可以使用手工负载分担模式。</p>
<p><strong>2. 静态LACP模式：</strong></p>
<ul>
<li>在静态LACP模式中，链路两端的设备相互发送<strong>LACP报文，协商聚合参数</strong>。协商完成后，两台设备确定活动接口和非活动接口。</li>
<li>在静态LACP模式中，需要手动创建一个Eth-Trunk口，并添加成员口。</li>
<li>静态LACP模式也叫<strong>M:N模式</strong>。M代表<strong>活动成员链路</strong>，用于在负载均衡模式中转发数据。N代表<strong>非活动链路</strong>，用于冗余备份。</li>
<li>如果一条活动链路发生故障，该链路传输的数据被切换到一条优先级最高的备份链路上，这条备份链路转变为活动状态。</li>
</ul>
<p><strong>两种链路聚合模式的主要区别：</strong></p>
<ul>
<li>在<strong>静态LACP模式中</strong>，一些链路充当备份链路。</li>
<li>在<strong>手动负载均衡模式</strong>中，所有的成员口都处于转发状态。</li>
</ul>
<table>
<thead>
<tr>
<th>维度</th>
<th>手工模式</th>
<th>LACP模式</th>
</tr>
</thead>
<tbody><tr>
<td>Eth-Trunk的建立方式</td>
<td>Eth-Trunk接口的创建、成员接口的加入由手工配置，没有链路聚合控制协议的参与。</td>
<td>Eth-Trunk接口的创建、成员接口的加入由手工配置，LACP协议参与链路动态调整，负责链路状态维护。在聚合条件发生变化时，自动调整或解散链路聚合。</td>
</tr>
<tr>
<td>设备是否需要支持LACP协议</td>
<td>不需要</td>
<td>需要</td>
</tr>
<tr>
<td>数据转发</td>
<td>正常情况下，所有链路都是活动链路。所有活动链路均参与数据转发。如果某条活动链路故障，链路聚合组自动在剩余的活动链路中分担流量。</td>
<td>正常情况下，部分链路是活动链路。所有活动链路均参与数据转发。如果某条活动链路故障，链路聚合组自动在非活动链路中选择一条链路作为活动链路，参与数据转发的链路数目不变。</td>
</tr>
<tr>
<td>检测故障</td>
<td>只能检测到同一聚合组内的成员链路有断路等故障，无法检测到链路断连、错连等故障。</td>
<td>不仅能够检测到同一聚合组内的成员链路有断路等故障，还可以检测到链路故障、链路错连等故障。</td>
</tr>
</tbody></table>
<p><strong>数据流控制:</strong></p>
<p>Eth-trunk链路两端相连的物理接口的数量、速率、双工方式、流控方式必须一致。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>0-65535 </p>
<p>默认32768</p>
<p>小的优先</p>
<p>优先级一样，看mac，mac小的优先</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><img src="/2023/12/07/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/juhetuopu31207160429.png" alt="juhetuopu31207160429"></p>
<h2 id="配置手工链路聚合"><a href="#配置手工链路聚合" class="headerlink" title="配置手工链路聚合"></a>配置手工链路聚合</h2><p># 创建Eth-Trunk接口</p>
<p>[S1]interface Eth-Trunk 1 </p>
<p><strong>interface eth-trunk</strong>命令用来进入已经存在的Eth-Trunk接口，或创建并进入Eth-Trunk接口。数字“1”代表接口编号，编号范围根据设备情况有所不同。</p>
<p>[S2]interface Eth-Trunk 1</p>
<p># 设置Eth-Trunk接口的聚合模式 </p>
<p>[S1-Eth-Trunk1]mode manual load-balance</p>
<p><strong>mode</strong>命令用来配置Eth-Trunk的工作模式，有LACP模式和手工负载分担模式（手工模式）两种，缺省情况下，Eth-Trunk的工作模式为手工负载分担模式。此处S1上的模式配置仅为示范目的，实际操作时不需要。</p>
<p># 将成员接口加入聚合组</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;10 </p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;10]eth-trunk 1 </p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;10]quit</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;11</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11]eth-trunk 1</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11]quit</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;12</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12]eth-trunk 1</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12]quit</p>
<p>可进入到成员接口的接口视图下，逐一添加到Eth-Trunk接口。也可以在Eth-Trunk接口视图下通过<strong>trunkport</strong>命令批量添加接口。</p>
<p>[S2]interface Eth-Trunk 1</p>
<p>[S2-Eth-Trunk1]trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12 </p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>将成员接口加入Eth-Trunk时，需要注意以下问题：</p>
<p>• 每个Eth-Trunk接口下最多可以包含8个成员接口。</p>
<p>• Eth-Trunk接口不能嵌套，即Eth-Trunk接口的成员接口不能是Eth-Trunk接口。</p>
<p>• 一个以太网接口只能加入到一个Eth-Trunk接口，如果需要加入其它Eth-Trunk接口，必须先退出原来的Eth-Trunk接口。</p>
<p>• 如果本地设备使用了Eth-Trunk，与成员接口直连的对端接口也必须捆绑为Eth-Trunk接口，两端才能正常通信。</p>
<p>Eth-Trunk链路两端相连的物理接口的数量、速率、双工方式等必须一致。</p>
<p>#查看Eth-Trunk接口状态</p>
<p>dis eth-trunk 1</p>
<h2 id="配置LACP模式"><a href="#配置LACP模式" class="headerlink" title="配置LACP模式"></a>配置LACP模式</h2><p># 删除现有Eth-Trunk接口下的成员接口</p>
<p>[S1]interface Eth-Trunk 1</p>
<p>[S1-Eth-Trunk1]undo trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12</p>
<p>[S2]interface Eth-Trunk 1</p>
<p>[S2-Eth-Trunk1]undo trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12</p>
<p><strong>在修改Eth-Trunk接口的聚合模式之前，需要确保Eth-Trunk中没有任何成员接口。</strong></p>
<p># 修改聚合模式</p>
<p>[S1]interface Eth-Trunk 1</p>
<p>[S1-Eth-Trunk1]mode lacp</p>
<p><strong>mode</strong> <strong>lacp</strong> 指定Eth-Trunk工作模式为LACP模式。</p>
<p>注：部分版本的设备命令为 mode lacp-static</p>
<p>[S2]interface Eth-Trunk 1</p>
<p>[S2-Eth-Trunk1]mode lacp</p>
<p># 将成员接口加入聚合组</p>
<p>[S1]interface Eth-Trunk 1</p>
<p>[S1-Eth-Trunk1]trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12</p>
<p>[S2]interface Eth-Trunk 1</p>
<p>[S2-Eth-Trunk1]trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12</p>
<p>查看</p>
<p><img src="/2023/12/07/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/1chakan1207160903.png" alt="1chakan1207160903"></p>
<p>注意此时三个接口都是Select的状态</p>
<h2 id="选择接口"><a href="#选择接口" class="headerlink" title="选择接口"></a>选择接口</h2><p>​	考虑到网络流量情况，当网络正常时，只需要GigabitEthernet0&#x2F;0&#x2F;11和GigabitEthernet0&#x2F;0&#x2F;12接口处于转发状态，GigabitEthernet0&#x2F;0&#x2F;10接口作为备份。但当活动接口数量少于2时，直接关闭整个Eth-Trunk接口。</p>
<p>全局配置优先级选举主动方，主动方设备的端口上配置接口优先级选举活动端口</p>
<p># 配置设备S1的LACP优先级，使其成为主动端设备</p>
<p>[S1]lacp priority 100 </p>
<p># 配置接口优先级，优选GigabitEthernet0&#x2F;0&#x2F;11和GigabitEthernet0&#x2F;0&#x2F;12接口</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;10 </p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;10]lacp priority 40000</p>
<p># 配置接口优先级，优选GigabitEthernet0&#x2F;0&#x2F;11和GigabitEthernet0&#x2F;0&#x2F;12接口</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;10 </p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;10]lacp priority 40000</p>
<p>g0&#x2F;0&#x2F;10配置了大于32768的优先级4000，所以变为备份端口</p>
<p>之后，g0&#x2F;0&#x2F;11和g0&#x2F;0&#x2F;12为活动端口</p>
<p>使能了LACP模式链路聚合的两端设备均会收发的LACPDU报文。</p>
<p>首先选举主动端设备：</p>
<ol>
<li>比较系统优先级字段，如果对端的系统优先级高于本端的系统优先级（默认为32768，越小越优），则确定对端为LACP主动端。</li>
<li>如果系统优先级相同，比较两端设备的MAC地址，MAC地址小的一端为LACP主动端。</li>
</ol>
<p>选出主动端后，两端都会以主动端的接口优先级来选择活动接口，接口优先级越小越优，默认为32768。</p>
<p># 配置Eth-trunk活动接口数上限阈值和下限阈值</p>
<p>[S1]interface Eth-Trunk 1</p>
<p>[S1-Eth-Trunk1]max active-linknumber 2</p>
<p>[S1-Eth-Trunk1]least active-linknumber 2</p>
<p>在一个Eth-Trunk接口内，活动接口数可以影响到Eth-Trunk接口的状态和带宽。Eth-Trunk接口的带宽是所有处于Up状态的成员口带宽之和。为保证Eth-Trunk接口的状态和带宽，可以设置以下两个阈值，以减小成员链路状态的变化带来的影响。</p>
<p>• 活动接口数下限阈值：当活动接口数小于配置的下限阈值时，Eth-Trunk接口的状态转为Down。设置活动接口数下限阈值的目的是为了保证最小带宽。<strong>least active-linknumber</strong>命令用来配置链路聚合组活动接口数目的下限阈值。</p>
<p>• 活动接口数上限阈值：当活动接口数达到上限阈值后，之后再发生成员链路状态变为Up都不会使Eth-Trunk接口的带宽增加。设置活动接口数上限阈值的目的是在保证了带宽的情况下提高网络的可靠性。<strong>max active-linknumber</strong>命令用来配置链路聚合组活动接口数目的上限阈值。</p>
<p># 开启抢占功能</p>
<p>[S1]interface Eth-Trunk 1</p>
<p>[S1-Eth-Trunk1]lacp preempt enable</p>
<p>在LACP模式下，当活动链路中出现故障链路时，系统会从备用链路中选择优先级最高的链路替代故障链路；如果被替代的故障链路恢复了正常，而且该链路的优先级又高于替代自己的链路。这种情况下，如果使能了LACP优先级抢占功能，高优先级链路会抢占低优先级链路，<strong>回切</strong>到活动状态。<strong>lacp preempt enable</strong>命令用来使能LACP模式下LACP优先级抢占的功能，缺省情况下，优先级抢占处于禁止状态。</p>
<p># 查看当前 Eth-Trunk接口状态</p>
<p><img src="/2023/12/07/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/2chakan2207161758.png" alt="2chakan2207161758"></p>
<p>shutdown接口g0&#x2F;0&#x2F;11和g0&#x2F;0&#x2F;12</p>
<p>查看状态，发现都变为unselect状态</p>
<p>由于设置了Eth-Trunk的活动链路下限阈值为2，所以聚合组中可用活动接口数量少于2时，整个聚合组对应的接口将会被关闭。尽管此时GigabitEthernet0&#x2F;0&#x2F;10处于UP状态，但是仍处于Unselect状态。</p>
<h2 id="修改负载分担模式"><a href="#修改负载分担模式" class="headerlink" title="修改负载分担模式"></a>修改负载分担模式</h2><p># 开启上一步中关闭的接口 </p>
<p>[S1]inter GigabitEthernet 0&#x2F;0&#x2F;11</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11]undo shutdown </p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11]quit</p>
<p>[S1]inter GigabitEthernet 0&#x2F;0&#x2F;12</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12]undo shutdown</p>
<p># 大约30秒后，查看当前Eth-Trunk1的接口状态</p>
<p>由于使能了Eth-Trunk接口的抢占功能，所以当GigabitEthernet0&#x2F;0&#x2F;11和GigabitEthernet0&#x2F;0&#x2F;12接口进入UP状态之后，这两个接口的接口的优先级高于GigabitEthernet0&#x2F;0&#x2F;10，所以GigabitEthernet0&#x2F;0&#x2F;10会进入unselect状态。同时因为系统为了保证链路的稳定性，默认的抢占延时为30秒，所以要在30秒后才会发生抢占。</p>
<p># 修改Eth-Trunk接口的负载分担模式为基于目的IP地址</p>
<p>[S1]interface Eth-Trunk 1</p>
<p>[S1-Eth-Trunk1]load-balance dst-ip</p>
<p>当需要将Eth-Trunk接口的流量分散到不同的链路上，最后能到达统一目的地时，使用load-balance命令配置Eth-Trunk接口负载分担模式，以确保出方向的流量在各物理链路间进行合理的负载分担，避免链路阻塞。由于负载分担只对出方向的流量有效，因此链路两端接口的负载分担模式可以不一致，两端互不影响</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>链路聚合</tag>
        <tag>lacp</tag>
        <tag>eth-trunk</tag>
      </tags>
  </entry>
  <entry>
    <title>组播</title>
    <url>/2024/05/10/%E7%BB%84%E6%92%AD/</url>
    <content><![CDATA[<h1 id="组播简介"><a href="#组播简介" class="headerlink" title="组播简介"></a>组播简介</h1><p>组播（Multicast）是在一台源IP主机和多台（一组）IP主机之间进行，中间的网络设备根</p>
<p>据接收者的需要，有选择性地对数据进行复制和转发。</p>
<p>• 组播技术有效地满足了单点发送、多点接收的需求，实现了IP网络中点到多点业务数据的高</p>
<p>效传送，能够大量节约网络带宽、降低网络负载。</p>
<p>• 组播分发树：组播流量的转发路径</p>
<p><strong>组播地址</strong>：224.0.0.0–239.255.255.255</p>
<p><strong>组播MAC：</strong></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/zubomac3553.png" alt="zubomac3553"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/zubokun53926.png" alt="zubokun53926"></p>
<p><strong>RPF检查：</strong></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/rpf4213.png" alt="rpf4213"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/rpf2154343.png" alt="rpf2154343"></p>
<h1 id="IGMPv1"><a href="#IGMPv1" class="headerlink" title="IGMPv1"></a>IGMPv1</h1><p>IGMPv1协议主要基于查询和响应机制完成组播组管理。当一个网段内有多个组播设备时，由于它们都可以接收到主机发送的成员报告报文，因此只需要选取其中一台组播设备发送查询报文，该组播设备称为IGMP查询器（Querier）。在IGMPv1中，由组播路由协议PIM选举出唯一的组播信息转发者（Assert Winner或DR）作为IGMP的查询器，负责该网段的组成员关系查询。</p>
<p>（不具备选举查询器，<strong>依赖PIM协议选举</strong>）</p>
<h2 id="IGMPv1报文"><a href="#IGMPv1报文" class="headerlink" title="IGMPv1报文"></a>IGMPv1报文</h2><p>IGMPv1报文封装在IP报文中，由8个字节组成。IGMPv1包括两种类型的报文：</p>
<ul>
<li><strong>普遍组查询报文</strong>（General Query）：查询器向共享网络上所有主机发送的查询报文，用于了解哪些组播组存在成员。（60s一次）</li>
<li><strong>成员报告报文</strong>（Report）：主机向查询器发送的报告报文，用于申请加入某个组播组或者应答查询报文。</li>
</ul>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/igmpgeshi155029.png" alt="igmpgeshi155029"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Version</td>
<td>IGMP版本，值为1。</td>
</tr>
<tr>
<td>Type</td>
<td>报文类型。该字段有以下两种取值：0x1：表示普遍组查询报文。0x2：表示成员报告报文。</td>
</tr>
<tr>
<td>Unused</td>
<td>在IGMPv1中，该字段在发送时被设为0，并在接收时被忽略。</td>
</tr>
<tr>
<td>Checksum</td>
<td>校验和。</td>
</tr>
<tr>
<td>Group Address</td>
<td>组播组地址。在普遍组查询报文中，该字段设为0；在成员报告报文中，该字段为成员加入的组播组地址。</td>
</tr>
</tbody></table>
<h2 id="查询组播组成员机制"><a href="#查询组播组成员机制" class="headerlink" title="查询组播组成员机制"></a>查询组播组成员机制</h2><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/shiyi5404.png" alt="shiyi5404"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/v1chaxun510155159.png" alt="v1chaxun510155159"></p>
<p>普遍组查询和响应过程如下：</p>
<ol>
<li><p>IGMP查询器发送目的地址为224.0.0.1（表示同一网段内所有主机和设备）的普遍组查询报文；收到该查询报文的组成员启动定时器。</p>
<p>普遍组查询报文是周期性发送的，发送周期可以通过命令配置。HostA和HostB作为组播组G1的成员，收到普遍组查询报文后，在本地启动定时器Timer-G1。</p>
</li>
<li><p>第一个定时器（10s）超时的组成员发送针对该组的报告报文。</p>
<p>假设HostA上的Timer-G1首先超时，HostA向该网段发送目的地址为G1的报告报文。也想加入组G1的HostB收到此报告报文，则停止定时器Timer-G1，不再发送针对G1的报告报文。<strong>这样报告报文被抑制</strong>，可以减少网段上的流量。</p>
</li>
<li><p>IGMP查询器接收到HostA的报告报文后，了解到本网段内存在组播组G1的成员，则由组播路由协议生成（<em>，G1）组播转发表项，“</em>”代表任意组播源。网络中一旦有组播组G1的数据到达DeviceA，将向该网段转发。</p>
</li>
</ol>
<h2 id="加组机制"><a href="#加组机制" class="headerlink" title="加组机制"></a>加组机制</h2><ol>
<li>主机HostC不等待普遍组查询报文的到来，主动发送针对G2的报告报文以声明加入组播组G2。</li>
<li>IGMP查询器接收到HostC的报告报文后，了解到本网段内出现了组播组G2的成员，则生成组播转发项（*，G2）。网络中一旦有G2的数据到达DeviceA，将向该网段转发。</li>
</ol>
<h2 id="离组机制"><a href="#离组机制" class="headerlink" title="离组机制"></a>离组机制</h2><p>IGMPv1没有专门定义离开组的报文。主机离开组播组后，停止发送成员报告报文。根据主机想要离开的组播组中是否还有其他成员，处理机制有所不同。如<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_igmp_cfg_0004.html#ZH-CN_CONCEPT_0000001176743865__fig_03">图2</a>所示。</p>
<ul>
<li><p>假设HostA想要退出组播组G1</p>
<p>HostA收到IGMP查询器发送的普遍组查询报文时，不再发送针对G1的报告报文。由于网段内还存在G1组成员HostB，HostB会向IGMP查询器发送针对G1的报告报文，因此IGMP查询器感知不到HostA的离开。</p>
</li>
<li><p>假设HostC想要退出组播组G2</p>
<p>HostC收到IGMP查询器发送的普遍组查询报文时，不再发送针对G2的报告报文。由于网段内不存在组G2的其他成员，IGMP查询器不会收到G2组成员的报告报文，则在一定时间（缺省值为130秒）后，删除G2所对应的组播转发表项。</p>
</li>
</ul>
<p>130&#x3D;60×2+10</p>
<h1 id="IGMPv2"><a href="#IGMPv2" class="headerlink" title="IGMPv2"></a>IGMPv2</h1><p>IGMPv2的工作机制与IGMPv1基本相同，最大的不同之处在于IGMPv2增加了查询器选举和离开组机制。IGMPv2可以使IGMP查询器及时了解到网段内哪些组播组已不存在成员，从而及时更新组成员关系，减少网络中冗余的组播流量。</p>
<p>与IGMPv1相比，IGMPv2的变化如下：</p>
<ul>
<li>除了普遍组查询报文和成员报告报文之外，IGMPv2新增了两种报文：<ul>
<li><strong>成员离开报文</strong>（Leave）：成员离开组播组时主动向查询器发送的报文，用于宣告自己离开了某个组播组。</li>
<li><strong>特定组查询报文</strong>（Group-Specific Query）：查询器向共享网段内<strong>指定组播组</strong>发送的查询报文，用于查询该组播组是否存在成员。</li>
</ul>
</li>
<li>IGMPv2对普遍组查询报文格式也做了改进，添加了最大响应时间（Max Response Time）字段。此字段取值可以通过命令配置，用于控制成员对于查询报文的响应速度。</li>
</ul>
<h2 id="IGMPv2报文："><a href="#IGMPv2报文：" class="headerlink" title="IGMPv2报文："></a>IGMPv2报文：</h2><p><strong>图1</strong> IGMPv2报文格式<br><img src="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/figure/zh-cn_image_0000001130624468.png" alt="img"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>Type</td>
<td align="left">报文类型。该字段有以下四种取值：0x11：表示查询报文。IGMPv2的查询报文包括普遍组查询报文和特定组查询报文两类。0x12：表示IGMPv1成员报告报文。0x16：表示IGMPv2成员报告报文。0x17：表示成员离开报文。</td>
</tr>
<tr>
<td>Max Response Time</td>
<td align="left">最大响应时间。成员主机在收到IGMP查询器发送的普遍组查询报文后，需要在最大响应时间内做出回应。该字段仅在IGMP查询报文中有效。</td>
</tr>
<tr>
<td>Checksum</td>
<td align="left">校验和。</td>
</tr>
<tr>
<td>Group Address</td>
<td align="left">组播组地址。在普遍组查询报文中，该字段设为0。在特定组查询报文中，该字段为要查询的组播组地址。在成员报告报文和离开报文中，该字段为成员要加入或离开的组播组地址。</td>
</tr>
</tbody></table>
<img src="/2024/05/10/%E7%BB%84%E6%92%AD/v235.png" alt="v235" style="zoom:80%;">

<h2 id="v2查询器选举机制"><a href="#v2查询器选举机制" class="headerlink" title="v2查询器选举机制"></a>v2查询器选举机制</h2><p>在IGMPv2中，查询器的选举过程如下：</p>
<ol>
<li><p>初始状态下，所有运行IGMPv2的组播设备（DeviceA和DeviceB）都认为自己是查询器，向本网段内的所有主机和组播设备发送普遍组查询报文。DeviceA和DeviceB在收到对方发送的普遍组查询报文后，将报文的源IP地址与自己的接口地址作比较。通过比较，IP地址最小的组播设备将成为查询器，其他组播设备成为非查询器。如图所示，DeviceA的接口地址小于DeviceB，则DeviceA当选为查询器，DeviceB为非查询器。</p>
</li>
<li><p>确定查询器后，将由IGMP查询器（DeviceA）向本网段内的所有主机和其他组播设备发送普遍组查询报文，而非查询器（DeviceB）则不再发送普遍组查询报文。</p>
<p>非查询器（DeviceB）上都会启动一个定时器（即其他查询器存在时间定时器Other Querier Present Timer）。在该定时器超时前，如果收到了来自查询器的查询报文，则重置该定时器；否则，就认为原查询器失效，并发起新的查询器选举过程。</p>
</li>
</ol>
<h2 id="v2离组机制"><a href="#v2离组机制" class="headerlink" title="v2离组机制"></a>v2离组机制</h2><p>在IGMPv2中，成员离开组播组时可以主动向查询器发送离开报文，宣告自己离开了某个组播组。</p>
<p>主机HostA离开组播组G1的过程如下：</p>
<ol>
<li>HostA向本地网段内的所有组播设备（目的地址为224.0.0.2）发送针对组G1的离开报文。</li>
<li>查询器收到离开报文，会发送针对组G1的特定组查询报文。发送间隔和发送次数可以通过命令配置，缺省情况下每隔1秒发送一次，共发送两次。同时查询器启动组成员关系定时器（Timer-Membership&#x3D;发送间隔x发送次数）。</li>
<li>如果该网段内还存在组G1的其他成员（如HostB），这些成员在收到查询器发送的特定组查询报文后，会立即发送针对组G1的报告报文。查询器收到针对组G1的报告报文后将继续维护该组成员关系。如果该网段内不存在组G1的其他成员，查询器将不会收到针对组G1的报告报文。在Timer-Membership超时后，查询器将删除（*，G1）对应的IGMP组表项。当有组G1的组播数据到达查询器时，查询器将不会向下游转发。</li>
</ol>
<h1 id="IGMPv3"><a href="#IGMPv3" class="headerlink" title="IGMPv3"></a>IGMPv3</h1><p>IGMPv3主要是为了配合SSM（Source-Specific Multicast）模型发展起来的，提供了在报文中携带组播源信息的能力，即主机可以对组播源进行选择。</p>
<p>与IGMPv2相比，IGMPv3报文的变化如下：</p>
<ul>
<li>IGMPv3报文包含两大类：查询报文和成员报告报文。<strong>IGMPv3没有定义专门的成员离开报文</strong>，成员离开通过特定类型的报告报文来传达。</li>
<li>查询报文中不仅包含普遍组查询报文和特定组查询报文，还新增了<strong>特定源组查询报文</strong>（Group-and-Source-Specific Query）。该报文由查询器向共享网段内特定组播组成员发送，用于查询该组成员是否愿意接收特定源发送的数据。特定源组查询通过在报文中携带一个或多个组播源地址来达到这一目的。</li>
<li>成员报告报文不仅包含主机想要加入的组播组，而且包含主机想要接收来自哪些组播源的数据。IGMPv3增加了针对组播源的过滤模式（INCLUDE&#x2F;EXCLUDE），将组播组与源列表之间的对应关系简单的表示为（G，INCLUDE，(S1、S2…)），表示只接收来自指定组播源S1、S2……发往组G的数据；或（G，EXCLUDE，(S1、S2…)），表示接收除了组播源S1、S2……之外的组播源发给组G的数据。当组播组与组播源列表的对应关系发生了变化，IGMPv3报告报文会将该关系变化存放于组记录（Group Record）字段，发送给IGMP查询器。</li>
<li>在IGMPv3中一个成员报告报文可以携带多个组播组信息，而之前的版本一个成员报告只能携带一个组播组。这样在IGMPv3中报文数量大大减少。</li>
</ul>
<h2 id="IGMPv3报文"><a href="#IGMPv3报文" class="headerlink" title="IGMPv3报文"></a>IGMPv3报文</h2><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/v3cahx61552.png" alt="v3cahx61552"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Type</td>
<td>报文类型，取值为0x11。</td>
</tr>
<tr>
<td>Max Response Code</td>
<td>最大响应时间。成员主机在收到IGMP查询器发送的普遍组查询报文后，需要在最大响应时间内做出回应。</td>
</tr>
<tr>
<td>Checksum</td>
<td>校验和。</td>
</tr>
<tr>
<td>Group Address</td>
<td>组播组地址。在普遍组查询报文中，该字段设为0；在特定组查询报文和特定源组查询报文中，该字段为要查询的组播组地址。</td>
</tr>
<tr>
<td>Resv</td>
<td>保留字段。发送报文时该字段设为0；接收报文时，对该字段不做处理。</td>
</tr>
<tr>
<td>S</td>
<td>该比特位为1时，所有收到此查询报文的其他设备不启动定时器刷新过程，但是此查询报文并不抑制查询器选举过程和设备的主机侧处理过程。</td>
</tr>
<tr>
<td>QRV</td>
<td>如果该字段非0，则表示查询器的健壮系数（Robustness Variable）。如果该字段为0，则表示查询器的健壮系数大于7。设备接收到查询报文时，如果发现该字段非0，则将自己的健壮系数调整为该字段的值；如果发现该字段为0，则不做处理。</td>
</tr>
<tr>
<td>QQIC</td>
<td>IGMP查询器的查询间隔，单位为秒。非查询器收到查询报文时，如果发现该字段非0，则将自己的查询间隔参数调整为该字段的值；如果发现该字段为0，则不做处理。</td>
</tr>
<tr>
<td>Number of Sources</td>
<td>报文中包含的组播源的数量。对于普遍组查询报文和特定组查询报文，该字段为0；对于特定源组查询报文，该字段非0。此参数的大小受到所在网络MTU大小的限制。</td>
</tr>
<tr>
<td>Source Address</td>
<td>组播源地址，其数量受到Number of Sources字段值大小的限制。</td>
</tr>
</tbody></table>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/v3baog18.png" alt="v3baog18"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Type</td>
<td>报文类型，取值为0x22。</td>
</tr>
<tr>
<td>Reserved</td>
<td>保留字段。发送报文时该字段设为0；接收报文时，对该字段不做处理。</td>
</tr>
<tr>
<td>Checksum</td>
<td>IGMP报文的校验和。校验和是IGMP报文长度（即IP报文的整个有效负载）的16位检测，表示IGMP信息补码之和的补码。Checksum字段在进行校验计算时设为0。当发送报文时，必须计算校验和并插入到Checksum字段中去。当接收报文时，校验和必须在处理该报文之前进行检验。</td>
</tr>
<tr>
<td>Number of Group Records (M)</td>
<td>报文中包含的组记录的数量。</td>
</tr>
<tr>
<td>Group Record</td>
<td>组记录。Group Record字段的格式如<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_igmp_cfg_0006.html#ZH-CN_CONCEPT_0000001130784226__fig_dc_fd_igmp_100803">图3</a>所示，解释如<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_igmp_cfg_0006.html#ZH-CN_CONCEPT_0000001130784226__tab_dc_fd_igmp_100803">表3</a>所示。</td>
</tr>
</tbody></table>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/tusan61812.png" alt="tusan61812"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Record Type</td>
<td>组记录的类型。共分为三大类。当前状态报告。用于对查询报文进行响应，通告自己目前的状态，共两种：MODE_IS_INCLUDE，表示接收源地址列表包含的源发往该组的组播数据。如果指定源地址列表为空，该报文无效。MODE_IS_EXCLUDE，表示不接收源地址列表包含的源发往该组的组播数据。过滤模式改变报告。当组和源的关系在INCLUDE和EXCLUDE之间切换时，会通告过滤模式发生变化，共两种：CHANGE_TO_INCLUDE_MODE，表示过滤模式由EXCLUDE转换到INCLUDE，接收源地址列表包含的新组播源发往该组播组的数据。如果指定源地址列表为空，主机将离开组播组。CHANGE_TO_EXCLUDE_MODE，表示过滤模式由INCLUDE转换到EXCLUDE，拒绝源地址列表包含的新组播源发往该组的组播数据。源列表改变报告。当指定源发生改变时，会通告源列表发生变化，共两种：ALLOW_NEW_SOURCES，表示在现有的基础上，需要接收源地址列表包含的组播源发往该组播组的组播数据。如果当前对应关系为INCLUDE，则向现有源列表中添加这些组播源；如果当前对应关系为EXCLUDE，则从现有阻塞源列表中删除这些组播源。BLOCK_OLD_SOURCES，表示在现有的基础上，不再接收源地址列表包含的组播源发往该组播组的组播数据。如果当前对应关系为INCLUDE，则从现有源列表中删除这些组播源；如果当前对应关系为EXCLUDE，则向现有源列表中添加这些组播源。</td>
</tr>
<tr>
<td>Aux Data Len</td>
<td>辅助数据长度。在IGMPv3的报告报文中，不存在辅助数据字段，该字段设为0。</td>
</tr>
<tr>
<td>Number of Sources (N)</td>
<td>本记录中包含的源地址数量。</td>
</tr>
<tr>
<td>Multicast Address</td>
<td>组播组地址。</td>
</tr>
<tr>
<td>Source Address</td>
<td>组播源地址。</td>
</tr>
<tr>
<td>Auxiliary Data</td>
<td>辅助数据。预留给IGMP后续扩展或后续版本。在IGMPv3的报告报文中，不存在辅助数据。</td>
</tr>
</tbody></table>
<h2 id="IGMPv3工作机制"><a href="#IGMPv3工作机制" class="headerlink" title="IGMPv3工作机制"></a>IGMPv3工作机制</h2><p>在工作机制上，与IGMPv2相比，IGMPv3增加了主机对组播源的选择能力。</p>
<p><strong>特定源组加入</strong></p>
<p>IGMPv3的成员报告报文的目的地址为224.0.0.22（表示同一网段所有使能IGMPv3的设备）。通过在报告报文中携带组记录，主机在加入组播组的同时，能够明确要求接收或不接收特定组播源发出的组播数据。如<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_igmp_cfg_0006.html#ZH-CN_CONCEPT_0000001130784226__fig_01">图4</a>所示，网络中存在S1和S2两个组播源，均向组播组G发送组播数据，Host仅希望接收从组播源S1发往组播组G的信息。</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/tedingh047.png" alt="tedingh047"></p>
<p>如果Host和组播设备之间运行的是IGMPv1或IGMPv2，Host加入组播组G时无法对组播源进行选择，无论其是否需要，都会同时接收到来自组播源S1和S2的数据。如果采用IGMPv3，成员主机可以发送IGMPv3报告（G，INCLUDE，(S1)），选择仅接收源S1向组播组G发送的数据。</p>
<p><strong>特定源组查询</strong></p>
<p>当接收到组成员发送的改变组播组与源列表的对应关系的报告时（比如CHANGE_TO_INCLUDE_MODE、CHANGE_TO_EXCLUDE_MODE），IGMP查询器会发送特定源组查询报文。如果组成员希望接收其中任意一个源的组播数据，将反馈报告报文。IGMP查询器根据反馈的组成员报告更新该组对应的源列表。</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/v3jiazu2434.png" alt="v3jiazu2434"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/v3lizu2449.png" alt="v3lizu2449"></p>
<h2 id="各个版本比较"><a href="#各个版本比较" class="headerlink" title="各个版本比较"></a>各个版本比较</h2><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/cahyi540.png" alt="cahyi540"></p>
<h1 id="IGMP-Snooping"><a href="#IGMP-Snooping" class="headerlink" title="IGMP Snooping"></a>IGMP Snooping</h1><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/Snooping5041.png" alt="Snooping5041"></p>
<p>当Router将组播报文转发至Switch以后，Switch负责将组播报文转发给组播用户。由于组</p>
<p>播报文的目的地址为组播组地址，在二层设备上是学习不到这一类MAC表项的，因此组播</p>
<p>报文就会在所有接口进行广播，和它在同一广播域内的组播成员和非组播成员都能收到组</p>
<p>播报文。这样不但浪费了网络带宽，而且影响了网络信息安全。</p>
<p>• IGMP Snooping有效地解决了这个问题。配置IGMP Snooping后，二层组播设备可以侦听</p>
<p>和分析组播用户和上游路由器之间的IGMP报文，根据这些信息建立二层组播转发表项，控</p>
<p>制组播数据报文转发。这样就防止了组播数据在二层网络中的广播。</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/sjies153.png" alt="sjies153"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/jiekou165325.png" alt="jiekou165325"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/zhuafabiao5448.png" alt="zhuafabiao5448"></p>
<p>• 路由器端口形成后会启动老化计时器（默认180s）,当路由器端口收到新的普遍组查询后刷</p>
<p>新该计时器。</p>
<p>• 成员端口形成后会启动老化计时器（默认180s）,当成员端口收到新的成员关系报告报文后</p>
<p>刷新该计时器。</p>
<p>• IGMP Snooping不再使用成员关系报告报文抑制机制：</p>
<p>▫ 由于IGMP Snooping需要监听IGMP报文才能决定端口角色，进而指导转发，所以所</p>
<p>有组成员都需要发送IGMP组成员关系报告报文。</p>
<p>▫ 当IGMP Snooping设备收到成员关系报告报文后，只将成员关系报告报文从路由器接</p>
<p>口发送出去，从而避免其余组成员收到成员关系报告报文，不触发成员关系报告报文</p>
<p>抑制机制。</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/weihu65557.png" alt="weihu65557"></p>
<p>• 收到IGMP离开报文后，成员端口的老化定时器 &#x3D; 健壮系数（默认2） x 特定组查询间隔</p>
<p>（默认1s）。</p>
<h1 id="IGMP-SSM-Mapping"><a href="#IGMP-SSM-Mapping" class="headerlink" title="IGMP SSM Mapping"></a>IGMP SSM Mapping</h1><p>SSM（Source-Specific Multicast）称为指定源组播，要求设备能了解成员主机加入组播组时所指定的组播源。如果成员主机上运行IGMPv3，可以在IGMPv3报告报文中直接指定组播源地址。但是某些情况下，成员主机只能运行IGMPv1或IGMPv2，为了使其也能够使用SSM服务，设备上需要提供IGMP SSM Mapping功能。</p>
<p>IGMP SSM Mapping的机制是：通过在设备上静态配置SSM地址的映射规则，将IGMPv1和IGMPv2报告报文中的（*, G）信息转化为对应的（G, INCLUDE, (S1, S2…)）信息，以提供SSM组播服务。</p>
<p>配置了SSM Mapping规则后，当IGMP查询器收到来自成员主机的IGMPv1或IGMPv2报告报文时，首先检查该报文中所携带的组播组地址G，然后根据检查结果的不同分别进行处理。</p>
<ul>
<li>如果G在ASM（Any-Source Multicast）范围内，则只提供ASM服务。</li>
<li>如果G在SSM组地址范围内（缺省情况下为232.0.0.0～232.255.255.255）：<ul>
<li>如果设备上没有G对应的SSM Mapping规则，则无法提供SSM服务，丢弃该报文。</li>
<li>如果设备上有G对应的SSM Mapping规则，则依据规则将报告报文中所包含的（*, G）信息映射为（G, INCLUDE, (S1, S2…)）信息，提供SSM服务。</li>
</ul>
</li>
</ul>
<p>SSM网络的用户网段中HostA运行IGMPv3、HostB运行IGMPv2、HostC运行IGMPv1。HostB和HostC无法升级到IGMPv3，如果要为该网段中的所有主机提供SSM服务，需要在IGMP查询器（Device）上使能IGMP SSM Mapping并配置相应的映射规则。</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/mm0923.png" alt="mm0923"></p>
<p>假如在Device上配置如下映射关系：</p>
<table>
<thead>
<tr>
<th>组播组地址</th>
<th>映射的组播源地址</th>
</tr>
</thead>
<tbody><tr>
<td>232.0.0.0&#x2F;8</td>
<td>10.10.1.1</td>
</tr>
<tr>
<td>232.1.0.0&#x2F;16</td>
<td>10.10.2.2</td>
</tr>
<tr>
<td>232.1.0.0&#x2F;16</td>
<td>10.10.3.3</td>
</tr>
<tr>
<td>232.1.1.0&#x2F;24</td>
<td>10.10.4.4</td>
</tr>
</tbody></table>
<p>经过映射后，Device收到HostB和HostC的成员报告报文时，首先判断报文携带的组地址是否在SSM范围内，发现在SSM范围内，则根据配置的映射规则生成如下所示的组播表项。如果一个组地址映射了多个源，则生成多个（S，G）表项。</p>
<p>在映射过程中，一个组播组地址只要能在规则中匹配到，都会生成一条相应的表项。因此232.1.1.1有四条表项，232.1.2.2有三条表项。</p>
<table>
<thead>
<tr>
<th align="left">IGMPv1&#x2F;IGMPv2报告报文中的组地址</th>
<th>生成的组播表项</th>
</tr>
</thead>
<tbody><tr>
<td align="left">232.1.1.1 （来自HostC）</td>
<td>（10.10.1.1，232.1.1.1）（10.10.2.2，232.1.1.1）（10.10.3.3，232.1.1.1）（10.10.4.4，232.1.1.1）</td>
</tr>
<tr>
<td align="left">232.1.2.2 （来自HostB）</td>
<td>（10.10.1.1，232.1.2.2）（10.10.2.2，232.1.2.2）（10.10.3.3，232.1.2.2）</td>
</tr>
</tbody></table>
<h1 id="IGMP-Proxy"><a href="#IGMP-Proxy" class="headerlink" title="IGMP Proxy"></a>IGMP Proxy</h1><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/p1171231.png" alt="p1171231"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/p2171311.png" alt="p2171311"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/p371410.png" alt="p371410"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/plizu10171452.png" alt="plizu10171452"></p>
<h1 id="PIM-DM"><a href="#PIM-DM" class="headerlink" title="PIM DM"></a>PIM DM</h1><p>PIM-DM：密集模式，采用的是“推”模式，适用于成员比较少，相对密集的场景</p>
<p>PIM-SM：稀疏模式  采用的是“拉”模式，适用于成员多，但是成员不集中的场景</p>
<p>PIM（Protocol Independent Multicast，协议无关组播）是域内组播路由协议，利用单播路由信息，对组播消息进行RPF检查，创建组播路由表项。为IP组播提供路由信息的协议可以是任何单播路由协议，比如静态路由、RIP、OSPF、IS-IS、BGP等。组播路由和单播路由协议无关，只是通过单播路由表产生相应组播路由表项。</p>
<p>目前在实际网络中，PIM协议有三种模式：PIM-DM、使用ASM（Any-Source Multicast）模型的PIM-SM，使用SSM（Source-Specific Multicast）模型的PIM-SM。需要注意的是，同一个PIM域中不能同时运行PIM-DM和PIM-SM。</p>
<p>PIM协议中依据组播分发树转发数据，组播分发树有两种，<strong>SPT和RPT</strong></p>
<p>以组播源为根，组播组成员为叶子的组播分发树称为SPT（Shortest Path Tree），在PIM-DM与PIM-SM中均有使用。<br>以RP（Rendezvous Point）为根，组播组成员为叶子的组播分发树称为RPT（RP Tree），在PIM-SM中使用。</p>
<p>PIM-DM域中组播数据转发的实现过程是：</p>
<ol>
<li>邻居发现Neighbor Discovery）：在PIM-DM域中，PIM设备通过周期性的向所有其他PIM设备发送<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>，来发现PIM邻居，维护PIM设备之间的PIM邻居关系。缺省情况下，无论PIM设备是否收到来自邻居的Hello消息，都会接收其他的PIM控制消息或组播报文。但是如果PIM设备配置了邻居检查功能，则只有在PIM设备接收到来自邻居的Hello消息后，才会接收其他的PIM控制消息或组播报文。</li>
<li>扩散Flooding）：PIM-DM假设网络中的每个子网都存在至少一个组播组成员，因此组播数据将被扩散到网络中的所有节点，网络中所有的PIM设备都能接收到组播数据。</li>
<li>剪枝（Prune）：组播数据扩散到网络中后，PIM-DM对没有组播数据接收者的分支进行剪枝，只保留包含接收者的分支，即确保网络中只有需要组播数据的PIM设备能够接收到组播数据，不需要组播数据的PIM设备接收不到组播数据。</li>
<li>状态刷新（State-Refresh）：如果设备处于剪枝状态，其上游PIM设备会维护一个“剪枝定时器”。当剪枝定时器超时，上游PIM设备恢复对不需要数据的下游PIM设备的数据转发，这样会导致不必要的网络资源浪费。采用状态刷新可使离组播源最近的第一跳设备周期性发送State-Refresh消息，刷新所有设备的剪枝定时器状态，对不需要数据的下游设备始终保持剪枝状态。</li>
<li>嫁接Graft）：当被剪枝分支的节点上出现了组播组成员时，为了减少该节点恢复成转发状态所需的时间，PIM-DM使用嫁接机制主动恢复其对组播数据的转发。</li>
<li>断言（Assert）：如果在一个网段内出现多台PIM设备，则相同的组播报文可能会被重复发送到该网段。通过<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0006.html#ZH-CN_CONCEPT_0000001176663373__section_dc_vrp_multicast_feature_311109">断言</a>可以为网段选定唯一的组播数据转发者，避免冗余的组播数据转发。</li>
</ol>
<h2 id="邻居发现"><a href="#邻居发现" class="headerlink" title="邻居发现"></a>邻居发现</h2><p>PIM设备在每个使能了PIM的接口上，都会对外发送Hello消息。封装<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>的组播报文有如下特点：</p>
<ul>
<li>目的地址是224.0.0.13，表示同一网段中所有PIM设备</li>
<li>源地址为接口的IP地址</li>
<li>TTL数值为1，仅发送给邻居接口</li>
</ul>
<p><a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>具有发现邻居、协商各项协议参数、维持邻居关系的作用。</p>
<p><strong>发现PIM邻居</strong></p>
<p>同一网段中的PIM设备都必须接收目的地址为224.0.0.13的组播报文。这样在收到<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>以后，直接相连的组播设备之间，就可以知道自己的邻居信息。</p>
<p><strong>协商各项协议参数</strong></p>
<p><a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>中携带多项协议参数，邻居之间通过<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>来进行协商，这些参数包括：</p>
<ul>
<li>DR_Priority：表示各设备接口竞选DR的优先级，优先级越高越容易获胜。</li>
<li>Holdtime：表示保持邻居为可达状态的超时时间。</li>
<li>LAN_Delay：表示共享网段内传输Prune消息的延迟时间。</li>
<li>Override-Interval：表示Hello消息]中携带的否决剪枝的时间间隔。</li>
</ul>
<p><strong>维持邻居关系</strong></p>
<p>PIM设备之间周期性地发送<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>。如果Holdtime超时还没有收到该PIM邻居发出的新的<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>，则认为该邻居不可达，将其从邻居列表中清除。</p>
<p>PIM邻居的变化将导致网络中组播拓扑的变化。如果组播分发树上的某上游邻居或下游邻居不可达，将导致组播路由重新收敛，组播分发树迁移。</p>
<p>维护邻居关系  30s  邻居超时时间105s</p>
<h2 id="扩散机制"><a href="#扩散机制" class="headerlink" title="扩散机制"></a>扩散机制</h2><p>全网建立（S，G）路由表项    组播源开始发送组播数据，组播数据全网进行转发，生成（S，G ）表项，表项默认老化时间210s，，超过210s没有组播数据转发，将删除表项，有组播 数据的时候重新建立表项</p>
<p>扩散机制会周期性（默认180s）全网扩散组播数据，周期性扩散的主要目的是探测是否有新成员加组，但是由于全网扩散组播数据会浪费大量带宽，所以现在的组播网络一般使用“状态刷新机制”加上“嫁接机制”来实现周期性全网扩散感知新成员加组的目的。</p>
<h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>如果路由器下游没有组成员，将向上游发起剪枝，剪到最后一个不需要发组播报文的路由器</p>
<p>剪枝接口会有一个计时器，210s，计时器超时，接口将加入下游接口，转发组播报文</p>
<h2 id="状态刷新机制"><a href="#状态刷新机制" class="headerlink" title="状态刷新机制"></a>状态刷新机制</h2><p>状态刷新报文60s发一次</p>
<p>对于剪枝端口而言，收到状态刷新报文，计时器将重置</p>
<p>离组播源最近的第一跳路由器周期性触发State-Refresh消息。State-Refresh消息在全网扩散，刷新所有设备上的剪枝定时器状态，对不需要数据的下游设备始终保持剪枝状态。</p>
<h2 id="嫁接"><a href="#嫁接" class="headerlink" title="嫁接"></a>嫁接</h2><p>一旦有新成员加入，叶子路由器会基于本地的组播路由表向上游发送Graft报文，请求上游路由器恢复相应出接口转发，将其添加在（S，G）表项下游接口列表中。</p>
<p>下游发送Graft消息，请求上游恢复对应出接口的转发。上游收到Graft消息后，将下游的出接口恢复转发</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在组播网络中，如果出现如下情况，则说明网段上还存在着其他的组播转发者。</p>
<ul>
<li>该组播报文不能通过RPF检查。</li>
<li>接收到该组播报文的接口是本设备上（S，G）表项中的一个下游接口。</li>
</ul>
<p>此时，设备会执行Assert机制。设备从该下游接口发送<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>。同时，该下游接口也接收到了来自该网段上其他组播转发者的<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>。<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>的目的地址为224.0.0.13，源地址为下游接口地址，TTL为1。<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>中携带该PIM设备到组播源或RP的开销、所采用的单播路由协议的优先级和组播组地址G。</p>
<p>设备将自身条件与对方报文中携带的信息进行比较，称为Assert竞选。<strong>规则如下</strong>：</p>
<ol>
<li><strong>单播路由协议优先级较高者获胜。</strong></li>
<li><strong>如果优先级相同，则到组播源或RP的开销较小者获胜。</strong></li>
<li><strong>如果以上都相同，则下游接口IP地址最大者获胜。</strong></li>
</ol>
<p>根据Assert竞选结果，设备将执行不同的操作：</p>
<ul>
<li>如果获胜，则该下游接口保持转发状态，设备负责后续在该网段上的（S，G）转发，该下游接口称为Assert winner。</li>
<li>如果落败，则禁止该下游接口转发组播报文，将其从（S，G）表项下游接口列表中删除。该下游接口称为Assert loser。</li>
</ul>
<p>Assert竞选结束后，该网段上只存在一个有下游接口的上游设备，只传输一份组播报文。Assert winner周期性发送<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>，维持Assert winner的状态。若Assert loser的定时器超时后，Assert loser仍没有收到Assert winner的<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>，则重新添加下游接口转发组播数据。</p>
<p>如<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0006.html#ZH-CN_CONCEPT_0000001176663373__fig_dc_vrp_multicast_feature_311104">图6</a>所示，如果DeviceB和DeviceC都能够接收到组播源Source发出的组播报文，并且均能通过RPF检查，创建（S，G）表项。DeviceB、DeviceC的下游接口连接在同一网段，那么DeviceB和DeviceC就会同时向该网段发送组播数据。Assert机制可以保证一个网段只能存在一个组播数据转发者。Assert过程如下：</p>
<ol>
<li>DeviceB从下游接口接收到DeviceC发来的组播报文，RPF检查失败，报文被丢弃。同时，DeviceB向该网段发送<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>。</li>
<li>DeviceC将自身的路由信息与对方的Assert消息中携带的路由信息进行比较，由于自身到组播源的开销较大而落败。于是禁止该下游接口转发组播报文，将其从DeviceC的（S，G）表项的下游接口列表中删除。</li>
<li>DeviceC从该网段接收到DeviceB发来的组播报文，RPF检查失败，报文被丢弃。Assert过程结束。</li>
</ol>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/duanyan10181610.png" alt="duanyan10181610"></p>
<h1 id="PIM-SM"><a href="#PIM-SM" class="headerlink" title="PIM SM"></a>PIM SM</h1><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/pimsm32.png" alt="pimsm32"></p>
<p><strong>RP介绍</strong>：</p>
<p>汇聚点RP（Rendezvous Point）为网络中一台重要的PIM路由器，用于处理源端DR注册信息及组成员加入</p>
<p>请求，网络中的所有PIM路由器都必须知道RP的地址，类似于一个供求信息的汇聚中心。</p>
<p>• 目前可以通过以下方式配置RP：</p>
<p>▫ 静态RP：在网络中的所有PIM路由器上配置相同的RP地址，静态指定RP的位置。</p>
<p>▫ 动态RP：通过选举机制在多个C-RP（Candidate-RP，候选RP）之间选举出RP。</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/rp1.png" alt="rp1"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/2rp.png" alt="2rp"></p>
<p>• PIM-SM（ASM）模式首次形成组播分发树主要依赖RPT构建机制，组播源注册机制与DR选举机制。</p>
<p>▫ RPT构建机制：组播叶子路由器主动建立到RP的组播分发树（RPT）</p>
<p>▫ 组播源注册机制：通过该机制形成组播源到RP的组播分发树（SPT）</p>
<p>▫ DR选举机制：DR负责源端或组成员端组播报文的收发，避免重复组播报文，同时成员端DR还负责发送Join加组消息。</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/rpt82833.png" alt="rpt82833"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/zhuce0183042.png" alt="zhuce0183042"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/2zhuce83158.png" alt="2zhuce83158"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/dr3316.png" alt="dr3316"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/dr1.png" alt="dr1"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/rptciyou183410.png" alt="rptciyou183410"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/sptqiehuan3531.png" alt="sptqiehuan3531"></p>
<p>• 当组播分发树（SPT或RPT）稳定后，成员端DR会周期性发送Join&#x2F;Prune报文，用于维护组播分发树。</p>
<p>• 如果组播在一段时间后（默认210s）没有流量则SPT树会消失，成员端DR恢复到RP的RPT树。</p>
<h1 id="PIM（SSM）"><a href="#PIM（SSM）" class="headerlink" title="PIM（SSM）"></a>PIM（SSM）</h1><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/ssm822.png" alt="ssm822"></p>
<p>• PIM-SM（SSM）无需Assert机制</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/Q0183905.png" alt="Q0183905"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/bijiao929.png" alt="bijiao929"></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>IGMP</tag>
        <tag>PIM</tag>
      </tags>
  </entry>
  <entry>
    <title>路由策略</title>
    <url>/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p><img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/luyouceltuopu126203917.png" alt="luyouceltuopu126203917"></p>
<p>设备互联方式、互联地址如图所示，所有设备均创建Loopback0，其IP地址为10.0.x.x&#x2F;32，其中x为设备编号，R1、R2、R3在互联接口、Loopback0接口上激活OSPF。</p>
<p>R3、R4属于IS-IS Area 49.0001，两者都是Level-1路由器，R3、R4的系统ID采用0000.0000.000x格式，其中x为设备编号。</p>
<span id="more"></span>

<p>R1上存在三个业务网段A、B、C（使用Loopback1、2、3接口路由模拟），在R1上将直连路由引入到OSPF，但是OSPF域内的路由器上不需要C业务的路由，为此在R1上引入直连路由时通过Route-Policy过滤引入的路由。</p>
<p>R2上不需要A业务网段的路由，但是R3上需要A、B业务网段的路由，为此在R2上配置Filter-Policy对OSPF接收的路由进行过滤。</p>
<p>IS-IS域内的路由器需要访问A业务，因此需要在R3上执行路由重分发，将OSPF路由引入到IS-IS，但是IS-IS域内的路由器不需要访问B业务，为此在R1上引入直连路由时为A、B业务网段路由打上不同的路由标记，R3上执行重分发时根据路由标记过滤B业务网段路由。</p>
<h1 id="任务思路"><a href="#任务思路" class="headerlink" title="任务思路"></a>任务思路</h1><ol>
<li>设备基础IP地址配置。</li>
<li>配置R1、R2、R3之间的OSPF，在互联接口、Loopback0接口上激活OSPF。在R3、R4之间配置IS-IS。</li>
<li>在R1上将直连路由引入到OSPF中，同时配置路由策略不引入C业务网段的路由，将A、B业务网段路由分别打上路由标记10、20。</li>
<li>在R2上配置Filter-Policy对接收的OSPF路由进行过滤，只接收B业务网段的路由。</li>
<li>在R3上将OSPF路由引入到IS-IS中，通过Route-Policy匹配路由标记，只引入A业务网段的OSPF外部路由。</li>
</ol>
<h1 id="1-配置ip"><a href="#1-配置ip" class="headerlink" title="1.配置ip"></a>1.配置ip</h1><p>#配置R1的GE0&#x2F;0&#x2F;2、Loopback0接口IP地址</p>
<p>[R1]interface GigabitEthernet0&#x2F;0&#x2F;2</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;2] ip address 10.0.12.1 255.255.255.0</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;2] quit</p>
<p>[R1]interface LoopBack0</p>
<p>[R1-LoopBack0] ip address 10.0.1.1 255.255.255.255</p>
<p>[R1-LoopBack0] quit</p>
<p>#在R1上创建多个环回口，用于模拟业务网段A、B、C</p>
<p>[R1]interface LoopBack1</p>
<p>[R1-LoopBack1] ip address 172.16.1.1 255.255.255.0</p>
<p>[R1-LoopBack1] quit</p>
<p>[R1]interface LoopBack2</p>
<p>[R1-LoopBack2] ip address 172.16.2.1 255.255.255.0</p>
<p>[R1-LoopBack2] quit</p>
<p>[R1]interface LoopBack3</p>
<p>[R1-LoopBack3] ip address 172.16.3.1 255.255.255.0</p>
<p>[R1-LoopBack3] quit</p>
<p>#配置R2的GE0&#x2F;0&#x2F;2、GE0&#x2F;0&#x2F;3、Loopback0接口IP地址</p>
<p>[R2]interface LoopBack0</p>
<p>[R2-LoopBack0] ip address 10.0.2.2 255.255.255.255</p>
<p>[R2-LoopBack0] quit</p>
<p>[R2]interface GigabitEthernet0&#x2F;0&#x2F;2</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;2] ip address 10.0.23.2 255.255.255.0</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;2] quit</p>
<p>[R2]interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;3] ip address 10.0.12.2 255.255.255.0</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;3] quit</p>
<p>#配置R3的GE0&#x2F;0&#x2F;2、GE0&#x2F;0&#x2F;3、Loopback0接口IP地址</p>
<p>[R3]interface LoopBack0</p>
<p>[R3-LoopBack0] ip address 10.0.3.3 255.255.255.255</p>
<p>[R3-LoopBack0] quit</p>
<p>[R3]interface GigabitEthernet0&#x2F;0&#x2F;2</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;2] ip address 10.0.34.3 255.255.255.0</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;2] quit</p>
<p>[R3]interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;3] ip address 10.0.23.3 255.255.255.0</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;3] quit</p>
<p>#配置R4的GE0&#x2F;0&#x2F;3、Loopback0接口IP地址</p>
<p>[R4]interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;3] ip address 10.0.34.4 255.255.255.0</p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;3] quit</p>
<p>[R4]interface LoopBack0</p>
<p>[R4-LoopBack0] ip address 10.0.4.4 255.255.255.255</p>
<p>[R4-LoopBack0] quit</p>
<p>#在R2、R4上检查IP地址连通性</p>
<h1 id="2-配置ospf和isis"><a href="#2-配置ospf和isis" class="headerlink" title="2.配置ospf和isis"></a>2.配置ospf和isis</h1><p>#配置R1</p>
<p>[R1]ospf 1 router-id 10.0.1.1</p>
<p>[R1-ospf-1] area 0</p>
<p>[R1-ospf-1-area-0.0.0.0] network 10.0.1.1 0.0.0.0</p>
<p>[R1-ospf-1-area-0.0.0.0] network 10.0.12.1 0.0.0.0</p>
<p>[R1-ospf-1-area-0.0.0.0] quit</p>
<p>[R1-ospf-1] quit</p>
<p>#配置R2</p>
<p>[R2]ospf 1 router-id 10.0.2.2</p>
<p>[R2-ospf-1] area 0.0.0.0</p>
<p>[R2-ospf-1-area-0.0.0.0] network 10.0.2.2 0.0.0.0</p>
<p>[R2-ospf-1-area-0.0.0.0] network 10.0.12.2 0.0.0.0</p>
<p>[R2-ospf-1-area-0.0.0.0] network 10.0.23.2 0.0.0.0</p>
<p>[R2-ospf-1-area-0.0.0.0] quit</p>
<p>[R2-ospf-1] quit</p>
<p>#配置R3</p>
<p>[R3]ospf 1 router-id 10.0.3.3</p>
<p>[R3-ospf-1] area 0.0.0.0</p>
<p>[R3-ospf-1-area-0.0.0.0] network 10.0.3.3 0.0.0.0</p>
<p>[R3-ospf-1-area-0.0.0.0] network 10.0.23.3 0.0.0.0</p>
<p>[R3-ospf-1-area-0.0.0.0] quit</p>
<p>[R3-ospf-1] quit</p>
<p>#在R2上检查OSPF邻居的概要信息</p>
<p>R3、R4上配置IS-IS，区域为49.0001，系统ID采用0000.0000.000x格式（x为设备编号），两台设备都为Level-1路由器，在互联接口、R4的Loopback0接口上激活IS-IS。</p>
<p>#配置R3</p>
<p>[R3]isis 1</p>
<p>[R3-isis-1] is-level level-1</p>
<p>[R3-isis-1] network-entity 49.0001.0000.0000.0003.00</p>
<p>[R3-isis-1] quit</p>
<p>[R3]interface GigabitEthernet0&#x2F;0&#x2F;2</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;2] isis enable 1</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;2] quit</p>
<p>#配置R4</p>
<p>[R4]isis 1</p>
<p>[R4-isis-1] is-level level-1</p>
<p>[R4-isis-1] network-entity 49.0001.0000.0000.0004.00</p>
<p>[R4-isis-1] quit</p>
<p>[R4]interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;3] isis enable 1</p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;3] quit</p>
<p>[R4]interface LoopBack 0</p>
<p>[R4-LoopBack0] isis enable 1</p>
<p>[R4-LoopBack0] quit</p>
<p>#在R3上检查IS-IS邻居状态</p>
<h1 id="3-在R1上引入直连路由"><a href="#3-在R1上引入直连路由" class="headerlink" title="3.在R1上引入直连路由"></a>3.在R1上引入直连路由</h1><p>在R1上将直连路由引入到OSPF中，同时配置路由策略过滤C业务网段，将A、B业务网段路由分别打上路由标记10、20。</p>
<p>#创建IP前缀列表1，匹配Loopback1接口路由（A业务网段）</p>
<p>[R1]ip ip-prefix 1 index 10 permit 172.16.1.0 24 greater-equal 24 less-equal 24</p>
<p>#创建IP前缀列表2，匹配Loopback2接口路由（B业务网段）</p>
<p>[R1]ip ip-prefix 2 index 10 permit 172.16.2.0 24 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10、20，分别调用IP前缀列表1、2，打上路由标记</p>
<p>[R1]route-policy hcip permit node 10</p>
<p>[R1-route-policy] if-match ip-prefix 1</p>
<p>[R1-route-policy] apply tag 10</p>
<p>[R1-route-policy] quit</p>
<p>[R1]route-policy hcip permit node 20</p>
<p>[R1-route-policy] if-match ip-prefix 2</p>
<p>[R1-route-policy] apply tag 20 </p>
<p>[R1-route-policy] quit</p>
<p>#在R1的OSPF中引入直连路由，调用Route-Policy hcip</p>
<p>[R1]ospf 1</p>
<p>[R1-ospf-1] import-route direct route-policy hcip</p>
<p>r1上查看ospf lsdb，Loopback1、2接口路由已经被成功引入OSPF中。</p>
<p>#在R1上查看OSPF LSDB中AS-external LSA 172.16.1.0的相关信息</p>
<p>[R1]display ospf lsdb ase 172.16.1.0 </p>
<p>​	 OSPF Process 1 with Router ID 10.0.1.1</p>
<p>​		 Link State Database</p>
<p> Type    : External</p>
<p> Ls id   : 172.16.1.0</p>
<p> Adv rtr  : 10.0.1.1  </p>
<p> Ls age   : 165 </p>
<p> Len    : 36 </p>
<p> Options  :  E  </p>
<p> seq#    : 80000001 </p>
<p> chksum   : 0xa954</p>
<p> Net mask  : 255.255.255.0 </p>
<p> TOS 0  Metric: 1 </p>
<p> E type   : 2</p>
<p> Forwarding Address : 0.0.0.0 </p>
<p> Tag    : 10 </p>
<p> Priority  : Low</p>
<p>外部路由172.16.1.0&#x2F;24已经被打上Tag 10。</p>
<p>#在R1上查看OSPF LSDB中AS-external LSA 172.16.2.0的相关信息</p>
<p>[R1]display ospf lsdb ase 172.16.2.0</p>
<p>​	 OSPF Process 1 with Router ID 10.0.1.1</p>
<p>​		 Link State Database</p>
<p> Type    : External</p>
<p> Ls id   : 172.16.2.0</p>
<p> Adv rtr  : 10.0.1.1  </p>
<p> Ls age   : 355 </p>
<p> Len    : 36 </p>
<p> Options  :  E  </p>
<p> seq#    : 80000001 </p>
<p> chksum   : 0x539f</p>
<p> Net mask  : 255.255.255.0 </p>
<p> TOS 0  Metric: 1 </p>
<p> E type   : 2</p>
<p> Forwarding Address : 0.0.0.0 </p>
<p> Tag    : 20 </p>
<p> Priority  : Low</p>
<p>外部路由172.16.2.0&#x2F;24已经被打上Tag 20。</p>
<h1 id="4-在R2上配置过滤策略"><a href="#4-在R2上配置过滤策略" class="headerlink" title="4.在R2上配置过滤策略"></a>4.在R2上配置过滤策略</h1><p>在R2上配置Filter-Policy对接收的OSPF路由进行过滤，只接收B业务网段的路由。</p>
<p>#查看配置Filter-Policy前的OSPF路由表</p>
<p><R2>display ospf routing</R2></p>
<p>#查看配置Filter-Policy前的IP路由表中的OSPF路由</p>
<p><R2>display ip routing-table protocol ospf	</R2></p>
<p>在OSPF路由表以及IP路由表中<strong>都可以看到</strong>OSPF外部路由172.16.1.0&#x2F;24、172.16.2.0&#x2F;24。</p>
<p>#配置基础ACL </p>
<p>[R2]acl number 2000</p>
<p>[R2-acl-basic-2000] rule 5 deny source 172.16.1.0 0.0.0.255</p>
<p>[R2-acl-basic-2000] rule 10 permit</p>
<p>#在OSPF中部署入方向的Filter-Policy，调用ACL 2000</p>
<p>[R2]ospf 1</p>
<p>[R2-ospf-1] filter-policy 2000 import</p>
<p>#查看配置Filter-Policy后的OSPF路由表</p>
<p>dis ospf routing</p>
<p>发现两条外部路由都还存在</p>
<p>#查看配置Filter-Policy后的IP路由表中的OSPF路由</p>
<p><R2>display ip routing-table protocol ospf	</R2></p>
<p>在IP路由表中路由172.16.2.0&#x2F;24已经不存在，但是在OSPF路由表中依旧存在。这验证了对于OSPF，Filter-Policy只是限制路由加入IP路由表，不影响本地的LSDB以及LSA的传递。</p>
<p>#在R3上查看IP路由表中的OSPF路由</p>
<p><R3>display ip routing-table protocol ospf </R3></p>
<p>R3的IP路由表中OSPF外部路由172.16.1.0&#x2F;24、172.16.2.0&#x2F;24依旧存在。</p>
<h1 id="5-在R3上将OSPF路由引入到IS-IS"><a href="#5-在R3上将OSPF路由引入到IS-IS" class="headerlink" title="5.在R3上将OSPF路由引入到IS-IS"></a>5.在R3上将OSPF路由引入到IS-IS</h1><p>在R3上将OSPF路由引入到IS-IS中，通过Route-Policy匹配路由标记，只引入A业务网段的OSPF外部路由。</p>
<p>#创建Route-Policy hcip</p>
<p>[R3]route-policy hcip permit node 10</p>
<p>[R3-route-policy] if-match tag 10</p>
<p>[R3-route-policy] quit</p>
<p>#在IS-IS中引入OSPF路由，调用Route-Policy hcip只引入A业务网段的OSPF外部路由</p>
<p>[R3]isis 1</p>
<p>[R3-isis-1] import-route ospf 1 <strong>level-1</strong> route-policy hcip</p>
<p>（注意指定level）</p>
<p>#查看R3的IS-IS路由表</p>
<p><R3>display isis route </R3></p>
<p>Level-1的路由重分发表中只有172.16.1.0&#x2F;24。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>路由策略</tag>
      </tags>
  </entry>
</search>
