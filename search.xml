<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BFD</title>
    <url>/2024/08/07/BFD/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>双向转发检测BFD（Bidirectional Forwarding Detection）是一种高速故障检测机制，在两个系统之间建立BFD会话并周期性地发送BFD报文，如果一方在协商的检测时间内没有接收到BFD报文，则认为这条双向通道上发生了故障。上层协议通过BFD感知到链路故障后可以及时采取措施，进行故障恢复。</p>
<p>BFD提供如下功能：</p>
<ul>
<li>对相邻设备之间的通道提供轻负荷、快速故障检测。这些故障包括接口故障，数据链路故障，甚至有可能是设备本身故障。</li>
<li>提供一个单一的机制，能够用来对任何媒介、任何协议层进行实时地检测。</li>
</ul>
<p>检测机制</p>
<p>BFD的检测机制是两个系统建立BFD会话，并沿它们之间的路径周期性发送BFD控制报文，如果一方在既定的时间内没有收到BFD控制报文，则认为路径上发生了故障。</p>
<p>BFD控制报文封装在<strong>UDP</strong>报文中传送。会话开始阶段，双方系统通过控制报文中携带的参数（会话标识符、期望的收发报文最小时间间隔、本端BFD会话状态等）进行协商。协商成功后，以协商的报文收发时间在彼此之间的路径上定时发送BFD控制报文。</p>
<p>BFD的主要操作模式称为异步模式。在这种模式下，系统之间相互周期性地发送BFD控制报文，如果某个系统连续几个报文都没有接收到，就认为此BFD会话的状态是Down。</p>
<h1 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h1><p><img src="/2024/08/07/BFD/QQ%E6%88%AA%E5%9B%BE20240807201113.png" alt="QQ截图20240807201113"></p>
<p>重要字段解释：</p>
<p>vers：版本，1</p>
<table>
<thead>
<tr>
<th>My Discriminator</th>
<th>32 bits</th>
<th>BFD会话连接本地标识符。发送系统产生的一个唯一的、非0鉴别值，用来区分一个系统的多个BFD会话。</th>
</tr>
</thead>
<tbody><tr>
<td>Your Discriminator</td>
<td>32 bits</td>
<td>BFD会话连接远端标识符。0：未知。Non-0：从远端系统接收到的鉴别值，这个域直接返回接收到的“My Discriminator”。</td>
</tr>
<tr>
<td>Desired Min TX Interval</td>
<td>32 bits</td>
<td>本地支持的最小BFD报文发送间隔，单位为毫秒。</td>
</tr>
<tr>
<td>Required Min RX Interval</td>
<td>32 bits</td>
<td>本地支持的最小BFD报文接收间隔，单位为毫秒。</td>
</tr>
<tr>
<td>Required Min Echo RX Interval</td>
<td>32 bits</td>
<td>本地支持的最小Echo报文接收间隔，单位为毫秒（如果本地不支持Echo功能，则设置0）。</td>
</tr>
</tbody></table>
<h1 id="BFD会话建立"><a href="#BFD会话建立" class="headerlink" title="BFD会话建立"></a>BFD会话建立</h1><table>
<thead>
<tr>
<th>BFD会话建立方式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>静态BFD会话</td>
<td>手工指定标识符的静态BFD会话静态BFD会话是指通过命令行手工配置BFD会话参数，包括了配置<strong>本地标识符和远端标识符等，手工下发BFD会话建立请求</strong>。当BFD会话的一端收到BFD控制报文时，将收到报文中的My Discriminator和Your Discriminator的值，与本地BFD会话进行比较，判断是否匹配。标识符自协商的静态BFD会话标识符自协商的静态BFD会话是指手工创建BFD会话，但不需要配置本地标识符和远端标识符，本地标识符和远端标识符通过会话协商获得。在静态路由与BFD联动应用中，如果对端设备不支持静态BFD会话，而采用动态BFD会话，此时本端设备既要与之互通，又要能够实现静态路由与BFD联动时，必须使用静态标识符自协商BFD会话。</td>
</tr>
<tr>
<td>动态BFD会话</td>
<td>动态BFD会话是指由路由协议动态触发BFD会话建立。动态BFD中，本地标识符是动态分配的，远端标识符从对端的BFD报文中获取。路由协议在建立了新的邻居关系时，将对应的参数及检测参数（包括目的地址、源地址等）通告给BFD，BFD根据收到的参数建立起会话。当发生链路故障时，联动了BFD的路由协议可以快速感知到BFD会话状态变为Down，从而实现将流量快速切换到备份路径，避免了数据大量丢失。动态BFD具有较高的灵活性，适用于全网都对可靠性要求较高的网络。动态建立BFD会话时，系统对本地标识符和远端标识符的处理方式如下：动态分配本地标识符：当应用程序触发动态创建BFD会话时，系统分配属于动态会话标识符区域的值作为BFD会话的本地标识符。然后向对端发送Your Discriminator的值为0的BFD控制报文，进行会话协商。自学习远端标识符：当BFD会话的一端收到Your Discriminator的值为0的BFD控制报文时，根据四元组（源地址、目的地址、出接口、VPN索引）判断该报文是否与本地BFD会话匹配，如果匹配，则学习接收到的BFD报文中My Discriminator的值，获取远端标识符。</td>
</tr>
</tbody></table>
<p>会话状态：</p>
<ul>
<li>Down：会话处于Down状态或刚刚创建。</li>
<li>Init：已经能够与对端系统通信，本端希望使会话进入Up状态。</li>
<li>Up：会话已经建立成功。</li>
</ul>
<p>会话状态变化通过BFD报文的State字段传递，系统根据自己本地的会话状态和接收到的对端BFD报文驱动状态改变。BFD状态机的建立和拆除都采用三次握手机制，以确保两端系统都能知道状态的变化。以BFD会话建立为例，简单介绍状态机的迁移过程。</p>
<img src="/2024/08/07/BFD/QQ截图20240807213249.png" alt="QQ截图20240807213249" style="zoom:67%;">

<p>BFD缺省参数</p>
<img src="/2024/08/07/BFD/QQ截图20240807213403.png" alt="QQ截图20240807213403" style="zoom:67%;">

<h1 id="BFD检测机制"><a href="#BFD检测机制" class="headerlink" title="BFD检测机制"></a>BFD检测机制</h1><img src="/2024/08/07/BFD/QQ截图20240807213527.png" alt="QQ截图20240807213527" style="zoom:67%;">

<h1 id="BFD检测时间"><a href="#BFD检测时间" class="headerlink" title="BFD检测时间"></a>BFD检测时间</h1><img src="/2024/08/07/BFD/QQ截图20240807213553.png" alt="QQ截图20240807213553" style="zoom: 80%;">

<h1 id="单臂回声"><a href="#单臂回声" class="headerlink" title="单臂回声"></a>单臂回声</h1><img src="/2024/08/07/BFD/QQ截图20240807213607.png" alt="QQ截图20240807213607" style="zoom:80%;">

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><img src="/2024/08/07/BFD/QQ截图20240807214404.png" alt="QQ截图20240807214404" style="zoom:80%;">

<img src="/2024/08/07/BFD/QQ截图20240807214409.png" alt="QQ截图20240807214409" style="zoom:80%;">

<img src="/2024/08/07/BFD/QQ截图20240807214417.png" alt="QQ截图20240807214417" style="zoom:80%;">

<img src="/2024/08/07/BFD/QQ截图20240807214428.png" alt="QQ截图20240807214428" style="zoom:80%;">
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>BGP路由优选</title>
    <url>/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/</url>
    <content><![CDATA[<h1 id="BGP路由优选"><a href="#BGP路由优选" class="headerlink" title="BGP路由优选"></a>BGP路由优选</h1><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>你是公司的网络管理员。公司的网络采用了BGP协议接入了两个服务运营商。公司自己采用了私有的AS号64512，ISP1的AS号为100，ISP2的AS号为200。通过AS100、AS200都可以到达相同的网络，你通过改变BGP的各种属性达到了调整路由走向的目的。</p>
<span id="more"></span>

<p>实验介绍：</p>
<p>设备互联方式、互联接口地址如图所示，所有设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号，所有设备都使用Loopback0地址作为BGP Router ID。</p>
<p>R1在AS100，R5在AS200，R2、R3、R4在AS64512。AS64512内运行OSPF，在互联接口（不包括连接外部AS的接口）、Loopback0接口上激活OSPF。</p>
<p>EBGP对等体关系基于直连接口建立，IBGP对等体关系基于Loopback0接口建立。</p>
<p>R1、R5上存在相同的网段172.16.1.0&#x2F;24、172.16.2.0&#x2F;24、172.16.3.0&#x2F;24、172.16.4.0&#x2F;24，在R1、R5上将其发布到BGP，以用于BGP路由优选。</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/tuopu22sd182306.png" alt="tuopu22sd182306"></p>
<p>配置ip，配置bgp：略</p>
<p>#在R1、R5上将Loopback1、Loopback2、Loopback3、Loopback4接口路由发布到BGP中</p>
<p>[R1]bgp 100</p>
<p>[R1-bgp] network 172.16.1.0 24</p>
<p>[R1-bgp] network 172.16.2.0 24</p>
<p>[R1-bgp] network 172.16.3.0 24</p>
<p>[R1-bgp] network 172.16.4.0 24</p>
<p>[R5]bgp 200</p>
<p>[R5-bgp] network 172.16.1.0 24</p>
<p>[R5-bgp] network 172.16.2.0 24</p>
<p>[R5-bgp] network 172.16.3.0 24</p>
<p>[R5-bgp] network 172.16.4.0 24</p>
<p>#在R3上查看BGP路由表，检查BGP路由是否成功学习</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/r3chakandp128185306.png" alt="r3chakandp128185306"></p>
<p>R3已经成功学习R1、R5发布的路由，此时所有路由都优选由R2通告的。</p>
<h2 id="修改AS-Path属性"><a href="#修改AS-Path属性" class="headerlink" title="修改AS_Path属性"></a>修改AS_Path属性</h2><p>在R1上通过路由策略修改BGP路由172.16.1.0&#x2F;24的 AS_Path属性值，使得R3优选R5发布的BGP路由172.16.1.0&#x2F;24。</p>
<p>#创建IP前缀列表1，匹配Loopback1接口路由</p>
<p>[R1]ip ip-prefix 1 permit 172.16.1.0 24 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1，修改AS_Path属性值</p>
<p>[R1]route-policy hcip permit node 10</p>
<p>[R1-route-policy] if-match ip-prefix 1</p>
<p>[R1-route-policy] apply as-path 300 400 additive</p>
<p>[R1-route-policy] quit</p>
<p>[R1]route-policy hcip permit node 20</p>
<p>注意创建一个空节点，对于另外3条BGP路由不执行任何操作。</p>
<p>#对向BGP对等体R2通告的BGP路由应用Route-Policy</p>
<p>[R1]bgp 100</p>
<p>[R1-bgp] peer 10.0.12.2 route-policy hcip export</p>
<p>#在R1上触发出方向的软复位，刷新对外通告的BGP路由</p>
<p><R1>refresh bgp all export</R1></p>
<p>#在R3上查看BGP路由172.16.1.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/as5cs28190005.png" alt="as5cs28190005"></p>
<p>此时R3优选R4通告的BGP路由172.16.1.0&#x2F;24，R2通告的未被优选的原因是AS_Path长度。</p>
<h2 id="修改Local-Preference属性"><a href="#修改Local-Preference属性" class="headerlink" title="修改Local_Preference属性"></a>修改Local_Preference属性</h2><p>local_Preference：默认100，越大越优先，只能在ibgp对等体之间传递</p>
<p>在R4上通过路由策略修改BGP路由172.16.2.0&#x2F;24的Local_Preference属性值，使得R3优选R4通告的BGP路由172.16.2.0&#x2F;24。</p>
<p>#创建IP前缀列表1，匹配BGP路由172.16.2.0&#x2F;24</p>
<p>[R4]ip ip-prefix 1 permit 172.16.2.0 24 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1，修改Local_Preference属性值</p>
<p>[R4]route-policy hcip permit node 10</p>
<p>[R4-route-policy] if-match ip-prefix 1</p>
<p>[R4-route-policy] apply local-preference 200</p>
<p>[R4-route-policy] quit</p>
<p>[R4]route-policy hcip permit node 20</p>
<p>注意创建一个空节点，对于另外3条BGP路由不执行任何操作。</p>
<p>#对向BGP对等体R3通告的BGP路由应用Route-Policy</p>
<p>[R4]bgp 64512</p>
<p>[R4-bgp] peer 10.0.3.3 route-policy hcip export</p>
<p>#在R4上触发出方向的软复位，刷新对外通告的BGP路由</p>
<p><R4>refresh bgp all export</R4></p>
<p>#在R3上查看BGP路由172.16.2.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/local55chakan192014.png" alt="local55chakan192014"></p>
<p>此时R3优选R4通告的BGP路由172.16.2.0&#x2F;24，R2通告的BGP路由其Local_Preference值为100，小于R3通告的BGP路由Local_Preference值200，因此R2通告的BGP路由未被优选。</p>
<h2 id="修改MED属性"><a href="#修改MED属性" class="headerlink" title="修改MED属性"></a>修改MED属性</h2><p>在R2上通过路由策略修改BGP路由172.16.3.0&#x2F;24的MED属性值，使得R3优选R5发布的BGP路由172.16.3.0&#x2F;24。</p>
<p>#创建IP前缀列表1，匹配BGP路由172.16.3.0&#x2F;24</p>
<p>[R2]ip ip-prefix 1 permit 172.16.3.0 24 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1，修改MED属性值</p>
<p>[R2]route-policy hcip permit node 10</p>
<p>[R2-route-policy] if-match ip-prefix 1</p>
<p>[R2-route-policy] apply cost 200</p>
<p>[R2-route-policy] quit</p>
<p>[R2]route-policy hcip permit node 20</p>
<p>注意创建一个空节点，对于另外3条BGP路由不执行任何操作。</p>
<p>#对来自BGP对等体R1的BGP路由应用Route-Policy</p>
<p>[R2]bgp 64512</p>
<p>[R2-bgp] peer 10.0.12.1 route-policy hcip import</p>
<p>#在R2上触发入方向的软复位，刷新接收到的BGP路由</p>
<p><R2>refresh bgp all import</R2></p>
<p>#在R3上配置允许比较来自不同AS的BGP路由的MED值</p>
<p>[R3]bgp 64512</p>
<p>[R3-bgp] compare-different-as-med  </p>
<p>缺省情况下，不比较来自不同AS邻居的BGP的MED属性值。</p>
<p>#在R3上查看BGP路由172.16.3.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/medchakanf2735.png" alt="medchakanf2735"></p>
<p>R2通告的BGP路由172.16.3.0&#x2F;24其MED值为200，而R4通告BGP路由MED值为0，R3优选MED值较小的BGP路由，因此R2通告的BGP路由未被优选。</p>
<h2 id="修改preferred-value属性"><a href="#修改preferred-value属性" class="headerlink" title="修改preferred-value属性"></a>修改preferred-value属性</h2><p>preferred-value：华为特有的属性值，仅在本地有效，当bgp存在到相同的路由时，将优选prefeerred-value大的路由。只能在路由器本地配置，只影响本设备的路由优选，不会传递给任何bgp对等体。</p>
<p>在R3上通过路由策略修改BGP路由172.16.4.0&#x2F;24的preferred-value属性值，使得R3优选R4通告的BGP路由172.16.4.0&#x2F;24。</p>
<p>#创建IP前缀列表1，匹配BGP路由172.16.4.0&#x2F;24</p>
<p>[R3]ip ip-prefix 1 permit 172.16.4.0 24 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1，修改preferred-value属性值</p>
<p>[R3]route-policy hcip permit node 10</p>
<p>[R3-route-policy] if-match ip-prefix 1</p>
<p>[R3-route-policy] apply preferred-value 300</p>
<p>[R3-route-policy] quit</p>
<p>[R3]route-policy hcip permit node 20</p>
<p>注意创建一个空节点，对于另外3条BGP路由不执行任何操作。</p>
<p>#对来自BGP对等体R4的BGP路由应用Route-Policy</p>
<p>[R3]bgp 64512</p>
<p>[R3-bgp] peer 10.0.4.4 route-policy hcip import</p>
<p>#在R3上触发入方向的软复位，刷新收到的BGP路由</p>
<p><R3>refresh bgp all import</R3></p>
<p>#在R3上查看BGP路由172.16.4.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/prexiiuhai8193458.png" alt="prexiiuhai8193458"></p>
<p>R4通告的BGP路由172.16.3.0&#x2F;24其preferred-value值为300，而R2通告的preferred-value值为0，R3优选preferred-value值较大的BGP路由，因此R3优选R4通告的BGP路由。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>BGP路由优选</tag>
      </tags>
  </entry>
  <entry>
    <title>BGP总结</title>
    <url>/2024/05/11/BGP%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>BGP使用<strong>TCP</strong>作为其传输层协议（端口号为<strong>179</strong>），使用<strong>触发式路由更新</strong>，而不是周期性路由更新。—BGP要想建立邻居关系，必须保证建立邻居关系的两端能够ping通<br>BGP能够承载大批量的路由信息，能够支撑大规模网络。<br>BGP提供了丰富的路由策略，能够灵活的进行路由选路，并能指导对等体按策略发布路由。<br>BGP能够支撑MPLS&#x2F;VPN的应用，传递客户VPN路由。<br>BGP提供了路由聚合和路由衰减功能用于防止路由振荡，通过这两项功能有效地提高了网络稳定性。</p>
<p>AS范围：1-65535</p>
<p>BGP版本：BGP4+</p>
<p>一台路由器不能配置多个BGP进程</p>
<p>只传递路由信息，不会暴露AS内拓扑信息</p>
<h1 id="BGP对等体"><a href="#BGP对等体" class="headerlink" title="BGP对等体"></a>BGP对等体</h1><p>EBGP：对等体两端属于不同的AS</p>
<p>IBGP：对等体两端属于同一个AS</p>
<p>建立BGP对等体的时候可以使用物理接口建立，也可以使用loopback接口建立</p>
<p><strong>EBGP对等体</strong>：建议使用物理接口建立 </p>
<p>①使用物理接口建立：<br>[AR1]bgp 100</p>
<p>[AR1-bgp]router-id 1.1.1.1  </p>
<p>[AR1-bgp]peer 10.0.12.2 as-number 200</p>
<p>②使用loopback接口建立：</p>
<p>[Ar4]bgp 200    </p>
<p>[Ar4-bgp]peer 5.5.5.5 as-number 300   </p>
<p>[Ar4-bgp]peer 5.5.5.5 connect-interface loopback0     <strong>如果使用loopback接口建立对等体，必须要指明建立对等体的接口</strong></p>
<p>[Ar4-bgp]router-id 4.4.4.4  指定router id</p>
<p>[Ar4-bgp]peer 5.5.5.5  ebgp-max-hop   EBGP建立对等体关系默认发出报文TTL值为1，如果用loopback接口建立，到达loopback接口TTL值变成0，此时报文会丢弃，所以需要更改接口的TTL，peer 5.5.5.5  ebgp-max-hop命令可以直接设置TTL，至少设置为2，如果不设置，此时TTL值为255</p>
<p>I<strong>BGP对等体</strong>：建议使用loopback接口建立（更稳定）</p>
<p>IBGP建立对等体关系，发送报文TTL值为255，所以不用考虑TTL不可达问题</p>
<p>①使用loopback接口建立：</p>
<p>[Ar4]bgp 200   </p>
<p>[Ar4-bgp]peer 2.2.2.2 as-number 200  </p>
<p>[Ar4-bgp]peer 2.2.2.2 connect-interface loopback0</p>
<p>②使用物理接口建立：</p>
<p>[Ar4]bgp 200    </p>
<p>[Ar4-bgp]peer 10.0.34.4 as-number 200</p>
<h1 id="BGP对等体关系建立"><a href="#BGP对等体关系建立" class="headerlink" title="BGP对等体关系建立"></a>BGP对等体关系建立</h1><p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/image-20240511132855207.png" alt="image-20240511132855207"></p>
<p><strong>报文头部</strong></p>
<img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/QQ截图20240724222453.png" alt="QQ截图20240724222453" style="zoom:67%;">



<ul>
<li>Open消息：是TCP连接建立后发送的第一个消息，用于建立BGP对等体之间的连接关系。对等体在接收到Open消息并协商成功后，将发送Keepalive消息确认并保持连接的有效性。确认后，对等体间可以进行Update、Notification、Keepalive和Route-refresh消息的交换。</li>
</ul>
<img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/QQ截图20240724222709.png" alt="QQ截图20240724222709" style="zoom:67%;">

<ul>
<li><p>Update消息：用于在对等体之间交换路由信息。Update消息可以发布多条属性相同的可达路由信息，也可以撤销多条不可达路由信息。</p>
<img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/QQ截图20240724222847.png" alt="QQ截图20240724222847" style="zoom:67%;">

<ul>
<li>一条Update消息可以发布多条具有相同路由属性的可达路由，这些路由可共享一组路由属性。所有包含在一个给定的Update消息里的路由属性适用于该Update消息中的NLRI（Network Layer Reachability Information）字段里的所有目的地（用IP前缀表示）。</li>
<li>一条Update消息可以撤销多条不可达路由。每一个路由通过目的地（用IP前缀表示）清楚的定义了BGP Speaker之间先前通告过的路由。</li>
<li>一条Update消息可以同时发布可达路由，并且撤销另一部分不可达路由。一条Update消息也可以只用于撤销路由，这样就不需要包括路径属性或者NLRI。相反，也可以只用于通告可达路由，就不需要携带撤销路由信息了。</li>
</ul>
</li>
<li><p>Notification消息：当BGP检测到错误状态时，就向对等体发出Notification消息，之后BGP连接会立即中断。</p>
</li>
</ul>
<img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/QQ截图20240724222950.png" alt="QQ截图20240724222950" style="zoom:67%;">

<ul>
<li>Keepalive消息：BGP会周期性的向对等体发出Keepalive消息，用来保持连接的有效性。缺省情况下，间隔60s，保持180s</li>
</ul>
<img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/QQ截图20240724223005.png" alt="QQ截图20240724223005" style="zoom:67%;">

<ul>
<li><p>Route-refresh消息：Route-refresh消息用来请求对等体重新发送所有的可达路由信息。</p>
<p>在所有BGP设备使能Route-refresh能力的情况下，如果BGP的入口路由策略发生了变化，本地BGP设备会向对等体发布Route-refresh消息，收到此消息的对等体会将其路由信息重新发给本地BGP设备。这样，可以在不中断BGP连接的情况下，对BGP路由表进行动态刷新，并应用新的路由策略。</p>
<img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/QQ截图20240724223027.png" alt="QQ截图20240724223027" style="zoom:67%;"></li>
</ul>
<h1 id="BGP状态机"><a href="#BGP状态机" class="headerlink" title="BGP状态机"></a>BGP状态机</h1><p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/image-20240511133639233.png" alt="image-20240511133639233"></p>
<ol>
<li><p>Idle状态是BGP初始状态。在Idle状态下，BGP拒绝邻居发送的连接请求。只有在收到本设备的Start事件后，BGP才开始尝试和其他BGP对等体进行TCP连接，并转至Connect状态。</p>
<p> <strong>注意：</strong></p>
<ul>
<li>Start事件是由一个操作者配置一个BGP进程，或者重置一个已经存在的进程或者设备软件重置BGP进程引起的。</li>
<li>任何状态中收到Notification报文或TCP拆链通知等Error事件后，BGP都会转至Idle状态。</li>
</ul>
</li>
<li><p>在Connect状态下，BGP启动连接重传定时器（Connect Retry），等待TCP完成连接。</p>
<ul>
<li>如果TCP连接成功，那么BGP向对等体发送Open报文，并转至OpenSent状态。</li>
<li>如果TCP连接失败，那么BGP转至Active状态。</li>
<li>如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP继续尝试和对等体进行TCP连接，停留在Connect状态。</li>
</ul>
</li>
<li><p>在Active状态下，BGP总是在试图建立TCP连接。</p>
<ul>
<li>如果TCP连接成功，那么BGP向对等体发送Open报文，关闭连接重传定时器，并转至OpenSent状态。</li>
<li>如果TCP连接失败，那么BGP停留在Active状态。</li>
<li>如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP转至Connect状态。</li>
</ul>
</li>
<li><p>在OpenSent状态下，BGP等待对等体的Open报文，并对收到的Open报文中的AS号、版本号、认证码等进行检查。</p>
<ul>
<li>如果收到的Open报文正确，那么BGP发送Keepalive报文，并转至OpenConfirm状态。</li>
<li>如果发现收到的Open报文有错误，那么BGP发送Notification报文给对等体，并转至Idle状态。</li>
</ul>
</li>
<li><p>在OpenConfirm状态下，BGP等待Keepalive或Notification报文。如果收到Keepalive报文，则转至Established状态，如果收到Notification报文，则转至Idle状态。</p>
</li>
<li><p>在Established状态下，BGP可以和对等体交换Update、Keepalive、Route-refresh报文和Notification报文。</p>
<ul>
<li>如果收到正确的Update或Keepalive报文，那么BGP就认为对端处于正常运行状态，将保持BGP连接。</li>
<li>如果收到错误的Update或Keepalive报文，那么BGP发送Notification报文通知对端，并转至Idle状态。</li>
<li>Route-refresh报文不会改变BGP状态。</li>
<li>如果收到Notification报文，那么BGP转至Idle状态。</li>
<li>如果收到TCP拆链通知，那么BGP断开连接，转至Idle状态。</li>
</ul>
</li>
</ol>
<p>BGP对等体双方的状态必须都为Established，BGP对等体（也可以称为BGP邻居）关系才能成立，双方通过Update报文交换路由信息。</p>
<h1 id="BGP路由的生成"><a href="#BGP路由的生成" class="headerlink" title="BGP路由的生成"></a>BGP路由的生成</h1><p>1）network：逐条在BGP协议中注入路由（其中origin属性位“i”）</p>
<p><strong>注意：network注入的路由必须是路由器的路由表存在的路由</strong></p>
<p>2）import-route：将某个协议的路由引入到路由表中，直连路由、静态路由、OSPF路由、IS-IS路由等（origin属性位“incomplete”）<br>3）路由聚合</p>
<p>bgp 200<br>aggregate 10.1.0.0 22 detail-suppressed</p>
<p>（detail-suppressed：BGP只会向对等体通告聚合后的路由，而不通告聚合前的明细路由）</p>
<p>自动聚合：summary automatic</p>
<ul>
<li>自动聚合：对BGP引入的路由进行聚合。配置自动聚合后，对参加聚合的具体路由进行抑制。配置自动聚合后，BGP将按照自然网段聚合路由（如10.1.1.1&#x2F;24和10.2.1.1&#x2F;24将聚合为A类地址10.0.0.0&#x2F;8），并且BGP向对等体只发送聚合后的路由。</li>
</ul>
<p>（自动聚合只能聚合import引入的路由）（<strong>自动聚合只能在引入路由的路由器上做</strong>）</p>
<p>优先级：手动＞自动＞network＞import＞从对等体学到</p>
<h1 id="BGP对等体通告原则"><a href="#BGP对等体通告原则" class="headerlink" title="BGP对等体通告原则"></a>BGP对等体通告原则</h1><p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/image-20240511134752905.png" alt="image-20240511134752905"></p>
<p>只发布最优路由—下一跳可达、最优路由</p>
<p>从EBGP对等体获取的路由，会发布给所有对等体。</p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps1.jpg" alt="img"> </p>
<ol start="3">
<li>IBGP水平分割：从IBGP对等体获取的路由，不会发送给IBGP对等体。</li>
</ol>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps2.jpg" alt="img"> </p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps3.jpg" alt="img"> </p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps4.jpg" alt="img"> </p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps5.jpg" alt="img"> </p>
<ol start="4">
<li>BGP同步规则指的是：当一台路由器从自己的IBGP对等体学习到一条BGP路由时（这类路由被称为IBGP路由），它将不能使用该条路由或把这条路由通告给自己的EBGP对等体，<strong>除非它又从IGP协议（例如OSPF等，此处也包含静态路由）学习到这条路由</strong>，也就是<strong>要求IBGP路由与IGP路由同步</strong>。同步规则主要用于规避BGP路由黑洞问题。</li>
</ol>
<img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps6.jpg" alt="img" style="zoom:67%;"> 

<p>路由黑洞：解决办法：</p>
<p>①BGP–IGP互相引入   该方法不建议</p>
<p>②IBGP全互联</p>
<p>③MPLS</p>
<h1 id="BGP属性"><a href="#BGP属性" class="headerlink" title="BGP属性"></a>BGP属性</h1><p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/image-20240511135334705.png" alt="image-20240511135334705"></p>
<h1 id="AS-path属性："><a href="#AS-path属性：" class="headerlink" title="AS_path属性："></a>AS_path属性：</h1><p>该属性为公认必遵属性，是前往目标网络的路由经过的AS号列表；<br>作用：确保路由在EBGP对等体之间传递无环；另外也作为路由优选的衡量标准之一；<br>路由在被通告给EBGP对等体时，路由器会在该路由的AS_Path中追加上本地的AS号；路由被通告给IBGP对等体时，AS_Path不会发生改变。</p>
<p><strong>AS_path防环机制</strong>：路由每经过一个AS就会在AS_path中记录经过的AS 号，当路由器收到update报文，检查发现AS_path中含有本AS号，不接收该路由，从而防止了路由环路的产生。</p>
<p>AS_path影响路由优选：收到同一个网段多条路，比较AS_path属性，哪条路由的AS_Path属性值较短，也即AS号的个数更少，就优选哪条路由。</p>
<p><strong>AS-PATH类型：</strong></p>
<p>AS_SEQENCE：AS在传递时是有序的，默认就是该类型<br>AS_SET：无序的，在做路由聚合时可以使用该类型。路由聚合解决了两类问题，一是减轻了设备的负担，二是隐藏了明细的路由信息，减少了路由震荡的影响。但是路由聚合后，AS_Path属性丢失，存在产生环路的风险，为此可以通过AS_SET类型的AS_Path属性携带聚合前的AS路径信息。</p>
<p>修改AS_path：</p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps7.jpg" alt="img"> </p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps8.jpg" alt="img"> </p>
<p>在export方向上修改，修改完之后，再加上本as再发布出去。例如：添加一个100as号：发布出去是64512（加上本as）、100（追加的）、64513（上一个经历的as号）</p>
<p>①additive</p>
<p>#</p>
<p> acl number 2000  </p>
<p> rule 5 permit source 10.10.10.10 0 </p>
<p>#</p>
<p>route-policy aa permit node 10 </p>
<p> if-match acl 2000 </p>
<p> apply as-path 500 additive</p>
<p>#</p>
<p>bgp 200</p>
<p> peer 5.5.5.5 route-policy aa export</p>
<p>②overwrite</p>
<p>#</p>
<p> acl number 2000  </p>
<p> rule 5 permit source 10.10.10.10 0 </p>
<p>#</p>
<p>route-policy aa permit node 10 </p>
<p> if-match acl 2000 </p>
<p> apply as-path 500 overwrite</p>
<p>#</p>
<p>bgp 200</p>
<p> peer 5.5.5.5 route-policy aa export</p>
<h1 id="Origin属性"><a href="#Origin属性" class="headerlink" title="Origin属性"></a>Origin属性</h1><p>Origin属性用来定义路径信息的来源，标记一条路由是怎么成为BGP路由的。它有以下3种类型：</p>
<ul>
<li>IGP：具有最高的优先级。通过路由始发AS的IGP得到的路由信息，比如通过<strong>network</strong>命令注入到BGP路由表的路由，其Origin属性为IGP。</li>
<li>EGP：优先级次之。通过EGP得到的路由信息，其Origin属性为EGP。</li>
<li>Incomplete：优先级最低。通过其他方式学习到的路由信息。比如BGP通过<strong>import-route</strong>命令引入的路由，其Origin属性为Incomplete。</li>
</ul>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/image-20240511140106339.png" alt="image-20240511140106339"></p>
<p>当去往同一个目的地存在多条不同Origin属性的路由时，在其他条件都相同的情况下，BGP将按如Origin的下顺序优选路由：IGP &gt; EGP &gt; Incomplete。也就是i &gt; e &gt; ?</p>
<p>（注意：如果ospf学习到1.1.1.1一条路由，bgp中network1.1.1.1，bgp路由表中不会通告这个路由，因为ospf学习到的优先，bgp传递的一个机制）</p>
<h1 id="Next-Hop"><a href="#Next-Hop" class="headerlink" title="Next-Hop"></a>Next-Hop</h1><ul>
<li><p>BGP的下一跳属性和IGP的有所不同，不一定就是邻居的IP地址。通常情况下，Next_Hop属性遵循下面的规则：</p>
<ul>
<li>BGP Speaker在向EBGP对等体发布某条路由时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。</li>
<li>BGP Speaker将本地始发路由发布给IBGP对等体时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。</li>
<li>BGP Speaker在向IBGP对等体发布从EBGP对等体学来的路由时，并不改变该路由信息的下一跳属性。</li>
<li>BGP路由器本身始发的路由，下一跳是0.0.0.0</li>
</ul>
</li>
</ul>
<p>IBGP在进行路由传递时，下一跳地址 不变会造成路由不可达这种情况，可以使用一下命令修改</p>
<p>[AR2-bgp]peer 4.4.4.4 next-hop-local</p>
<h1 id="Local-Preference"><a href="#Local-Preference" class="headerlink" title="Local_Preference"></a>Local_Preference</h1><p>Local_Preference即本地优先级属性，是公认任意属性，可以用于告诉AS中的路由器，哪条路径是<strong>离开本AS的首选路径</strong>。<br>Local_Preference属性值越大则BGP路由越优。缺省的Local_Preference值为<strong>100</strong>。<br>该属性<strong>只能被传递给IBGP对等体</strong>，而不能传递给EBGP对等体。<strong>越大越优。</strong></p>
<p>注意事项：</p>
<p>Local_Preference属性只能在IBGP对等体间传递（除非做了策略否则Local_Preference值在IBGP对等体间传递过程中不会丢失），而不能在EBGP对等体间传递，如果在EBGP对等体间收到的路由的路径属性中携带了Local_Preference，则会进行错误处理。<br>但是可以在<strong>AS边界路由器上使用Import方向的策略来修改Local_Preference属性值。</strong>也就是在收到路由之后，在本地为路由赋予Local_Preference。<br>使用bgp default local-preference命令修改缺省Local_Preference值，该值缺省为100。<br><strong>路由器在向其EBGP对等体发送路由更新时，不能携带Local_Preference属性，但是对方接收路由之后，会在本地为这条路由赋一个缺省Local_Preference值（100），然后再将路由传递给自己的IBGP对等体。</strong><br>本地使用network命令及import-route命令引入的路由， Local_Preference为缺省值100，并能在AS内向其他IBGP对等体传递，传递过程中除非受路由策略影响，否则Local_Preference不变</p>
<h1 id="Community（团体）"><a href="#Community（团体）" class="headerlink" title="Community（团体）"></a>Community（团体）</h1><p>Community属性为可选过渡属性，是一种路由标记，用于简化路由策略的执行。<br>可以将某些路由分配一个特定的Community属性值，之后就可以基于Community值而不是网络前缀&#x2F;掩码信息来匹配路由并执行相应的策略了。</p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps9.jpg" alt="img"> </p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps10.jpg" alt="img"> </p>
<h1 id="MED"><a href="#MED" class="headerlink" title="MED"></a>MED</h1><p>（Multi-Exit Discriminator，多出口鉴别器）是可选非过渡属性，是一种度量值，用于向外部对等体指出进入本AS的首选路径，即当进入本AS的入口有多个时，AS可以使用MED动态地影响其他AS选择进入的路径。<br>MED属性值<strong>越小则BGP路由越优</strong>。<br>MED主要用于在AS之间影响BGP的选路。MED被传递给EBGP对等体后，对等体在其AS内传递路由时，携带该MED值，但将路由再次传递给其EBGP对等体时，<strong>缺省不会携带MED属性</strong>。0-4294967295</p>
<p>注意事项：</p>
<p>缺省情况下，<strong>路由器只比较来自同一相邻AS的BGP路由的MED值</strong>，也就是说如果去往同一个目的地的两条路由来自不同的相邻AS，则不进行MED值的比较。<br>一台BGP路由器将路由通告给EBGP对等体时，是否携带MED属性，需要根据以下条件进行判断（不对EBGP对等体使用策略的情况下）：<br>如果该BGP路由是本地始发（本地通过network或import-route命令引入）的，则缺省携带MED属性发送给EBGP对等体。<br>如果该BGP路由为从BGP对等体学习到，那么该路由传递给EBGP对等体时缺省不会携带MED属性。<br>在IBGP对等体之间传递路由时，MED值会被保留并传递，除非部署了策略，否则MED值在传递过程中不发生改变也不会丢失。<br>如果路由器通过IGP学习到一条路由，并通过network或import-route的方式将路由引入BGP，产生的BGP路由的MED值继承路由在IGP中的metric。</p>
<p>可以使用default med命令修改缺省的MED值，default med命令只对本设备上用import-route命令引入的路由和BGP的聚合路由生效。</p>
<h1 id="Preferred-Value（协议首选值）"><a href="#Preferred-Value（协议首选值）" class="headerlink" title="Preferred-Value（协议首选值）"></a>Preferred-Value（协议首选值）</h1><p>是华为设备的特有属性，该属性仅在本地有效。当BGP路由表中存在到相同目的地的路由时，将优先选择Preferred-Value值高的路由。<br>取值范围：0~65535；该值越大，则路由越优先。<br>Preferred-Value只能在路由器本地配置，而且只影响本设备的路由优选。该属性不会传递给任何BGP对等体。</p>
<h1 id="路由反射器"><a href="#路由反射器" class="headerlink" title="路由反射器"></a>路由反射器</h1><p>作用：解决IBGP全互联的问题</p>
<p><img src="/2024/05/11/BGP%E6%80%BB%E7%BB%93/wps1-1715409454233-11.jpg" alt="img"> </p>
<p>1、RR从EBGP学习到的，会发送给client和非client</p>
<p>2、RR从非client学习到的路由，会反射给自己的client，但是不会给非client</p>
<p>3、RR从client学习到的路由，会反射非自己的非client和client</p>
<p>非非不传</p>
<p>路由反射器中的防环：<strong>Originator_ID，Cluster_List</strong><br>RR将一条BGP路由进行反射时会在反射出去的路由中增加Originator_ID，其值为本地AS中通告该路由的BGP路由器Router ID。<br>若AS内存在多个RR，<strong>则Originator_ID属性由第一个RR创建</strong>，并且不被后续的RR（若有）所更改。<br>当BGP路由器收到一条携带Originator_ID属性的IBGP路由，并且Originator_ID属性值与自身的Router ID相同，则它会忽略关于该条路由的更新。</p>
<p> （Originator_ID，Cluster_List在第一个RR上看不见，是第一个RR发出去时才加上，在后边可以看到）</p>
<p>路由反射簇包括<strong>反射器RR及其Client</strong>。一个AS内允许存在多个路由反射簇（如下图）。<br>每一个簇都有唯一的簇ID（Cluster_ID，缺省时为RR的BGP Router ID ）。<br>当一条路由被反射器反射后，该RR（该簇）的Cluster_ID就会被添加至路由的Cluster_list属性中。<br>当RR收到一条携带Cluster_list属性的BGP路由，且该属性值中包含该簇的Cluster_ID时，RR认为该条路由存在环路，因此将忽略关于该条路由的更新。</p>
<p>配置：</p>
<p>在RR路由器上配置：</p>
<p>Bgp 200</p>
<p>   peer 6.6.6.6 reflect-client  –谁是client，就peer谁</p>
<p>缺省情况下，每个路由反射器使用自己的Router ID作为集群ID。<br>[Huawei-bgp] reflector cluster-id  20.2.2.2</p>
<h1 id="路由优选原则："><a href="#路由优选原则：" class="headerlink" title="路由优选原则："></a>路由优选原则：</h1><p>P   L  L  A  O  M  E  N 漂亮老男人</p>
<p>p—Preference Value (越大越优，仅限路由器本地)</p>
<p>L— Local Preference，本地优先级 (越大越优，同一AS内的路由器）</p>
<p>L— 手动聚合-&gt;自动聚合-&gt;network-&gt;import，为本地始发</p>
<p>A —AS Path (短的优先)</p>
<p>O —Origin，起源i(network)&gt;e(EBGP)&gt;? (import-route)</p>
<p>M—MED (值越小越优，本AS内或上游AS内所有路由器，EBGP邻居上设置)</p>
<p>E— EBGP优于IBGP (前面都一样，比不出最优路径时)</p>
<p>N— Next-Hop，下一跳(BGP选择IGP下一跳cost值最小的)</p>
<p>9.优选Cluster-List最短的路由</p>
<p>10.优选Router-ID（Origintor- ID）最小的设备通告的路由</p>
<p>11.优选具有最小的IP地址的对等体通告的路由</p>
<p>前八条全部相同形成路由负载分担</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>BGP</tag>
      </tags>
  </entry>
  <entry>
    <title>BGP实验</title>
    <url>/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="BGP基础实验"><a href="#BGP基础实验" class="headerlink" title="BGP基础实验"></a>BGP基础实验</h1><p>设备连接方式、IP地址规划、BGP AS号如图所示，所有设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号，所有设备都使用Loopback0接口IP地址作为BGP Router ID。R1、R5上存在Loopback1模拟用户网段。</p>
<p>R2、R3、R4之间运行OSPF，在R2、R3、R4的互联接口、Loopback0接口上激活OSPF。!</p>
<span id="more"></span>

<h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>你是公司的网络管理员。公司的网络采用了BGP协议作为路由协议。公司的网络由多个自治系统组成，不同的分支机构使用了不同的AS号，现在你需要完成公司网络的搭建工作。在公司总部使用了OSPF作为IGP，公司内部不同分支机构使用的是私有的BGP AS号。</p>
<p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/bgpadaw110633.png" alt="bgpadaw110633"></p>
<h1 id="1-配置ip"><a href="#1-配置ip" class="headerlink" title="1.配置ip"></a>1.配置ip</h1><p>如拓扑图配置各个接口ip，和loopback 0 ：10.0.x.x</p>
<p>r1 loopback 1 ：10.1.1.1 24</p>
<p>r5 loopback 1 ：10.1.5.5 24</p>
<p>r2 r3 r4配置ospf：略</p>
<h1 id="2-配置IBGP对等体"><a href="#2-配置IBGP对等体" class="headerlink" title="2.配置IBGP对等体"></a>2.配置IBGP对等体</h1><p>在R2、R3、R4之间基于Loopback0接口建立全互联的IBGP对等体关系。</p>
<p>#R2上配置BGP</p>
<p>[R2]bgp 64512</p>
<p>[R2-bgp] router-id 10.0.2.2</p>
<p>[R2-bgp] peer 10.0.3.3 as-number 64512</p>
<p>[R2-bgp] peer 10.0.3.3 connect-interface LoopBack0</p>
<p>[R2-bgp] peer 10.0.4.4 as-number 64512</p>
<p>[R2-bgp] peer 10.0.4.4 connect-interface LoopBack0</p>
<p>#R3上配置BGP</p>
<p>[R3]bgp 64512</p>
<p>[R3-bgp] router-id 10.0.3.3</p>
<p>[R3-bgp] peer 10.0.2.2 as-number 64512</p>
<p>[R3-bgp] peer 10.0.2.2 connect-interface LoopBack0</p>
<p>[R3-bgp] peer 10.0.4.4 as-number 64512</p>
<p>[R3-bgp] peer 10.0.4.4 connect-interface LoopBack0</p>
<p>#R4上配置BGP</p>
<p>[R4]bgp 64512</p>
<p>[R4-bgp] peer 10.0.2.2 as-number 64512</p>
<p>[R4-bgp] peer 10.0.2.2 connect-interface LoopBack0</p>
<p>[R4-bgp] peer 10.0.3.3 as-number 64512</p>
<p>[R4-bgp] peer 10.0.3.3 connect-interface LoopBack0</p>
<p>#分别在R2、R3、R4上检查BGP对等体状态</p>
<h1 id="3-配置EBGP对等体"><a href="#3-配置EBGP对等体" class="headerlink" title="3.配置EBGP对等体"></a>3.配置EBGP对等体</h1><p>（一般情况使用直连接口建立EBGp）</p>
<p>在R1与R2、R4与R5之间基于Loopback0接口建立EBGP对等体关系，为保证能够正常建立，在R1、R2上配置静态路由使Loopback0之间路由可达（R4、R5同样操作）。</p>
<p>#在R1、R2上配置静态路由</p>
<p>[R1]ip route-static 10.0.2.2 32 10.0.12.2</p>
<p>[R2]ip route-static 10.0.1.1 32 10.0.12.1</p>
<p>#在R4、R5上配置静态路由</p>
<p>[R4]ip route-static 10.0.5.5 32 10.0.45.5</p>
<p>[R5]ip route-static 10.0.4.4 32 10.0.45.4</p>
<p>这里配置静态路由，因为要建立TCP会话的前提，需要在数据层面两路由器相通，所以需要需要手工配置静态路由，实现loopback 0 之间互通</p>
<p>#配置R1、R2之间的EBGP对等体</p>
<p>[R1]bgp 64513</p>
<p>[R1-bgp] router-id 10.0.1.1</p>
<p>[R1-bgp] peer 10.0.2.2 as-number 64512</p>
<p>[R1-bgp] peer 10.0.2.2 ebgp-max-hop 2</p>
<p>[R1-bgp] peer 10.0.2.2 connect-interface LoopBack0</p>
<p>[R2]bgp 64512</p>
<p>[R2-bgp] peer 10.0.1.1 as-number 64513</p>
<p>[R2-bgp] peer 10.0.1.1 ebgp-max-hop 2</p>
<p>[R2-bgp] peer 10.0.1.1 connect-interface LoopBack0</p>
<p>默认情况下，EBGP连接允许的最大跳数为1，这导致EBGP对等体之间只能使用直连链路建立EBGP对等体关系，为使用环回口作为更新源需要手动修改EBGP连接允许的最大跳数。</p>
<p>#配置R4、R5之间的EBGP对等体</p>
<p>[R4]bgp 64512</p>
<p>[R4-bgp] peer 10.0.5.5 as-number 64514</p>
<p>[R4-bgp] peer 10.0.5.5 ebgp-max-hop 2</p>
<p>[R4-bgp] peer 10.0.5.5 connect-interface LoopBack0</p>
<p>[R5]bgp 64514</p>
<p>[R5-bgp] router-id 10.0.5.5</p>
<p>[R5-bgp] peer 10.0.4.4 as-number 64512</p>
<p>[R5-bgp] peer 10.0.4.4 ebgp-max-hop 2</p>
<p>[R5-bgp] peer 10.0.4.4 connect-interface LoopBack0</p>
<p>#在R1、R5上检查EBGP对等体状态</p>
<h1 id="4-在BGP中发布路由"><a href="#4-在BGP中发布路由" class="headerlink" title="4.在BGP中发布路由"></a>4.在BGP中发布路由</h1><p>在R1、R5上将Loopback1接口路由发布到BGP</p>
<p>#在R1、R5上通过network命令发布路由</p>
<p>[R1]bgp 64513</p>
<p>[R1-bgp] network 10.1.1.1 24</p>
<p>[R5]bgp 64514</p>
<p>[R5-bgp] network 10.1.5.5 24</p>
<p>在R3上查看BGP路由表</p>
<p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/luyoub122914.png" alt="luyoub122914"></p>
<p>可以看到此时R3上已经学习到R1、R5上发布的BGP路由，但是都是<strong>非有效路由</strong>，这是因为它们的下一跳在R3上都不可达，为此可以在R2、R4上通过<strong>next-hop-local</strong>命令修改下一跳地址为R2、R4的更新源地址。</p>
<p>原因：ebgp对等体在发送数据时，下一跳地址为自身更新源地址，ibgp收到ebgp发送的数据，下一跳不变</p>
<p>#在R2、R4上将路由的下一跳地址修改为自身</p>
<p>[R2]bgp 64512</p>
<p>[R2-bgp] peer 10.0.3.3 next-hop-local</p>
<p>[R2-bgp] peer 10.0.4.4 next-hop-local</p>
<p>[R4]bgp 64512</p>
<p>[R4-bgp] peer 10.0.2.2 next-hop-local</p>
<p>[R4-bgp] peer 10.0.3.3 next-hop-local</p>
<p><strong>peer next-hop-local</strong>命令一般在ASBR上配置。当设备通过EBGP邻居学到路由再转发给其他IBGP邻居时，默认不修改下一跳，但其EBGP邻居发来的路由的下一跳都是其EBGP邻居的Peer地址，本端对等体所属AS域内的IBGP邻居收到这样的路由后，由于下一跳不可达导致路由无法活跃。因此，需要在ASBR上对IBGP邻居配置<strong>peer next-hop-local</strong>命令，使得发给IBGP邻居的路由的下一跳是其自身的地址，IBGP邻居收到这样的路由后（由于域内都配置了IGP）发现下一跳可达，路由即为活跃路由。</p>
<p>此命令为覆盖式命令。</p>
<p>执行<strong>peer next-hop-local</strong>命令后，设备向IBGP对等体&#x2F;对等体组通告路由时，把下一跳属性设为自身的IP地址。</p>
<p><strong>peer next-hop-local</strong>命令仅应用于IBGP对等体间。</p>
<p>再次r3上查看bgp路由表</p>
<p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/louybadwad128123318.png" alt="louybadwad128123318"></p>
<p>此时两条BGP路由都变成了有效、最优的状态。</p>
<p>#在R1、R5上查看BGP路由表<img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/r11128123426.png" alt="r11128123426"></p>
<p>R1、R5之间相互学习到了对端Loopback1接口路由。</p>
<h1 id="BGP路由汇总实验"><a href="#BGP路由汇总实验" class="headerlink" title="BGP路由汇总实验"></a>BGP路由汇总实验</h1><p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/luyouhuizongdaw143536.png" alt="luyouhuizongdaw143536"></p>
<p>BGP AS号、互联地址如图所示，所有设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号。</p>
<p>R1、R2、R3使用Loopback0地址作为BGP Router ID，基于直连接口建立EBGP对等体关系。</p>
<p>R1、R3上存在Loopback1、Loopback2接口，用于模拟用户网段。</p>
<h1 id="1-配置ip-1"><a href="#1-配置ip-1" class="headerlink" title="1.配置ip"></a>1.配置ip</h1><p>略</p>
<h1 id="2-配置EBGPd对等体"><a href="#2-配置EBGPd对等体" class="headerlink" title="2.配置EBGPd对等体"></a>2.配置EBGPd对等体</h1><p>#配置R1</p>
<p>[R1]bgp 64511</p>
<p>[R1-bgp] router-id 10.0.1.1</p>
<p>[R1-bgp] peer 10.0.12.2 as-number 64512</p>
<p>#配置R2</p>
<p>#配置R3</p>
<p>[R3]bgp 64513</p>
<p>[R3-bgp] router-id 10.0.3.3</p>
<p>[R3-bgp] peer 10.0.23.2 as-number 64512</p>
<h1 id="3-BGP路由自动汇总"><a href="#3-BGP路由自动汇总" class="headerlink" title="3.BGP路由自动汇总"></a>3.BGP路由自动汇总</h1><p>在R1上开启BGP路由自动汇总，将Loopback1、Loopback2接口路由发布到BGP中，并进行自动汇总。</p>
<p>#创建IP前缀列表1，匹配Loopback1、Loopback2接口路由</p>
<p>[R1]ip ip-prefix 1 permit 172.16.0.0 16 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1</p>
<p>[R1]route-policy hcip permit node 10</p>
<p>[R1-route-policy] if-match ip-prefix 1</p>
<p>[R1-route-policy] quit</p>
<p>[R1]bgp 64511</p>
<p>[R1-bgp] import-route direct route-policy hcip</p>
<p>[R1-bgp] summary automatic</p>
<p>Info: Automatic summarization is valid only for the routes imported through the import-route command.</p>
<p>自动汇总只对通过<strong>import-route</strong>命令引入的路由生效。</p>
<p>#在R1上查看BGP路由表</p>
<p><R1>display	bgp	routing-table	</R1></p>
<p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/r11128123426.png" alt="r11128123426"></p>
<p>Loopback1、Loopback2接口路由已经发布到BGP，由于R1激活了BGP路由自动汇总，因此R1会将这些路由汇总成172.16.0.0&#x2F;16，同时抑制所有的明细路由，通过明细路由前的“s”标记可以看出，该标记的含义为“suppressed”，表示被抑制，最终R1只对外通告汇总路由172.16.0.0&#x2F;16。</p>
<p>#在R2上查看BGP路由表</p>
<p><R2>display bgp routing-table </R2></p>
<p>R2上只能看到一条主类路由172.16.0.0&#x2F;16。</p>
<p>#在R2上查看BGP路由172.16.0.0的明细信息</p>
<p><R2>display bgp routing-table 172.16.0.0</R2></p>
<p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/r2jyj28150027.png" alt="r2jyj28150027"></p>
<p>该路由的路径属性中存在Aggregator属性，其中携带了汇总路由生成设备所属的AS号以及其Router ID</p>
<h1 id="4-BGP路由手动汇总"><a href="#4-BGP路由手动汇总" class="headerlink" title="4.BGP路由手动汇总"></a>4.BGP路由手动汇总</h1><p>在R3上将Loopback1、Loopback2接口路由发布到BGP，在R2上通过<strong>aggregate</strong>命令执行手动汇总，并抑制明细路由的对外发布。</p>
<p>#创建IP前缀列表1，匹配Loopback1、Loopback2接口路由</p>
<p>[R3]ip ip-prefix 1 permit 172.17.0.0 16 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10，在其中调用IP前缀列表1</p>
<p>[R3]route-policy hcip permit node 10</p>
<p>[R3-route-policy] if-match ip-prefix 1</p>
<p>[R3-route-policy] quit</p>
<p>#将Loopback1、Loopback2接口路由发布到BGP </p>
<p>[R3]bgp 64513</p>
<p>[R3-bgp] import-route direct route-policy hcip</p>
<p>#查看R2的BGP路由表</p>
<p><R2>display	bgp	routing-table</R2></p>
<p>​	<img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/QQr2aef31128150511.png" alt="QQr2aef31128150511"></p>
<p>在R2的BGP路由表中已经存在R3通告的BGP路由172.17.1.0&#x2F;24、172.17.2.0&#x2F;24。</p>
<p>#R2上执行手动路由汇总，将172.17.1.0&#x2F;24、172.17.2.0&#x2F;24汇总成172.17.0.0&#x2F;22，并抑制明细路由的对外通告</p>
<p>[R2]bgp 64512</p>
<p>[R2-bgp] aggregate 172.17.0.0 22 detail-suppressed</p>
<p>#查看R2的BGP路由表</p>
<p><R2>display	bgp	routing-table</R2></p>
<p>​	</p>
<p>此时在R2的BGP路由表中可以看到汇总后的路由。</p>
<p> <img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/radwahh128150729.png" alt="radwahh128150729"></p>
<p>#在R2上查看BGP路由172.16.0.0&#x2F;22的明细信息</p>
<p><R2>display bgp routing-table 172.17.0.0 22</R2></p>
<p>从输出信息<img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/diushi222f1030.png" alt="diushi222f1030">可以看到AS_Path值为Nil，代表了AS_Path属性值为空，这意味着丢失了明细的AS_Path属性值，BGP依赖AS_Path实现防环，因此AS_Path属性的丢失可能带来路由环路。从该条路由对外通告的对等体中可以看到10.0.23.3（R3)。</p>
<p>#查看R3的BGP路由表</p>
<p>在R3的BGP路由表中可以看到汇总路由172.17.0.0&#x2F;22。</p>
<p>#为防止路由环路，在R2上执行手动汇总时增加as-set关键字</p>
<p>[R2]bgp 64512</p>
<p>[R2-bgp] aggregate 172.17.0.0 255.255.252.0 detail-suppressed as-set</p>
<p>#再次在R2上查看BGP路由172.17.0.0&#x2F;22的明细信息</p>
<p><img src="/2023/11/28/BGP%E5%AE%9E%E9%AA%8C/as645138151320.png" alt="as645138151320"></p>
<p>可以看到此时AS_Path属性值为64513，此时该条路由<strong>依旧向10.0.23.3（R3）</strong>通告。</p>
<p>R3收到关于172.17.0.0&#x2F;22的通告之后，在AS_Path中将看到自身的AS号（64153），将会忽略该路由通告。此时R3的BGP路由表中无法看到汇总路由172.17.0.0&#x2F;22，因此通过在手动路由汇总的配置中使用as-set关键字顺利地规避了路由环路的产生。</p>
<h1 id="BGP路由反射器"><a href="#BGP路由反射器" class="headerlink" title="BGP路由反射器"></a>BGP路由反射器</h1>]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>BGP</tag>
      </tags>
  </entry>
  <entry>
    <title>BGP路由反射器</title>
    <url>/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/</url>
    <content><![CDATA[<h1 id="BGP路由反射器"><a href="#BGP路由反射器" class="headerlink" title="BGP路由反射器"></a>BGP路由反射器</h1><p>由于水平分割的原因，为了保证AS内所有的BGP路由器都能学习到完整的BGP路由，就必须在AS内实现IBGP全互联。</p>
<p>然而实现IBGP全互联存在诸多短板：</p>
<p> 路由器需维护大量的TCP及BGP连接，尤其在路由器数量较多时。</p>
<p> AS内BGP网络的可扩展性较差，因为通过纯手工配置命令。</p>
<p>为了解决该问题，可应用到RR路由反射器技术。</p>
<p>1、Client：RR客户端，在RR设备上通过手动指定。</p>
<blockquote>
<p>指定命令：peer 邻居 reflect-client</p>
</blockquote>
<p>2、除了指定的设备为客户端，其它设备均为非客户端。</p>
<p>实验：</p>
<p>R1、R2、R3、R4都属于AS64511，其连接方式、互联接口地址如图所示。每台设备均创建Loopback0接口，IP地址为10.0.x.x&#x2F;32，其中x为设备编号。R1、R2上的Loopback1地址分别为10.1.1.1&#x2F;24、10.2.2.2&#x2F;24，用于模拟用户网段。</p>
<span id="more"></span>

<p>所有设备都使用Loopback0地址作为BGP Router ID，R1与R2、R2与R3、R3与R4、R4与R2之间基于直连接口建立IBGP对等体关系，其中R1为R2的路由反射器客户端，R2为R3的路由反射器客户端，R3为R4的路由反射器客户端。</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/bgpluy8165208.png" alt="bgpluy8165208"></p>
<p>配置ip地址：略</p>
<p>建立ibgp对等体：略</p>
<h1 id="配置路由反射器"><a href="#配置路由反射器" class="headerlink" title="配置路由反射器"></a>配置路由反射器</h1><p>#R2上将R1配置为路由反射器客户端</p>
<p>[R2]bgp 64511</p>
<p>[R2-bgp] peer 10.0.1.1 reflect-client</p>
<p>#R3上将R2配置为路由反射器客户端</p>
<p>[R3]bgp 64511</p>
<p>[R3-bgp] peer 10.0.2.2 reflect-client</p>
<p>#R4上将R3配置为路由反射器客户端</p>
<p>[R4]bgp 64511</p>
<p>[R4-bgp] peer 10.0.3.3 reflect-client</p>
<h1 id="验证Orginator-ID实现路由防环"><a href="#验证Orginator-ID实现路由防环" class="headerlink" title="验证Orginator_ID实现路由防环"></a>验证Orginator_ID实现路由防环</h1><p>在本步骤中，我们将在R2上发布BGP路由10.2.2.0&#x2F;24，并观察该路由依次经路由反射器R3、R4反射后，被通告回R2从而引发潜在路由环路风险的情况。</p>
<p>缺省情况下，R2发布BGP路由后，该路由将被R2直接通告给R4，另一方面也会通过R3反射给R4，此时R4将优选R2直接通告过来的路由，从而不会再将R3反射过来的路由再反射回给R2。为此，我们需要在R2上部署路由策略，使R2不直接向R4通告10.2.2.0&#x2F;24路由。</p>
<p>#配置路由策略</p>
<p>[R2]acl number 2000</p>
<p>[R2-acl-basic-2000] rule 5 permit</p>
<p>[R2-acl-basic-2000] quit</p>
<p>[R2]route-policy bgp deny node 10</p>
<p>[R2-route-policy] if-match acl 2000</p>
<p>#在BGP中调用路由策略</p>
<p>[R2]bgp 64511</p>
<p>[R2-bgp] peer 10.0.24.4 route-policy bgp export</p>
<p>#在R2上发布路由</p>
<p>[R2]bgp 64511</p>
<p>[R2-bgp] network 10.2.2.0 24</p>
<p>#R2上查看BGP路由10.2.2.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/chakan102224728.png" alt="chakan102224728"></p>
<p>R2将该条路由通告给了R3、R1，但是并未通告给R4。</p>
<p>#R3上查看BGP路由10.2.2.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/r174808.png" alt="r174808"></p>
<p>R3将来自反射器客户端的BGP路由10.2.2.0&#x2F;24反射给了10.0.34.4（R4）。同时该BGP路由的nexthop为10.0.23.2。</p>
<p># R4上查看BGP路由10.2.2.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/r4chakan80119.png" alt="r4chakan80119"></p>
<p>该条路由来自反射器客户端R3，原始路由经由R3反射，路由的nexthop地址并未改变，同时R3为其添加了Orginator_ID属性，值为10.0.2.2。同时R4将该条路由反射给了R2。</p>
<p>#再次在R2上查看BGP路由10.2.2.0&#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/zacifa80349.png" alt="zacifa80349"></p>
<p>依旧只存在本地通告的BGP路由，没有R4通告的BGP路由。</p>
<p>#在R2上查看BGP对等体10.0.4.4的详细信息</p>
<p>display bgp peer 10.0.4.4 verbose</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/safhaofbsh1128180629.png" alt="safhaofbsh1128180629"></p>
<p>从输出信息可以看到R2从R4收到了1个Update报文，未向R4发送Update报文（路由策略限制），但是本地BGP路由表中不存在由R4通告的BGP路由10.2.2.0&#x2F;24。</p>
<p>R4通告的BGP路由Orginator_ID属性值与本地的Router ID一致，R2忽略了该路由通告。</p>
<h1 id="验证Cluster-List实现路由防环"><a href="#验证Cluster-List实现路由防环" class="headerlink" title="验证Cluster_List实现路由防环"></a>验证Cluster_List实现路由防环</h1><p>为了方便观察现象，取消R2上的BGP路由发布，在R1上将Loopback1接口路由发布到BGP，观察Cluster_List如何防止环路。</p>
<p>#取消R2上的BGP路由发布</p>
<p>[R2]bgp 64511</p>
<p>[R2-bgp] undo network 10.2.2.0 255.255.255.0</p>
<p>#在R1上将Loopback1接口路由发布到BGP</p>
<p>[R1]bgp 64511</p>
<p>[R1-bgp] network 10.1.1.0 24</p>
<p>#依次在R1、R2、R3、R4上查看BGP路由10.1.1.0 &#x2F;24的明细信息</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/xinfuaiell181000.png" alt="xinfuaiell181000"></p>
<p>R1为BGP路由10.1.1.0&#x2F;24的始发者，R1将路由通告给了R2</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/2xinfahol128181116.png" alt="2xinfahol128181116"></p>
<p>来自路由反射器客户端R1的BGP路由10.1.1.0&#x2F;24，R2将其反射给了R3</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/3xinmbxmcx1128181206.png" alt="3xinmbxmcx1128181206"></p>
<p>来自路由反射器客户端R2的BGP路由10.1.1.0&#x2F;24，R2反射时添加了Cluster_List属性，值为10.0.2.2，R3将该条路由反射给了R4</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/44xinm1334.png" alt="44xinm1334"></p>
<p>来自路由反射器客户端R3的BGP路由10.1.1.0&#x2F;24，R3反射时添加了Cluster_List属性的值，当前值为10.0.3.3，10.0.2.2，R4将该条路由反射给了R2</p>
<p>#再次查看R2的BGP路由表</p>
<p><img src="/2023/11/28/BGP%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/zaizaici661435.png" alt="zaizaici661435"></p>
<p>R2的BGP路由表中依旧只有一条来自r1的BGP路由10.1.1.0&#x2F;24。</p>
<p>4通告的BGP路由其Cluster_List属性值中包含了R2的Cluster-ID，R2忽略了该路由通告。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>BGP路由反射器</tag>
      </tags>
  </entry>
  <entry>
    <title>BGP高级特性</title>
    <url>/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式是按照一定的模板来匹配字符串的公式，由普通字符（如字符a到z）和特殊字符组成。</p>
<p>普通字符：匹配的对象是普通字符本身。包括所有的大写和小写字母、数字、标点符号以及一些特殊符号。例如：a匹配abc中的a，10匹配10.113.25.155中的10，@匹配<a href="mailto:&#x78;&#120;&#120;&#64;&#x78;&#120;&#x78;&#x2e;&#99;&#111;&#x6d;">&#x78;&#120;&#120;&#64;&#x78;&#120;&#x78;&#x2e;&#99;&#111;&#x6d;</a>中的@。</p>
<p>特殊字符：配合普通字符匹配复杂或特殊的字符串组合。位于普通字符之前或之后用来限制或扩充普通字符的独立控制字符或占位符。用来描述它前面的字符的重复使用方式。限定一个完整的范围。</p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240812193036.png" alt="QQ截图20240812193036"></p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240812193052.png" alt="QQ截图20240812193052"></p>
<h1 id="AS-Path-Filter"><a href="#AS-Path-Filter" class="headerlink" title="AS_Path Filter"></a>AS_Path Filter</h1><p>AS_Path Filter是将BGP中的AS_Path属性作为匹配条件的过滤器，利用BGP路由携带的AS_Path列表对路由进行过滤。</p>
<p>在不希望接收某些AS的路由时，可以利用AS_Path Filter对携带这些AS号的路由进行过滤，从而实现拒绝某些路由。</p>
<img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240812193910.png" alt="QQ截图20240812193910" style="zoom:80%;">



<p>配置</p>
<img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240812194026.png" alt="QQ截图20240812194026" style="zoom:80%;">

<p>（两种方式，①直接peer as-path-filter 1 export②用router-policy过滤）</p>
<p>AS路径过滤器的<strong>默认行为是deny</strong>，即路由如果没有在某一次过滤中被permit则最终不能通过该过滤器的过滤。如果一个过滤器中的所有过滤规则都是deny，则没有路由能通过该过滤器的过滤，<strong>这种情况下需要在多次（或一次）deny之后设置一次permit，允许其余所有路由通过过滤器的过滤。</strong>(注意加空节点)</p>
<p>本地始发的路由，再本地上做export方向的as过滤不行，原因：会先匹配，最后带上as-path发送给邻居</p>
<h1 id="Community-Filter"><a href="#Community-Filter" class="headerlink" title="Community Filter"></a>Community Filter</h1><p>Community Filter与Community属性配合使用，可以在不便使用IP Prefix List和AS_Path Filter时，降低路由管理难度。</p>
<p>团体属性过滤器有两种类型：</p>
<p>基本Community Filter。匹配团体号或公认Community属性。（1-99）</p>
<p><strong>高级Community Filter</strong>。使用正则表达式匹配团体号。（&gt;100）</p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240812194734.png" alt="QQ截图20240812194734"></p>
<p>默认是internet</p>
<p>配置：</p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240812195042.png" alt="QQ截图20240812195042"></p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240812195112.png" alt="QQ截图20240812195112"></p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240812195501.png" alt="QQ截图20240812195501"></p>
<p>思路：</p>
<p>先邻居开启允许通告com unity属性功能（单向的，如果对端也需要传递，对端也要开启）</p>
<p>router-policy1设置路由的com unity值</p>
<p>配置comunity-filter</p>
<p>router-policy2中调用com unity-filter</p>
<p>bgp视图下，对邻居的export&#x2F;import方向调用router-policy2</p>
<h1 id="ORF"><a href="#ORF" class="headerlink" title="ORF"></a>ORF</h1><p>邻居按需发送路由</p>
<p>如果设备希望只接收自己需要的路由，但对端设备又无法针对每个与它连接的设备维护不同的出口策略。此时，可以通过配置BGP基于前缀的ORF（Outbound Route Filters，出口路由过滤器）来满足两端设备的需求。</p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813163948.png" alt="QQ截图20240813163948"></p>
<p>配置：</p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813164104.png" alt="QQ截图20240813164104"></p>
<p>命令：[Huawei-bgp-af-ipv4] peer { group-name | ipv4-address } ip-prefix ip-prefix-name { import | export }</p>
<p>import：对由指定对等体（组）接收的路由应用过滤策略。</p>
<p>export：对向指定对等体（组）发送的路由应用过滤策略。</p>
<p>命令：[Huawei-bgp] peer { group-name | ipv4-address } capability-advertise orf [ non-standard-compatible ] ip-prefix { both | receive | send } [ standard-match ]</p>
<p>non-standard-compatible：指定与非标准设备兼容。</p>
<p>both：表示允许发送和接收ORF报文。</p>
<p>receive：表示只允许接收ORF报文。</p>
<p>send：表示只允许发送ORF报文。</p>
<p>standard-match：指定按照RFC标准规定的前缀匹配规则来匹配路由。</p>
<p>案例：</p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813164433.png" alt="QQ截图20240813164433"></p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813164442.png" alt="QQ截图20240813164442"></p>
<h1 id="BGP对等体组"><a href="#BGP对等体组" class="headerlink" title="BGP对等体组"></a>BGP对等体组</h1><p>对等体组（Peer Group）是一些具有某些相同策略的对等体的集合。</p>
<p>当一个对等体加入对等体组中时，该对等体将获得与所在对等体组相同的配置。</p>
<p>当对等体组的配置改变时，组内成员的配置也相应改变。</p>
<p>在大型BGP网络中，对等体的数量会很多，其中很多对等体具有相同的策略，在配置时会重复使用一些命令，利用对等体组可以简化配置</p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813174230.png" alt="QQ截图20240813174230"></p>
<p>group-name：指定对等体组的名称。字符串形式，区分大小写，不支持空格，长度范围是1~47。当输入的字符串两端使用双引号时，可在字符串中输入空格。</p>
<p>external：表示创建EBGP对等体组。</p>
<p>internal：表示创建IBGP对等体组。</p>
<img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240813174326.png" alt="QQ截图20240813174326" style="zoom:67%;">

<img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240813174332.png" alt="QQ截图20240813174332" style="zoom:67%;">

<h1 id="BGP认证"><a href="#BGP认证" class="headerlink" title="BGP认证"></a>BGP认证</h1><p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813175629.png" alt="QQ截图20240813175629"></p>
<p>BGP使用TCP作为传输协议，只要TCP数据包的源地址、目的地址、源端口、目的端口和TCP序号是正确的，BGP就会认为这个数据包有效，但数据包的大部分参数对于攻击者来说是不难获得的。</p>
<p>为了保证BGP免受攻击，可以在BGP邻居之间使用MD5认证或者Keychain认证来降低被攻击的可能性。</p>
<p>MD5算法配置简单，配置后生成单一密码，需要人为干预才可以更换密码。</p>
<p>Keychain具有一组密码，可以根据配置自动切换，但是配置过程较为复杂，适用于对安全性能要求比较高的网络。</p>
<p><strong>注意：BGP的MD5认证与BGP的Keychain认证互斥。</strong></p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813180027.png" alt="QQ截图20240813180027"></p>
<h1 id="BGP的GTSM"><a href="#BGP的GTSM" class="headerlink" title="BGP的GTSM"></a>BGP的GTSM</h1><p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813175932.png" alt="QQ截图20240813175932"></p>
<p>如果没有使能BGP的GTSM功能，设备收到大量非法BGP报文后，发现是发送给本机的报文，会直接上送控制层面处理。这时将会因为控制层面处理大量攻击报文，导致设备CPU占用率高，系统异常繁忙。</p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813185435.png" alt="QQ截图20240813185435"></p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813185453.png" alt="QQ截图20240813185453"></p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813185459.png" alt="QQ截图20240813185459"></p>
<p>hops：指定需要检测的TTL跳数值。整数形式，取值范围是1~255，缺省值是255。如果配置为hops，则被检测的报文的TTL值有效范围为[255–hops+1, 255]。</p>
<h1 id="4字节AS号"><a href="#4字节AS号" class="headerlink" title="4字节AS号"></a>4字节AS号</h1><p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813185852.png" alt="QQ截图20240813185852"></p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813185936.png" alt="QQ截图20240813185936"></p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813190108.png" alt="QQ截图20240813190108"></p>
<h1 id="路由反射器"><a href="#路由反射器" class="headerlink" title="路由反射器"></a>路由反射器</h1><p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813190147.png" alt="QQ截图20240813190147"></p>
<p>RR1和RR2形成备份，RR1down之后，client2可以从RR2反射学习到路由。配置一样的cluster id，减少路由。</p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813190325.png" alt="QQ截图20240813190325"></p>
<p>每个集群中的RR之间建立不建立客户关系，普通的ibgp邻居</p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813190627.png" alt="QQ截图20240813190627"></p>
<p>分级RR与单级RR的路由发布规则相同。</p>
<p>分级RR设计需要考虑两个因素：</p>
<p>顶层全互联的拓扑大小：如果IBGP全互联数量已经多到难以管理了，则可考虑引入RR分级部署。</p>
<p>可替代路径的数量：该因素影响负载分担和资源消耗。越多的层次越会减少负载分担链路的数量，但需要的路由器资源更少。</p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813191028.png" alt="QQ截图20240813191028"></p>
<p><img src="/2024/08/12/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240813191033.png" alt="QQ截图20240813191033"></p>
]]></content>
      <tags>
        <tag>BGP高级特性</tag>
        <tag>as-path-filter</tag>
        <tag>comunity-filter</tag>
        <tag>正则表达式</tag>
        <tag>备份RR</tag>
        <tag>分级RR</tag>
        <tag>ORF</tag>
      </tags>
  </entry>
  <entry>
    <title>DHCP基础配置</title>
    <url>/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p> DHCP是一种终端自动配置协议，客户端通过DHCP协议可获取一个合法的动态IP地址。</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>随着网络规模的扩大和网络复杂度的提高，网络配置越来越复杂，经常出现计算机位置变化（如便携机或无线网络）和计算机数量超过可分配的IP地址的情况。动态主机配置协议DHCP（Dynamic Host Configuration Protocol）就是为满足这些需求而发展起来的。DHCP协议以服务器&#x2F;客户端（Server&#x2F;Client）模式工作，DHCP客户端向DHCP服务器动态地请求配置信息，DHCP服务器可以很方便地为客户端动态发送配置信息。</p>
<h3 id="DHCP服务器"><a href="#DHCP服务器" class="headerlink" title="DHCP服务器"></a>DHCP服务器</h3><p>DHCP Server即DHCP服务器，负责客户端IP地址的分配。客户端向服务器发送配置申请报文（包括IP地址、子网掩码、缺省网关等参数），服务器根据策略返回携带相应配置信息的报文，请求报文和回应报文都采用UDP进行封装。</p>
<h3 id="DHCP中继"><a href="#DHCP中继" class="headerlink" title="DHCP中继"></a>DHCP中继</h3><p>DHCP Relay即DHCP中继，它是为解决服务器和客户端不在同一个网段而提出来的，它提供了对DHCP广播报文的透明传输功能，能够把DHCP客户端的广播报文透明地传送到其它网段的DHCP服务器上，同样能够把DHCP服务器端的广播报文透明地传送到其它网段的DHCP客户端。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>基本命令<br><strong>pc：</strong></p>
<p>ipconfig &#x2F;release—释放ip地址<br>ipconfig &#x2F;renew—重新获取ip</p>
<p><strong>将DHCP转化为固定的地址：</strong></p>
<p>ip pool 名字—进入地址池<br>staic-bind ip-address 要分配的固定ip mac-address 目标的mac地址—添加固定地址到pc端<br>lease day &lt;0-999&gt;—修改租期（不建议修改）</p>
<p>将部分ip地址排除地址池，用于静态路由配置</p>
<p>ip pool 名字—进入地址池<br>excluded-ip-address 192.168.1.1 192.168.1.50—把1.1到1.50的地址排除出地址池不使用</p>
<p><strong>重置与查看地址池</strong></p>
<p>reset ip pool name 名字—重置ip配置<br>dis ip pool name 名字—查看指定地址池<br>dis ip pool—查看地址池<br>dis ip pool 名字 used—查看使用情况</p>
<p><strong>配置global全局模式</strong></p>
<p>先配置物理接口</p>
<p>interface 接口号—进入物理接口<br>ip address ip地址—配置物理接口IP</p>
<p>DHCP enable—开启DHCP功能<br>ip pool 名字—创建一个ip地址池（有几个网段就建几个池）<br>network 192.168.1.0 mask 24—给ip地址池添加一个网段<br>gateway-list 192.168.1.1—设置192.168.1.1这个ip地址为网关<br>dns-list 8.8.8.8 192.168.1.1—配置DNS为8.8.8.8（前面的优先）<br>interface ip地址—进入物理接口<br>dhcp select global—给接口配置全局模式</p>
<p>将pc更改为DHCP获取IP方式，就可以自动分配ip地址了</p>
<p><strong>interface配置方式</strong><br>基于接口的DHCP的配置方式：<br>配置物理接口的ip网关：</p>
<p>interface 接口号—进入接口<br>ip address IP网关—配置网关</p>
<p>dhcp enable—开启服务<br>dhcp select interface—选择interface这个配置方式<br>dhcp server dns-list 8.8.8.8-–配置DNS服务</p>
<p>注意：这种配置方式分配的ip地址网段，是该接口所在的网段的ip地址，网关就是这个接口的ip地址</p>
<p><strong>relay（中继）配置方式</strong></p>
<p>用于在服务器上做配置，路由器进行转发，减少负载量，可以对整个网络体系进行配置<br>首先要实现服务器与个网段互通<br>在服务器的配置：</p>
<p>服务器物理接口配置ip<br>ip route-static 0.0.0.0 0 下一跳的ip—服务器配置缺省路由保证互通<br>dhcp enable—在服务器开启dhcp功能<br>ip pool 名字—创建ip地址池（需要几个网段就创建几个地址池）<br>network 192.168.1.0 mask 24—创建网段<br>gateway-list 192.168.1.1—创建网关<br>dns-list 8.8.8.8—创建dns<br>interface 物理接口—进入物理接口<br>dhcp select global—选择全局配置模式</p>
<p><strong>在路由器&#x2F;核心交换机上的配置</strong></p>
<p>dhcp enable—开启dhcp功能<br>interface 接口号—进入接口 （需要几个网段就分别进入配置）<br>dhcp select relay—开启中继模式<br>dhcp relay server-ip 服务器物理ip—选择中继分配的接口</p>
<h1 id="基本实验"><a href="#基本实验" class="headerlink" title="基本实验"></a>基本实验</h1><p><img src="/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/newtu222.png" alt="newtu222"></p>
<ol>
<li>R1和R3模拟客户端，作为DHCP Client。</li>
<li>R2作为DHCP Server为R1和R3分配IP地址。</li>
</ol>
<p>动态主机配置协议DHCP（Dynamic Host Configuration Protocol）是一种用于集中对用户IP地址进行动态管理和配置的技术。即使规模较小的网络，通过DHCP也可以使后续增加网络设备变得简单快捷。</p>
<p>DHCP协议由RFC 2131定义，采用客户端&#x2F;服务器通信模式，由客户端（DHCP Client）向服务器（DHCP Server）提出配置申请，服务器返回为客户端分配的配置信息。</p>
<p>DHCP可以提供两种地址分配机制，网络管理员可以根据网络需求为不同的主机选择不同的分配策略。</p>
<p>• 动态分配机制：通过DHCP为主机分配一个有使用期限（这个使用期限通常叫做租期）的IP地址。这种分配机制适用于主机需要临时接入网络或者空闲地址数小于网络主机总数且主机不需要永久连接网络的场景。</p>
<p>• 静态分配机制：网络管理员通过DHCP为指定的主机分配固定的IP地址。相比手工静态配置IP地址，通过DHCP方式静态分配机制避免人工配置发生错误，方便管理员统一维护管理。</p>
<p>配置R2 ip：略</p>
<h2 id="开启DHCP功能"><a href="#开启DHCP功能" class="headerlink" title="开启DHCP功能"></a>开启DHCP功能</h2><p>[R1]dhcp enable </p>
<p>Info: The operation may take a few seconds. Please wait for a moment.done.</p>
<p><strong>dhcp enable</strong>命令是DHCP相关功能的总开关，DHCP Client和DHCP Server等功能都要在执行dhcp enable命令使能DHCP功能后才会生效。</p>
<p>[R2]dhcp enable </p>
<p>Info: The operation may take a few seconds. Please wait for a moment.done.</p>
<p>[R3]dhcp enable </p>
<p>Info: The operation may take a few seconds. Please wait for a moment.done.</p>
<h2 id="配置地址池"><a href="#配置地址池" class="headerlink" title="配置地址池"></a>配置地址池</h2><p># 配置R2的GigabitEthernet 0&#x2F;0&#x2F;0的接口地址池，为R1分配IP地址 </p>
<p>[R2]interface GigabitEthernet 0&#x2F;0&#x2F;0</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;0]dhcp select interface </p>
<p><strong>dhcp select interface</strong>命令用来开启接口采用接口地址池的DHCP Server功能。若不执行此命令，则无法配置接口地址池的相关参数。</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;0]dhcp server dns-list 10.0.12.2 </p>
<p><strong>dhcp server dns-list</strong>命令用来指定接口地址池下的DNS服务器地址。最多可以配置8个DNS Server的IP地址，用空格分隔。</p>
<p># 配置全局地址池 </p>
<p>[R2]ip pool GlobalPool</p>
<p>Info: It’s successful to create an IP address pool.</p>
<p><em>创建名<strong>为</strong>G**lobalPool的地址池</em></p>
<p>[R2-ip-pool-GlobalPool]network 10.0.23.0 mask 24 </p>
<p><strong>network</strong>命令用来配置全局地址池下可分配的网段地址。</p>
<p>[R2-ip-pool-GlobalPool]dns-list 10.0.23.2 </p>
<p>[R2-ip-pool-GlobalPool]gateway-list 10.0.23.2 </p>
<p><strong>gateway-list</strong>命令用来为DHCP Client配置出口网关地址。R3在获取地址之后，会生成一条默认路由，下一跳地址为10.0.23.2。</p>
<p>[R2-ip-pool-GlobalPool]lease day 2 hour 2 </p>
<p><strong>lease</strong>命令用来配置地址池下的地址租期。当租约被设置为<strong>unlimited</strong>时，代表租期无限制。缺省情况下，IP地址租期是1天。</p>
<p>[R2-ip-pool-GlobalPool]static-bind ip-address 10.0.23.3 mac-address 00e0-fc6f-6d1f</p>
<p><strong>static-bind</strong>命令用来将DHCP Server全局地址池下的IP地址与MAC地址进行绑定。00e0-fc6f-6d1f为当前实验环境下R3的GigabitEthernet0&#x2F;0&#x2F;0接口的MAC地址，可以在R3上通过命令“display interface GigabitEthernet0&#x2F;0&#x2F;0”来查看接口的MAC地址。配置完这条命令之后，R3会获得固定的IP–10.0.23.3。</p>
<p>[R2-ip-pool-GlobalPool]quit</p>
<p>#开启R2 GigabitEthernet 0&#x2F;0&#x2F;1接口的DHCP Server功能，为R3分配IP地址  </p>
<p>[R2]interface GigabitEthernet 0&#x2F;0&#x2F;1</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1]dhcp select global</p>
<p><strong>dhcp select global</strong>命令用来开启接口采用全局地址池的DHCP Server功能。当接口收到DHCP Client请求之后，会到所有全局地址池中查找对应的地址池，然后分配可用的地址给DHCP Client。</p>
<h2 id="配置DHCP-Client"><a href="#配置DHCP-Client" class="headerlink" title="配置DHCP Client"></a>配置DHCP Client</h2><p>[R1]interface GigabitEthernet 0&#x2F;0&#x2F;0</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;0] ip address dhcp-alloc</p>
<p>[R3]interface GigabitEthernet 0&#x2F;0&#x2F;0</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;0] ip address dhcp-alloc</p>
<h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><h5 id="查看R1和R3的地址及路由等信息"><a href="#查看R1和R3的地址及路由等信息" class="headerlink" title="查看R1和R3的地址及路由等信息"></a>查看R1和R3的地址及路由等信息</h5><p>[R1]display ip interface brief </p>
<p>Interface             	IP Address&#x2F;Mask    Physical  	Protocol  </p>
<p>GigabitEthernet0&#x2F;0&#x2F;0       	<strong>10.0.12.254&#x2F;24</strong>    	up     up     </p>
<p> <em>仅保留<strong>关键信息，可</strong>以<strong>看到</strong>R1已经<strong>获取到了</strong>IP地址**。</em></p>
<p>[R1]display dns server </p>
<p>Type:</p>
<p>D:Dynamic   S:Static</p>
<p>No.  Type   IP Address</p>
<p>1   D   	10.0.12.2 </p>
<p><em>仅保留<strong>关键信息，可</strong>以<strong>看到</strong>R1已经<strong>获取到了DNS</strong>地址**。</em></p>
<p>[R1]display ip routing-table </p>
<p>Destination&#x2F;Mask   Proto  	Pre  Cost  	Flags 	NextHop     Interface</p>
<p>   0.0.0.0&#x2F;0  		<strong>Unr</strong>   60  0    D  		10.0.12.2    GigabitEthernet0&#x2F;0&#x2F;0</p>
<p><em>仅保留<strong>关键信息，可</strong>以<strong>看到</strong>R1已经<strong>获取到了</strong>默认路由**。</em></p>
<p>[R3]display ip interface brief </p>
<p>Interface            	IP Address&#x2F;Mask    Physical 	Protocol  </p>
<p>GigabitEthernet0&#x2F;0&#x2F;0       	<strong>10.0.23.3&#x2F;24</strong>     	up    up     </p>
<p><em>仅保留<strong>关键信息，可</strong>以<strong>看到</strong>R3已经<strong>获取到了</strong>固定<strong>的</strong>IP地址**。</em></p>
<p>[R3]display dns server </p>
<p>Type:</p>
<p>D:Dynamic   S:Static</p>
<p>No.  Type   IP Address</p>
<p>1   D    2.23.0.10</p>
<p><em>仅保留<strong>关键信息，可</strong>以<strong>看到</strong>R<strong>3</strong>已经<strong>获取到了DNS</strong>地址**。</em></p>
<p>[R3]display ip routing-table </p>
<p>Route Flags: R - relay, D - download to fib</p>
<p>-—————————————————————————–</p>
<p>Routing Tables: Public</p>
<p>​     Destinations : 8     Routes : 8     </p>
<p>Destination&#x2F;Mask   Proto  	Pre  Cost  Flags 	NextHop   	Interface</p>
<p>   0.0.0.0&#x2F;0    Unr   	60  0   D  		10.0.23.2  	GigabitEthernet0&#x2F;0&#x2F;0</p>
<p><em>仅保留<strong>关键信息，可</strong>以<strong>看到</strong>R3已经<strong>获取到了</strong>默认路由**。</em></p>
<h5 id="2、查看R2上的地址分配情况"><a href="#2、查看R2上的地址分配情况" class="headerlink" title="2、查看R2上的地址分配情况"></a>2、查看R2上的地址分配情况</h5><p>[R2]display ip pool name GlobalPool </p>
<p> Pool-name    : GlobalPool</p>
<p> Pool-No     : 1</p>
<p> Lease      : <strong>2 Days 2 Hours 0 Minutes</strong></p>
<p> Domain-name   : -</p>
<p> DNS-server0   	: 10.0.23.2    </p>
<p> NBNS-server0  	: -        </p>
<p> Netbios-type  		: -        </p>
<p> Position    		: Local      Status      : Unlocked</p>
<p> Gateway-0    : <strong>10.0.23.2</strong>    </p>
<p> Mask      	: <strong>255.255.255.0</strong></p>
<p> VPN instance  		: –</p>
<p> -—————————————————————————-</p>
<p>​     Start      End   Total  Used  Idle(Expired)  Conflict  Disable</p>
<p> -—————————————————————————-</p>
<p>​    10.0.23.1   10.0.23.254  253   <strong>1</strong>     252(0)     0     0</p>
<p> -—————————————————————————-</p>
<p><strong>display ip pool</strong>命令用来查看已配置的IP地址池信息。包括地址池的名称、租期、锁定状态、地址池中IP地址的状态等。</p>
<p>[R2]display ip pool interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p> Pool-name    : <strong>GigabitEthernet****0&#x2F;0&#x2F;1</strong></p>
<p> Pool-No     : 0</p>
<p> Lease      : <strong>1 Days 0 Hours 0 Minutes</strong></p>
<p> Domain-name   : -</p>
<p> DNS-server0   	: <strong>10.0.12.2</strong>    </p>
<p> NBNS-server0  	: -        </p>
<p> Netbios-type  		: -        </p>
<p> Position    	: Interface    Status      : Unlocked</p>
<p> Gateway-0    : <strong>10.0.12.2</strong>    </p>
<p> Mask      	: 255.255.255.0</p>
<p> VPN instance  		: –</p>
<p> -—————————————————————————-</p>
<p>​     Start  		End   		Total  Used  	Idle(Expired)  Conflict  Disable</p>
<p> -—————————————————————————-</p>
<p>​    10.0.12.1   	10.0.12.254  	253   <strong>1</strong>     252(0)     0     0</p>
<p> -—————————————————————————-</p>
<p>当配置接口地址池时，地址池的名称为接口的名称。分配的网关地址为该接口的IP地址，且无法修改。</p>
<h1 id="中继实验"><a href="#中继实验" class="headerlink" title="中继实验"></a>中继实验</h1><p><img src="/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/dhcpzz111.png" alt="dhcpzz111">交换机4上有多个vlan，交换机1模拟dhcp服务器实现为多个vlan分配地址，交换机3作为dhcp终极连接服务器和客户端</p>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="创建VLAN"><a href="#创建VLAN" class="headerlink" title="创建VLAN"></a>创建VLAN</h3><p>[S1]vlan 40</p>
<p>[S3]vlan batch 10 20 30 40</p>
<p>[S4]vlan batch 10 20 30</p>
<h3 id="配置接口放通相应的VLAN"><a href="#配置接口放通相应的VLAN" class="headerlink" title="配置接口放通相应的VLAN"></a>配置接口放通相应的VLAN</h3><p>[S4]interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>[S4-GigabitEthernet0&#x2F;0&#x2F;3] port link-type trunk</p>
<p>[S4-GigabitEthernet0&#x2F;0&#x2F;3] port trunk allow-pass vlan 10 20 30</p>
<p>[S4-GigabitEthernet0&#x2F;0&#x2F;3] quit</p>
<p>[S3]interface GigabitEthernet0&#x2F;0&#x2F;1</p>
<p>[S3-GigabitEthernet0&#x2F;0&#x2F;1] port link-type access</p>
<p>[S3-GigabitEthernet0&#x2F;0&#x2F;1] port default vlan 40</p>
<p>[S3-GigabitEthernet0&#x2F;0&#x2F;1] quit</p>
<p>[S3]interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>[S3-GigabitEthernet0&#x2F;0&#x2F;3] port link-type trunk</p>
<p>[S3-GigabitEthernet0&#x2F;0&#x2F;3] port trunk allow-pass vlan 10 20 30</p>
<p>[S3-GigabitEthernet0&#x2F;0&#x2F;3] quit</p>
<p>[S1]interface GigabitEthernet0&#x2F;0&#x2F;12</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12] port link-type access</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12] port default vlan 40</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12] quit</p>
<p>交换机4和交换机3之间因为放通多个vlan，所以使用trunk口，交换机3和交换机1之间只有一个vlan40，所以配置access口，pvid&#x3D;40</p>
<h3 id="VLANIF配置"><a href="#VLANIF配置" class="headerlink" title="VLANIF配置"></a>VLANIF配置</h3><p>[S4]interface Vlanif 10</p>
<p>[S4-Vlanif10] quit</p>
<p>[S4]interface Vlanif 20</p>
<p>[S4-Vlanif20] quit</p>
<p>[S4]interface Vlanif 30</p>
<p>[S4-Vlanif30] quit</p>
<p>[S3]interface Vlanif 10</p>
<p>[S3-Vlanif10] ip address 10.0.10.3 24</p>
<p>[S3-Vlanif10] quit</p>
<p>[S3]interface Vlanif 20</p>
<p>[S3-Vlanif20] ip address 10.0.20.3 24</p>
<p>[S3-Vlanif20] quit</p>
<p>[S3]interface Vlanif 30</p>
<p>[S3-Vlanif30] ip address 10.0.30.3 24</p>
<p>[S3-Vlanif30] quit</p>
<p>[S3]interface Vlanif 40</p>
<p>[S3-Vlanif40] ip address 10.0.40.3 24</p>
<p>[S3-Vlanif40] quit</p>
<p>[S1]interface Vlanif 40</p>
<p>[S1-Vlanif40] ip address 10.0.40.1 24</p>
<p>[S1-Vlanif40] quit</p>
<p>检查一下交换机3和1之间的连通性</p>
<p>（开启DHCP服务，配置全局地址池，同时为S4上的VLANIF30分配静态IP地址。）：</p>
<h3 id="开启DHCP服务"><a href="#开启DHCP服务" class="headerlink" title="开启DHCP服务"></a>开启DHCP服务</h3><p>[S1]dhcp enable</p>
<h3 id="创建地址池VLAN10，用于给S4的VLANIF10分配地址"><a href="#创建地址池VLAN10，用于给S4的VLANIF10分配地址" class="headerlink" title="创建地址池VLAN10，用于给S4的VLANIF10分配地址"></a>创建地址池VLAN10，用于给S4的VLANIF10分配地址</h3><p>[S1]ip pool vlan10 &#x2F;&#x2F;创建地址池名为vlan10</p>
<p>[S1-ip-pool-vlan10] gateway-list 10.0.10.3  &#x2F;&#x2F;网关是中继上的vlanif 10</p>
<p>[S1-ip-pool-vlan10] network 10.0.10.0 mask 255.255.255.0 &#x2F;&#x2F;设置分配ip范围是10.0.10.1-10.0.10.255</p>
<p>[S1-ip-pool-vlan10] dns-list 10.0.10.3</p>
<p>[S1-ip-pool-vlan10] quit</p>
<h3 id="创建地址池VLAN20，用于给S4的VLANIF20分配地址"><a href="#创建地址池VLAN20，用于给S4的VLANIF20分配地址" class="headerlink" title="创建地址池VLAN20，用于给S4的VLANIF20分配地址"></a>创建地址池VLAN20，用于给S4的VLANIF20分配地址</h3><p>[S1]ip pool vlan20</p>
<p>[S1-ip-pool-vlan20] gateway-list 10.0.20.3</p>
<p>[S1-ip-pool-vlan20] network 10.0.20.0 mask 255.255.255.0</p>
<p>[S1-ip-pool-vlan20] dns-list 10.0.20.3</p>
<p>[S1-ip-pool-vlan20] quit</p>
<h3 id="创建地址池VLAN30，用于给S4的VLANIF30分配地址"><a href="#创建地址池VLAN30，用于给S4的VLANIF30分配地址" class="headerlink" title="创建地址池VLAN30，用于给S4的VLANIF30分配地址"></a>创建地址池VLAN30，用于给S4的VLANIF30分配地址</h3><p>[S1]ip pool vlan30</p>
<p>[S1-ip-pool-vlan30] gateway-list 10.0.30.3</p>
<p>[S1-ip-pool-vlan30] network 10.0.30.0 mask 255.255.255.0</p>
<p>[S1-ip-pool-vlan30] dns-list 10.0.30.3</p>
<p>[S1-ip-pool-vlan30] quit</p>
<h3 id="查看s4的vlanif30的mac"><a href="#查看s4的vlanif30的mac" class="headerlink" title="查看s4的vlanif30的mac"></a>查看s4的vlanif30的mac</h3><p>为了实现给s4的vlanif30口静态绑定一个指定的ip地址，我们需要先查看一下mac<img src="/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/macsiis30.png" alt="macsiis30"></p>
<h3 id="在S1上为S4的VLANIF30配置静态地址分配"><a href="#在S1上为S4的VLANIF30配置静态地址分配" class="headerlink" title="在S1上为S4的VLANIF30配置静态地址分配"></a>在S1上为S4的VLANIF30配置静态地址分配</h3><p><img src="/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/mac0234.png" alt="mac0234"></p>
<p>给s4的vlanif口静态分配ip：10.0.30.2</p>
<h3 id="在VLANIF40接口下使能DHCP-Server"><a href="#在VLANIF40接口下使能DHCP-Server" class="headerlink" title="在VLANIF40接口下使能DHCP Server"></a>在VLANIF40接口下使能DHCP Server</h3><p>[S1]interface Vlanif 40 </p>
<p>[S1-Vlanif40] dhcp select global &#x2F;&#x2F;全局的使能</p>
<h3 id="查看IP地址池配置情况"><a href="#查看IP地址池配置情况" class="headerlink" title="查看IP地址池配置情况"></a>查看IP地址池配置情况</h3><p>[S1]display ip pool name vlan30</p>
<p><img src="/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/3chakan0.png" alt="3chakan0"></p>
<p>地址池vlan30已经存在一个“Used”地址，该地址为静态分配的地址。</p>
<h3 id="配置前往用户网段的路由"><a href="#配置前往用户网段的路由" class="headerlink" title="配置前往用户网段的路由"></a>配置前往用户网段的路由</h3><p>[S1]ip route-static 10.0.10.0 24 10.0.40.3 </p>
<p>[S1]ip route-static 10.0.20.0 24 10.0.40.3</p>
<p>[S1]ip route-static 10.0.30.0 24 10.0.40.3</p>
<p>（或者配置缺省路由）</p>
<p>保证连通性</p>
<p>在S3上完成DHCP Relay相关配置</p>
<h3 id="开启DHCP服务-1"><a href="#开启DHCP服务-1" class="headerlink" title="开启DHCP服务"></a>开启DHCP服务</h3><p>[S3]dhcp enable</p>
<h3 id="在接口上配置DHCP-Relay，指定DHCP-Server"><a href="#在接口上配置DHCP-Relay，指定DHCP-Server" class="headerlink" title="在接口上配置DHCP Relay，指定DHCP Server"></a>在接口上配置DHCP Relay，指定DHCP Server</h3><p>[S3]interface Vlanif10</p>
<p>[S3-Vlanif10] dhcp select relay</p>
<p>[S3-Vlanif10] dhcp relay server-ip 10.0.40.1</p>
<p>[S3-Vlanif10] quit</p>
<p>[S3]interface Vlanif20</p>
<p>[S3-Vlanif20] dhcp select relay</p>
<p>[S3-Vlanif20] dhcp relay server-ip 10.0.40.1</p>
<p>[S3-Vlanif20] quit</p>
<p>[S3]interface Vlanif30</p>
<p>[S3-Vlanif30] dhcp select relay</p>
<p>[S3-Vlanif30] dhcp relay server-ip 10.0.40.1</p>
<p>[S3-Vlanif30] quit</p>
<h3 id="查看relay配置"><a href="#查看relay配置" class="headerlink" title="查看relay配置"></a>查看relay配置</h3><p><img src="/2023/11/25/DHCP%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/relayallss7.png" alt="relayallss7"></p>
<h3 id="DHCP-Client配置"><a href="#DHCP-Client配置" class="headerlink" title="DHCP Client配置"></a>DHCP Client配置</h3><p>在S4上配置VLANIF10、20、30接口通过DHCP获取IP地址</p>
<h4 id="开启DHCP服务-2"><a href="#开启DHCP服务-2" class="headerlink" title="开启DHCP服务"></a>开启DHCP服务</h4><p>[S4]dhcp enable</p>
<h4 id="开启接口通过DHCP获取地址"><a href="#开启接口通过DHCP获取地址" class="headerlink" title="开启接口通过DHCP获取地址"></a>开启接口通过DHCP获取地址</h4><p>[S4]interface Vlanif10</p>
<p>[S4-Vlanif10] ip address dhcp-alloc</p>
<p>[S4-Vlanif10] quit</p>
<p>[S4]interface Vlanif20</p>
<p>[S4-Vlanif20] ip address dhcp-alloc</p>
<p>[S4-Vlanif20] quit</p>
<p>[S4]interface Vlanif30</p>
<p>[S4-Vlanif30] ip address dhcp-alloc</p>
<p>[S4-Vlanif30] quit</p>
<h4 id="查看各个接口IP地址获取情况"><a href="#查看各个接口IP地址获取情况" class="headerlink" title="查看各个接口IP地址获取情况"></a>查看各个接口IP地址获取情况</h4><p><S4>display interface Vlanif 10</S4></p>
<p>Vlanif10 current state : UP</p>
<p>Line protocol current state : UP</p>
<p>Last line protocol up time : 2020-06-05 17:37:57 UTC-08:00</p>
<p>Description:</p>
<p>Route Port,The Maximum Transmit Unit is 1500</p>
<p>Internet Address is allocated by DHCP, 10.0.10.254&#x2F;24</p>
<p>[S4]display interface Vlanif 20</p>
<p>Vlanif20 current state : UP</p>
<p>Line protocol current state : UP</p>
<p>Last line protocol up time : 2020-06-05 17:41:23 UTC-08:00</p>
<p>Description:</p>
<p>Route Port,The Maximum Transmit Unit is 1500</p>
<p>Internet Address is allocated by DHCP, 10.0.20.254&#x2F;24</p>
<p>[S4]display interface Vlanif 30</p>
<p>Vlanif30 current state : UP</p>
<p>Line protocol current state : UP</p>
<p>Last line protocol up time : 2020-06-05 17:43:22 UTC-08:00</p>
<p>Description:</p>
<p>Route Port,The Maximum Transmit Unit is 1500</p>
<p>Internet Address is allocated by DHCP, 10.0.30.2&#x2F;24</p>
<p>接口已经通过DHCP获取到IP地址，并且VLANIF30的地址为静态分配的地址：10.0.30.2。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>DHCP Relay</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title>FTP实验</title>
    <url>/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="File-Transfer-Protocol-文件传输协议"><a href="#File-Transfer-Protocol-文件传输协议" class="headerlink" title="File Transfer Protocol 文件传输协议"></a>File Transfer Protocol 文件传输协议</h1><p>FTP服务器开启21号端口进行控制连接，20号端口与客户端建立数据连接</p>
<p>ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言，它是最通用的信息交换标准。</p>
<p>FTP是用来传送文件的协议。使用FTP实现远程文件传输的同时，还可以保证数据传输的可靠性和高效性。</p>
<p>FTP 是基于客户———服务器（C&#x2F;S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接</p>
<h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><p>FTP支持两种方式的传输：文本（ASCII）方式和二进制（Binary）方式。通常文本文件的传输采用ASCII方式，而图象、声音文件、加密和压缩文件等非文本文件采用二进制方式传输，如果为了从一个系统上传输文件而使用了与本地系统不同的计算机字节位数，那么就必须使用Tenex模式。FTP以ASCII方式作为缺省的文件传输方式。</p>
<h2 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h2><p> 使用FTP进行文件传输时，会使用两个TCP连接。第一个连接是FTP客户端和FTP服务器间的控制连接。FTP服务器开启21号端口，等待FTP客户端发送连接请求。FTP客户端随机开启端口，向服务器发送建立连接的请求。控制连接用于在服务器和客户端之间传输控制命令。<br>        第二个连接是FTP客户端和FTP服务器间的数据连接。服务器使用TCP的20号端口与客户端建立数据连接。通常情况下，服务器主动建立或中断数据连接。</p>
<h2 id="FTP服务器配置"><a href="#FTP服务器配置" class="headerlink" title="FTP服务器配置"></a>FTP服务器配置</h2><p>路由器和X7系列交换机均可提供FTP功能。<br>执行ftp server enable命令使能FTP功能。<br>执行set default ftp-directory命令设置FTP用户的默认工作目录。</p>
<p>在配置FTP服务器时，可以使用AAA为每个用户分别配置登录账号和访问权限。 aaa命令用来进入AAA视图。</p>
<p>  local-user user-name { access-limit max-number | ftp-directory directory | idle-timeout         minutes [ seconds ] | password cipher password [ opt ]         | privilege level level | state {active | block } } *命令用来创建本地用户，并配置本地用户的各项参数。</p>
<pre><code>  user-name指定用户名。
    local-user huawei service-type ftp命令用来配置本地用户的接入类型为ftp。
    ftp-directory指定FTP用户可访问的目录。如果不配置FTP用户可访问的目录，则FTP用户无法登录设备。
    access-limit指定用户名可建立的最大连接数目。
    idle-timeout指定用户的闲置超时时间。
    privilege level指定用户的优先级。
</code></pre>
<h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="idle-timeout"><a href="#idle-timeout" class="headerlink" title="idle-timeout"></a>idle-timeout</h3><p><strong>idle-timeout</strong>命令用来设置用户连接的超时时间。</p>
<p><strong>undo idle-timeout</strong>命令用来恢复超时时间的缺省值。</p>
<p>缺省情况下，用户连接的超时时间是5分钟。</p>
<p>命令格式</p>
<p><strong>idle-timeout</strong> <em>minutes</em> [ <em>seconds</em> ]</p>
<p><strong>undo idle-timeout</strong></p>
<table>
<thead>
<tr>
<th align="left"><em>minutes</em></th>
<th>指定用户界面断连的超时时间的分钟数。</th>
<th>整数形式，取值范围是0～35791，单位是分钟。</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>seconds</em></td>
<td>指定用户界面断连的超时时间的秒数。</td>
<td>整数形式，取值范围是0～59，单位是秒</td>
</tr>
</tbody></table>
<p>缺省级别</p>
<p>3：管理级</p>
<ul>
<li>设置执行命令<strong>idle-timeout</strong> <strong>0 0</strong>即关闭用户界面的超时断连功能。</li>
<li>如果用户界面没有设置闲置断连功能，则会导致已登录的用户始终处于连接状态，给设备带来安全风险，同时还有可能导致其他用户无法获得连接。</li>
<li>通常情况下，推荐设置用户界面断连的超时时间在10～15分钟之间。</li>
</ul>
<p># 设置超时为1分钟30秒。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idle-timeout 1 30</span><br></pre></td></tr></table></figure>



<h3 id="local-user-privilege-level"><a href="#local-user-privilege-level" class="headerlink" title="local-user privilege level"></a>local-user privilege level</h3><p>必须配置在3以上，否则ftp连接无法成功</p>
<p><strong>local-user privilege level</strong>命令用来配置本地用户的优先级。</p>
<p><strong>undo</strong> <strong>local-user privilege level</strong>命令用来将本地用户的优先级恢复为缺省配置。</p>
<p>缺省情况下，本地用户（如Telnet用户、SSH用户）的优先级由管理模块来决定。</p>
<p>命令格式</p>
<p><strong>local-user</strong> <em>user-name</em> <strong>privilege level</strong> <em>level</em></p>
<p><strong>undo local-user</strong> <em>user-name</em> <strong>privilege level</strong></p>
<table>
<thead>
<tr>
<th><em>user-name</em></th>
<th>用户名。</th>
<th>字符串形式，不支持空格，不区分大小写，长度范围是1~64。</th>
</tr>
</thead>
<tbody><tr>
<td><em>level</em></td>
<td>用户的优先级。</td>
<td>整数形式，取值范围是0~15，取值越大，用户的优先级越高。缺省级别是0级。不同级别的用户登录后，只能使用等于或低于自己级别的命令</td>
</tr>
</tbody></table>
<p>缺省情况下，命令级别分为0~3级：</p>
<ul>
<li>级别0即参观级，网络诊断工具命令（ping、tracert）、从本设备出发访问外部设备的命令（包括：Telnet 客户端、SSH）等。该级别命令不允许进行配置文件保存的操作。</li>
<li>级别1即监控级，用于系统维护，包括display命令。该级别命令不允许进行配置文件保存的操作。</li>
<li>级别2即配置级，可以使用业务配置命令，包括路由、各个网络层次的命令，向用户提供直接网络服务。</li>
<li>级别3即管理级，用于系统基本运行的命令，对业务提供支撑作用，包括文件系统、FTP、TFTP、配置文件切换命令、备板控制命令、用户管理命令、命令级别设置命令、系统内部参数设置命令；用于业务故障诊断的debugging命令。</li>
</ul>
<h3 id="access-limit"><a href="#access-limit" class="headerlink" title="access-limit"></a>access-limit</h3><p><strong>access-limit</strong>命令用来配置当前域允许接入的用户数。</p>
<p><strong>undo access-limit</strong>命令用来恢复缺省配置。</p>
<p>缺省情况下，不限制接入的用户数目。</p>
<p>命令格式</p>
<p><strong>access-limit</strong> <em>max-number</em></p>
<p><strong>undo access-limit</strong></p>
<table>
<thead>
<tr>
<th><em>max-number</em></th>
<th>指定允许接入的用户数。</th>
<th>整数形式，取值范围是0～283648。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>为了更方便地管理用户访问设备，可以限制域下用户的在线数量。</p>
<p><strong>注意事项</strong></p>
<p>执行这条配置命令后，当接入用户数大于允许的用户数时，系统不再允许用户接入系统，提示用户认证失败。</p>
<p><strong>access-limit</strong>命令对一个域下所能接入的用户总数进行限制，不区分接入用户的类型。</p>
<p># 设置当前域最多允许接入100个用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access-limit 100</span><br></pre></td></tr></table></figure>



<h3 id="local-user-ftp-directory"><a href="#local-user-ftp-directory" class="headerlink" title="local-user ftp-directory"></a>local-user ftp-directory</h3><p><strong>local-user ftp-directory</strong>命令用来配置本地用户的FTP目录。</p>
<p><strong>undo local-user ftp-directory</strong>命令用来将本地用户的FTP目录恢复为缺省配置。</p>
<p>缺省情况下，本地用户的FTP目录为空。</p>
<p>当需要将设备配置为FTP服务器，从而便于本地用户以FTP方式登录设备，对设备上的文件进行增加、删除、修改等操作时，可以通过本命令配置本地用户以FTP方式登录设备后所处的目录。</p>
<p>不指定该目录时，本地用户无法以FTP方式登录设备。</p>
<p>配置本地用户的FTP目录时，该用户必须已由local-user password命令建立。</p>
<h3 id="local-user-password"><a href="#local-user-password" class="headerlink" title="local-user password"></a>local-user password</h3><p><strong>local-user password</strong>命令用来创建一个本地用户并配置该用户的登录密码，或者修改已创建用户的登录密码。</p>
<p><strong>undo local-user</strong>命令用来删除一个本地用户。</p>
<p>缺省情况下，系统没有本地用户。</p>
<p><strong>local-user</strong> <em>user-name</em> <strong>password</strong> [ <strong>cipher</strong> <em>password</em> | <strong>irreversible-cipher</strong> <em>irreversible-cipher-password</em> ]</p>
<p><strong>undo local-user</strong> <em>user-name</em></p>
<p><strong>cipher</strong> <em>password</em></p>
<p>指定密文密钥。密钥以明文或密文形式输入，但配置文件中保存为密文形式。</p>
<p><strong>irreversible-cipher</strong> <em>irreversible-cipher-password</em></p>
<p>指定不可逆密文密钥。密钥以明文或不可逆密文形式输入，但配置文件中保存为密文形式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.FTP服务器需要开启TCP的21号端口来建立控制连接，20号端口来建立数据连接。</p>
<p>2.如果用户无权访问任何工作目录，则需要定义一个默认的FTP目录。执行set default ftp-directory <directory location>命令建立默认目录。</directory></p>
<h2 id="FTP实验"><a href="#FTP实验" class="headerlink" title="FTP实验"></a>FTP实验</h2><p>R1 做为FTP Server 进行配置<br>R2 做为Client 测试</p>
<p>R1：<br>undo ter mo<br>sys<br>sysname R1<br>int g0&#x2F;0&#x2F;0<br>ip add 192.168.1.1 24</p>
<p>R2：<br>undo ter mo<br>sys<br>sysname R2<br>int g0&#x2F;0&#x2F;0<br>ip add 192.168.1.2 24</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/ftp1130183749.png" alt="ftp1130183749"></p>
<p>R1:<br>ftp server enable<br>set default ftp-directory flash:&#x2F;</p>
<p>（设置默认目录为flash:&#x2F;）</p>
<p><strong>ftp server enable</strong>命令用来开启设备的FTP服务器功能，允许FTP用户登录。缺省情况下，FTP服务器功能处于关闭状态。</p>
<p>其他可选的配置参数还包括：指定FTP服务器端口号、指定FTP服务器的源地址和配置FTP连接空闲时间等。</p>
<p>R1：</p>
<p>通过在AAA中设置用户名和密码（均为huawei）<br>aaa<br>local-user huawei password cipher huawei<br>local-user huawei service-type ftp<br>local-user huawei ftp-directory flash:&#x2F;<br>local-user huawei access-limit 200<br>local-user huawei idle-timeout 0 0<br>local-user huawei privilege level 3</p>
<p>查看ftp server配置信息</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/diskvk30184121.png" alt="diskvk30184121"></p>
<p>R2登录FTP服务器</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/ftpdenglu1130184259.png" alt="ftpdenglu1130184259"></p>
<p>在R1和R2上分别保存文件text1.cfg和text2.cfg，用于后续测试</p>
<p>R1：save text1.cfg</p>
<p>R2：save text2.cfg</p>
<p>R2上通过dir命令查看服务器上的文件</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/dirr2184558.png" alt="dirr2184558"></p>
<p>R2从服务器上下载text1.cfg文件，并改名为newtext1.cfg</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/xiazaigaiming0184834.png" alt="xiazaigaiming0184834"></p>
<p>R2本地查看dir</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/r2bendichakan30184952.png" alt="r2bendichakan30184952"></p>
<p>put把本地文件text2.cfg上传到服务器，并改名为newtext2.cfg</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/putnew85130.png" alt="putnew85130"></p>
<p>查看是否上传成功</p>
<p><img src="/2023/11/30/FTP%E5%AE%9E%E9%AA%8C/yanzg5227.png" alt="yanzg5227"></p>
<p>关闭ftp连接：bye</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hybrid接口</title>
    <url>/2023/12/05/Hybrid%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="接口属性"><a href="#接口属性" class="headerlink" title="接口属性"></a>接口属性</h1><p>​	交换机接口的类型，可以是Access、Trunk和Hybrid。Access类型的接口仅属于一个VLAN,,,,只能接收、转发相应VLAN的帧；而Trunk类型接口则默认属于所有VLAN任何Tagged帧都能经过Trunk接收和转发； Hybrid类型接口则介于二者之间，可自主定义端口上能接收和转发那些VLAN Tag帧，并可决定VLAN Tag是否继续携带或者剥离。。Access和Trunk类型接口是Hybrid类型接口的两个特例，，，一个仅支持一个VLAN传递，，一个默认支持所有VLAN的传递，而Access类型和Trunk类型的接口能做到的，Hybrid接口都能做到。</p>
<p>​    hybrid属性具有trunk和access两种端口属性的特点，tag类似trunk，untag类似access，但是又不同，因为hybrid端口可以接收某个或者多个vlan的数据。</p>
<p>在开始研究之前强调几点：</p>
<p>1、在hybrid端口中，所有端口都默认属于vlan1，除非配置undo port hybrid vlan 1 才能将该hybrid剔除出vlan1，可以使用display vlan 查看端口所属的vlan</p>
<p>2、在hybrid端口中，无论是tag还是untag后面配置的vlan-id就是该hybrid端口所能够收到vlan数据的vlan-id，换句话说就是这些vlan中发出的数据该端口都能收到，可以使用display vlan查看（这里注意虽然可以收到这些vlan的数据但是严格意义上讲hybrid端口并不属于任何一个vlan）</p>
<p>3、所有类型端口的默认pvid都是vlan1，而pvid这个属性只！针对！进入！该端口的！没有标签的！普通数据包有效，作用是将没有标签的普通数据包打上pvid中配置的标签号</p>
<p>4、hybrid属性中，tag是针对于端口的接收方向的（从该端口进来的流量允许带有这些vlan标签的通过），untag是针对端口的发送方向的（从该端口出去的流量去除这些vlan标签）</p>
<p>5、加入一个hybrid端口配置tag vlan 2 3和untag vlan 4 5 ，那么默认情况下这个hybrid属于vlan1、2、3、4、5，在display vlan中可以查看到，只有端口属于了某个vlan，那么该端口才能收到某个vlan的数据包，这一点是理解下列两种配置和hybrid端口属性的关键！！！</p>
<h1 id="收发过程"><a href="#收发过程" class="headerlink" title="收发过程"></a>收发过程</h1><p>在数据发送时untag列表的原理，如下图<br>1.带有vlan 3标签的数据从F0&#x2F;0接口出去，通过时查看untag列表，发现有对应的标签，将标签脱掉发送出去<br>2.带有vlan 8标签的数据从F0&#x2F;1接口出去，通过时查看untag列表，发现没有对应的标签，继续查看tag表，发现有对应标签，所以直接带有vlan 8标签的数据发送出去<br>3.带有vlan 5标签的数据从F0&#x2F;2接口出去，通过时查看untag列表，发现没有对应的标签 ，继续查看tag列表，发现也没有对应的标签，所以数据直接被丢弃<br><img src="/2023/12/05/Hybrid%E6%8E%A5%E5%8F%A3/shoufa6505133622.png" alt="shoufa6505133622"></p>
<p>tag列表处理数据帧的接收和发送的原理，如下图<br>1.没有标签的数据进入F0&#x2F;0接口，接口查看到数据没有标签，根据接口PVID&#x3D;3，将vlan 3标签打入数据<br>2.带有vlan 9标签的数据进入接口F0&#x2F;1，接口查看到数据带有标签，接着查看tag列表，发现列表中存在对应标签，放通数据<br>3.带有vlan 5标签的数据从接口F0&#x2F;2出去，接口查看到数据带有标签，查看untag列表，发现列表中没有对应vlan 5标签，继续查看tag列表，发现列表中存在对应标签vlan 5，放通数据出去<br>4.带有vlan 3标签的数据从F0&#x2F;2接口出去，查看untag列表，发现列表中存在对应vlan 3标签，将标签脱掉，放通数据出去<br>5.带有vlan 9标签的数据从F0&#x2F;2接口出去，查看untag表，发现列表中不存在对应vlan 9标签，继续查看tag列表，发现列表中不存在vlan 9标签，将数据丢弃</p>
<p><img src="/2023/12/05/Hybrid%E6%8E%A5%E5%8F%A3/fataf2133722.png" alt="fataf2133722"></p>
<h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p><img src="/2023/12/05/Hybrid%E6%8E%A5%E5%8F%A3/tuo2205133307.png" alt="tuo2205133307"></p>
<p>1、为了让我们更加简洁的理解hydrid的属性，首先在所有的端口上移除了vlan1这个默认有的vlan，假设为所有端口初始不属于任何vlan，都不能相互之间通信</p>
<p>2、pvid是当普通的主机数据帧进入交换机端口后被打上的vlan-tag的属性，在途中可以看出PC1、PC2、PC3的流量在进入交换机的时候分别会被打上vlan2、vlan3、vlan99的vlan标签</p>
<p>3、untag后面的vlan就是该端口属于的vlan，那么不难看出LSW1的G0&#x2F;0&#x2F;1属于vlan2、3，G0&#x2F;0&#x2F;2属于vlan2、10，G0&#x2F;0&#x2F;3属于vlan3、10，而untag的动作是在流量出端口去往主机的时候把vlan-tag全部去除，那么不难看出LSW1的G0&#x2F;0&#x2F;1将去除vlan2、3的标签，G0&#x2F;0&#x2F;2去除vlan2、10的标签，G0&#x2F;0&#x2F;3去除vlan3、10的标签（还原成普通帧）</p>
<p>LSW2的G0&#x2F;0&#x2F;1属于vlan99，G0&#x2F;0&#x2F;2属于vlan99，在流量出端口的时候会去除vlan99的标签（还原成普通帧）</p>
<p>那么PC1与PC2的通信现在分析如下：当PC1发送arp去请求PC2的MAC地址的时候，PC1会将数据包广播发往LSW1的G0&#x2F;0&#x2F;2接口，LSW1收到后发现是个普通的不带标签的数据帧，于是根据接口的pvid给该帧打上vlan2的tag，然后往vlan2中进行泛红，无奈G0&#x2F;0&#x2F;3端口只属于vlan3、10所以无法收到vlan2中的泛红，故PC1与PC2通信失败。</p>
<p>下面再来分析PC1与PC3通信：前面已经分析了PC1要去请求PC3的MAC，被LSW1的G0&#x2F;0&#x2F;2收到，并且打上vlan2的tag，然后在vlan2中泛红，那么在vlan2中的端口就都能收到该泛红了，所以在配置了untag vlan 2 3的G0&#x2F;0&#x2F;1端口自然也能收到vlan2和vlan3的泛红并转发出去，但是LSW1发现G0&#x2F;0&#x2F;1配置untag vlan2 3，所以将从该端口发送出去的所有带有vlan2和vlan3的数据包的tag全部去除（还原成普通帧），然后这个普通的帧就会发往LSW2被G0&#x2F;0&#x2F;1端口接收到，LSW2发现了一个普通的帧，那么就会用到pvid了不是，所以LSW2收到这个帧后打上vlan99的tag进行泛红，那么PC3所在的hybrid因为配置有untag vlan99必然能够收到vlan99的数据包了，然后在G0&#x2F;0&#x2F;2发给PC3的时候将vlan99的tag去除掉，PC3收到的就是一个不带任何tag的普通包（PC3完全不知道在它个PC1之间还有SW这种东西存在），好了PC3收到了PC1发来的arp请求，那么作为有礼貌的人应该回复自己的MAC地址了，与回一个arp响应给PC1，</p>
<p>下面PC3的回包分析：PC3使用PC1的MAC和ip封装好数据包后从网卡发送出去，LSW2的G0&#x2F;0&#x2F;2端口收到了，发现是一个普通帧，OK来pvid打上vlan99的tag，然后查看mac地址表发现PC1的MAC地址在G0&#x2F;0&#x2F;1口，在查看vlan信息，发现G0&#x2F;0&#x2F;1口可以接收vlan99的数据（untag vlan99），两个转发条件都满足了，那么久把数据包发给G0&#x2F;0&#x2F;1转发，G0&#x2F;0&#x2F;1转发的时候根据untag vlan99把数据包vlan-id去除还原成普通帧，被LSW1的G0&#x2F;0&#x2F;1收到，按照pvid的惯例，普通帧被打上了pvid vlan10的tag（用vlan10举例，也可以是任意vlan），然后LSW1根据MAC地址表找到PC1在自己的G0&#x2F;0&#x2F;2口，再查看vlan信息发现G0&#x2F;0&#x2F;2接口配置了untag vlan2 10，可以接收vlan10的数据包，于是就把这个被打上vlan10的PC3发来的arp响应通过G0&#x2F;0&#x2F;2发送给了PC1，当然在从G0&#x2F;0&#x2F;2接口出去的时候根据untag vlan2 10的配置将vlan10的tag去除还原成一个普通的帧，PC1收到的是一个普通的帧，完全不知道它和PC3之间还有交换机这个东西。好了，这就是一次通信过程，PC2与PC3的通信原理也是一样的，于是就实现了PC3与PC1、PC2互通，PC1与PC2之间不通的效果。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>hybrid</tag>
        <tag>tag</tag>
      </tags>
  </entry>
  <entry>
    <title>Hub-Spoke组网</title>
    <url>/2024/08/19/Hub-Spoke%E7%BB%84%E7%BD%91/</url>
    <content><![CDATA[<p><img src="/2024/08/19/Hub-Spoke%E7%BB%84%E7%BD%91/QQ%E6%88%AA%E5%9B%BE20240819201731.png" alt="QQ截图20240819201731"></p>
<p><img src="/2024/08/19/Hub-Spoke%E7%BB%84%E7%BD%91/QQ%E6%88%AA%E5%9B%BE20240819201810.png" alt="QQ截图20240819201810"></p>
<p><img src="/2024/08/19/Hub-Spoke%E7%BB%84%E7%BD%91/QQ%E6%88%AA%E5%9B%BE20240819202243.png" alt="QQ截图20240819202243"></p>
<p>拓扑图如上图，R3，R4，R5之间运行ospf（都是进程1），并建立mpls，R1和R3运行ospf（R3ospf2在vpn实例aa中），R2和R3运行isis（R3的isis在VPN实例bb中）。</p>
<p>粗略记录主要步骤：</p>
<h2 id="R1"><a href="#R1" class="headerlink" title="R1"></a>R1</h2><p>interface GigabitEthernet0&#x2F;0&#x2F;0<br> ip address 10.0.13.1 255.255.255.0</p>
<p>ospf 1<br> area 0.0.0.0<br>  network 10.0.13.0 0.0.0.255<br>  network 1.1.1.1 0.0.0.0</p>
<h2 id="R2"><a href="#R2" class="headerlink" title="R2"></a>R2</h2><p>isis 1<br> is-level level-2<br> network-entity 49.0000.0000.0002.00</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;0<br> ip address 10.0.23.2 255.255.255.0<br> isis enable 1</p>
<p>interface LoopBack0<br> ip address 2.2.2.2 255.255.255.255<br> isis enable 1</p>
<p>运营商骨干网ospf建立，建立mpls，R3，R5建立ibgp（开启vpnv4功能）：略</p>
<h2 id="R3"><a href="#R3" class="headerlink" title="R3"></a>R3</h2><p><strong>创建vpn实例aa：</strong></p>
<p>ip vpn-instance aa<br> ipv4-family<br>  route-distinguisher 100:1<br>  vpn-target 200:1 export-extcommunity<br>  vpn-target 100:1 import-extcommunity</p>
<p><strong>创建vpn实例bb：</strong></p>
<p>ip vpn-instance bb<br> ipv4-family<br>  route-distinguisher 100:2<br>  vpn-target 200:2 export-extcommunity<br>  vpn-target 100:1 import-extcommunity</p>
<p><strong>在实例bb建立isis，并引入bgp路由：</strong></p>
<p>isis 1 vpn-instance bb<br> is-level level-2<br> network-entity 49.0000.0000.0003.00<br> import-route bgp<br>#<br>interface GigabitEthernet0&#x2F;0&#x2F;0<br> ip binding vpn-instance aa<br> ip address 10.0.13.3 255.255.255.0<br>#<br>interface GigabitEthernet0&#x2F;0&#x2F;1<br> ip binding vpn-instance bb<br> ip address 10.0.23.3 255.255.255.0<br> isis enable 1</p>
<p><strong>bgp引入ospf2</strong></p>
<p>bgp100</p>
<p> ipv4-family vpn-instance aa<br>  import-route ospf 2</p>
<p><strong>bgp引入isis</strong></p>
<p>bgp100</p>
<p> ipv4-family vpn-instance bb<br>  import-route isis 1</p>
<p><strong>ospf 2 引入bgp</strong><br>ospf 2 vpn-instance aa<br> import-route bgp</p>
<h2 id="R5"><a href="#R5" class="headerlink" title="R5"></a>R5</h2><p><strong>创建两个vpn实例vpnin（只有import RT），vpnout（只有export RT）</strong></p>
<p>ip vpn-instance vpnin<br> ipv4-family<br>  route-distinguisher 100:60<br>  vpn-target 200:1 200:2 import-extcommunity（两个入的，匹配R1和R2的出）<br>#</p>
<p>ip vpn-instance vpnout<br> ipv4-family<br>  route-distinguisher 100:6060<br>  vpn-target 100:1 export-extcommunity（一个出，匹配R1和R2的入）</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1（物理口绑定了出的vpnout实例）<br> ip binding vpn-instance vpnout<br> ip address 10.0.56.5 255.255.255.0<br>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1.1（创建子接口绑定vpnin实例）<br> dot1q termination vid 10<br> ip binding vpn-instance vpnin<br> ip address 10.0.65.5 255.255.255.0<br> arp broadcast enable</p>
<p><strong>与R6建立ebgp（两个实例中）</strong></p>
<p> ipv4-family vpn-instance vpnin<br>  peer 10.0.65.6 as-number 200<br> #<br> ipv4-family vpn-instance vpnout<br>  peer 10.0.56.6 as-number 200<br>  peer 10.0.56.6 allow-as-loop 2（必须有这一条，运行带本地as号通过，不然R5发给R6带as100，R6出去再发给R5带as100不给过）</p>
<h2 id="R6"><a href="#R6" class="headerlink" title="R6"></a>R6</h2><p>interface GigabitEthernet0&#x2F;0&#x2F;1<br> ip address 10.0.56.6 255.255.255.0</p>
<p><strong>创建子接口</strong></p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1.1<br> dot1q termination vid 10<br> ip address 10.0.65.6 255.255.255.0<br> arp broadcast enable</p>
<p>interface LoopBack0<br> ip address 6.6.6.6 255.255.255.255</p>
<p><strong>与R5建立ebgp</strong></p>
<p>bgp 200<br> peer 10.0.56.5 as-number 100<br> peer 10.0.65.5 as-number 100</p>
<p>通告6.6.6.6</p>
<p>bgp200</p>
<p>  network 6.6.6.6 255.255.255.255</p>
<p>此时都能学习到所有路由，R1pingR2能通（经过R5-R6中转）</p>
<p><img src="/2024/08/19/Hub-Spoke%E7%BB%84%E7%BD%91/QQ%E6%88%AA%E5%9B%BE20240819205645.png" alt="QQ截图20240819205645"></p>
<p>在R5的出口抓包</p>
<p>R1pingR2能抓到icmp的包</p>
<p>以上实验Hub PE和Hub CE之间用的是bgp，也可以采用ospf，要创建两个ospf进程，分别绑定vpnin和vpnout，两个进程的两端宣告用不同的区域，在PE上把bgp引入vpnin的ospf实例中，在CE上把入方向的ospf引入出方向的ospf，在PE上把出方向的ospf引入bgp</p>
<p><img src="/2024/08/19/Hub-Spoke%E7%BB%84%E7%BD%91/QQ%E6%88%AA%E5%9B%BE20240819210026.png" alt="QQ截图20240819210026"></p>
<p><img src="/2024/08/19/Hub-Spoke%E7%BB%84%E7%BD%91/QQ%E6%88%AA%E5%9B%BE20240819210122.png" alt="QQ截图20240819210122"></p>
<p>R5</p>
<p><strong>创建两个vpn</strong></p>
<p>ip vpn-instance vpnin<br> ipv4-family<br>  route-distinguisher 100:60<br>  vpn-target 200:1 200:2 export-extcommunity<br>  vpn-target 200:1 200:2 import-extcommunity<br>#<br>ip vpn-instance vpnout<br> ipv4-family<br>  route-distinguisher 100:6060<br>  vpn-target 100:1 export-extcommunity</p>
<p><strong>子接口和物理接口分别绑定两个vpn实例</strong></p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1<br> ip binding vpn-instance vpnout<br> ip address 10.0.56.5 255.255.255.0 </p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1.1<br> dot1q termination vid 10<br> ip binding vpn-instance vpnin<br> ip address 10.0.65.5 255.255.255.0<br> arp broadcast enable</p>
<p><strong>在vpn实例中创ospf两个进程</strong></p>
<p> ipv4-family vpn-instance vpnout<br>  import-route ospf 200</p>
<p>ospf 100 vpn-instance vpnin（vpnin在ospf 100进程，用area 0）<br> import-route bgp<br> area 0.0.0.0<br>  network 10.0.65.0 0.0.0.255 </p>
<p>ospf 200 vpn-instance vpnout（vpnout在ospf 200进程，用area 1）<br> area 0.0.0.1<br>  network 10.0.56.0 0.0.0.255</p>
<p>ipv4-family vpn-instance vpnout<br>  import-route ospf 200</p>
<p>R6</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1.1<br> dot1q termination vid 10<br> ip address 10.0.65.6 255.255.255.0<br> arp broadcast enable</p>
<p>ospf 100<br> area 0.0.0.0<br>  network 10.0.65.0 0.0.0.255 </p>
<p>ospf 200<br> import-route ospf 100<br> area 0.0.0.1<br>  network 10.0.56.0 0.0.0.255 </p>
]]></content>
      <categories>
        <category>ie实验</category>
      </categories>
      <tags>
        <tag>Hub&amp;Spoke</tag>
        <tag>RT</tag>
      </tags>
  </entry>
  <entry>
    <title>IA综合实验</title>
    <url>/2024/06/21/IA%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<img src="/2024/06/21/IA%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/QQ截图20240621210447.png" alt="QQ截图20240621210447" style="zoom:80%;">

<p>如图所示为某园区网络简易拓扑，LSW1,LSW2作为汇聚层交换机，AR1作为核心路由器，LSW3-4作为<br>各自楼层的接入交换机，现按照要求实现如下配置：</p>
<p>一.IP地址规划<br>   1.办公楼1所有PC的网段为：192.168.10.0&#x2F;24  网关地址为：192.168.10.254<br>   2.办公楼2所有PC的网段为：192.168.20.0&#x2F;24  网关地址为：192.168.20.254<br>   3.服务器区所有PC的网段为：192.168.30.0&#x2F;24  网关地址为：192.168.30.254<br>   4.LSW1作为汇聚层交换机使用INT VLANIF 100接口与R1互连，IP地址为100.1.1.1&#x2F;24；<br>     R1与LSW1互连接口的IP地址为100.1.1.2&#x2F;24<br>   5.R1与R2接口,R1接口IP地址为：200.1.1.1&#x2F;24,R2接口IP地址为：200.1.1.2&#x2F;24,<br>   6.配置设备的名称</p>
<p>二.配置LSW1与LSW2汇聚交换机之间的链路聚合，采用LACP的方式，活动链路2条<br>   要求G0&#x2F;0&#x2F;3端口down掉之后，数据走G0&#x2F;0&#x2F;2转发。</p>
<p>三.配置交换机之间的生成树<br>    1.要求所有运行RSTP<br>    2.LSW1作为主根桥，LSW2作为备份根桥<br>    3.配置边缘端口，让所有的终端接入到网络中，能立即转发数据<br>四.配置交换机的链路类型以及VLAN<br>    1.在交换机上创建拓扑图中所存在的VLAN<br>    2.配置交换机与PC与路由器的链路类型为access链路，然后将接口划分进相应的VLAN；<br>      办公楼1为VLAN 10<br>      办公楼2为VLAN 20<br>      服务器区为VLAN 30<br>      LSW1与连接R1的接口VLAN 100<br>    3.配置交换机与交换机互连的链路的trunk，并且允许相应的VLAN通过</p>
<p>五.在汇聚交换机LSW1配置相应的VLANIF接口，使不同楼层的PC能实现通讯</p>
<p>六.DHCP配置:<br>     在LSW1上配置全局地址池1：<br>     地址池pool10分配地址段为192.168.10.0&#x2F;24,网关为192.168.10.254,DNS为114.114.114.114，<br>        为VLAN10的主机分配IP地址；<br>     在LSW2上配置全局地址池2：<br>     地址池pool20分配地址段为192.168.20.0&#x2F;24,网关为192.168.20.254,DNS为8.8.8.8<br>        为VLAN20的主机分配IP地址。<br>七.路由协议<br>1.在核心路由器AR1和汇聚交换机LSW1上配置动态路由协议ospf，使R1能学到教学楼和服务器区网段的路由<br> 配置完成之后，测试R1是否访问到每台PC上<br>2.在核心路由器AR1配置一跳静态默认路由指向ISP的路由器AR2</p>
<p>八.NAT技术<br>   1、在AR1上使用NAT技术，使内网VLAN10，VLAN20的网段访问外网时，转化的地址为AR1 g0&#x2F;0&#x2F;1接口的IP地址。<br>     （通过easy ip技术实现）</p>
<p><strong>LSW3-1</strong></p>
<p><Huawei>sys</Huawei></p>
<p>[Huawei]sysn lsw3-1</p>
<p>[lsw3-1]v b 10 20</p>
<p>Info: This operation may take a few seconds. Please wait for a</p>
<p>moment…done.</p>
<p>[lsw3-1]int e0&#x2F;0&#x2F;3</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;3]p l a</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;3]p d v 10</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;3]int e0&#x2F;0&#x2F;4</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;4]p l a[lsw3-1-Ethernet0&#x2F;0&#x2F;4]p d v 10</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;4]int e0&#x2F;0&#x2F;1</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;1]p l t</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;1]p t a v 10 20</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;1]int e0&#x2F;0&#x2F;2</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;2]p l t</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;2]p t a v 10 20</p>
<p>[lsw3-1]stp mode r</p>
<p>[lsw3-1]int e0&#x2F;0&#x2F;3</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;3]stp edged-port enable &#x2F;&#x2F;设置边缘端口便于快速收</p>
<p>敛</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;3]int e0&#x2F;0&#x2F;4</p>
<p>[lsw3-1-Ethernet0&#x2F;0&#x2F;4]stp edged-port enable</p>
<p><strong>LSW4</strong></p>
<p><Huawei>sys</Huawei></p>
<p>Enter system view, return user view with Ctrl+Z.</p>
<p>[Huawei]sysn LSW4-1</p>
<p>[LSW4-1]v b 20</p>
<p>[LSW4-1]int e0&#x2F;0&#x2F;4</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;4]p l a</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;4]p d v 20</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;4]int e0&#x2F;0&#x2F;5</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;5]p l a</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;5]p d v 20</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;5]int e0&#x2F;0&#x2F;1</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;1]p l t</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;1]p t a v 10 20</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;1]int e0&#x2F;0&#x2F;2</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;2]p l t</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;2]p t a v 10 20</p>
<p>[LSW4-1]stp mode r</p>
<p>[LSW4-1]int e0&#x2F;0&#x2F;4</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;4]stp edged-port enable</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;4]int e0&#x2F;0&#x2F;5[LSW4-1-Ethernet0&#x2F;0&#x2F;5]stp ed e</p>
<p>[LSW4-1]int e0&#x2F;0&#x2F;1</p>
<p>[LSW4-1-Ethernet0&#x2F;0&#x2F;1]stp cost 300000 &#x2F;&#x2F;修改端口cost来使到达网关最优</p>
<p><strong>LSW1</strong></p>
<p>[LSW1]v b 10 20 12 100 30</p>
<p>[LSW1]int g0&#x2F;0&#x2F;4</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;4]p l t</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;4]p t a v 10 20</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;4]int g0&#x2F;0&#x2F;5</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;5]p l t</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;5]p t a v 10 20</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;5]q</p>
<p>[LSW1]int Eth-Trunk 1</p>
<p>[LSW1-Eth-Trunk1]mode lacp-static</p>
<p>[LSW1-Eth-Trunk1]max active-linknumber 2 &#x2F;&#x2F;设置聚合最大数量为2</p>
<p>[LSW1-Eth-Trunk1]trunkport g 0&#x2F;0&#x2F;1 0&#x2F;0&#x2F;2 0&#x2F;0&#x2F;3</p>
<p>[LSW1-Eth-Trunk1]p l t</p>
<p>[LSW1-Eth-Trunk1]p t a v 10 20 30 12</p>
<p>[LSW1-Eth-Trunk1]shutdown</p>
<p>[LSW1-Eth-Trunk1]undo shutdown</p>
<p>[LSW1-Eth-Trunk1]q</p>
<p>[LSW1]int g0&#x2F;0&#x2F;6</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;6]p l a</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;6]p d v 100</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;6]int g0&#x2F;0&#x2F;7</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;7]p l a</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;7]p d v 30</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;7]int g0&#x2F;0&#x2F;8</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;8]p l a</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;8]p d v 30</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;8]q</p>
<p>[LSW1]stp mode rstp</p>
<p>[LSW1]stp root primary</p>
<p>[LSW1]int g0&#x2F;0&#x2F;7[LSW1-GigabitEthernet0&#x2F;0&#x2F;7]stp ed e</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;7]int g0&#x2F;0&#x2F;8</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;8]stp ed e</p>
<p>[LSW1-GigabitEthernet0&#x2F;0&#x2F;8]q</p>
<p>[LSW1]int v 10</p>
<p>[LSW1-Vlanif10]ip add 192.168.10.254 24</p>
<p>[LSW1-Vlanif10]int v 12</p>
<p>[LSW1-Vlanif12]ip add 10.0.12.1 24</p>
<p>[LSW1-Vlanif12]int v 100</p>
<p>[LSW1-Vlanif100]ip add 100.1.1.1 24</p>
<p>[LSW1-Vlanif100]int v 30</p>
<p>[LSW1-Vlanif30]ip add 192.168.30.254 24</p>
<p>[LSW1-Vlanif30]q</p>
<p>[LSW1]ip pool vlan10</p>
<p>[LSW1-ip-pool-vlan10]network 192.168.10.0 mask 24</p>
<p>[LSW1-ip-pool-vlan10]gateway-list 192.168.10.254</p>
<p>[LSW1-ip-pool-vlan10]dns-list 8.8.8.8</p>
<p>[LSW1-ip-pool-vlan10]q</p>
<p>[LSW1]ip pool vlan30</p>
<p>[LSW1-ip-pool-vlan30]network 192.168.30.0 m 24</p>
<p>[LSW1-ip-pool-vlan30]g 192.168.30.254</p>
<p>[LSW1-ip-pool-vlan30]dns 114.114.114.114</p>
<p>[LSW1-ip-pool-vlan30]q</p>
<p>[LSW1]dhcp enable</p>
<p>[LSW1]int v 10</p>
<p>[LSW1-Vlanif10]dhcp se g</p>
<p>[LSW1-Vlanif10]int v 30</p>
<p>[LSW1-Vlanif30]dhcp s g</p>
<p>[LSW1]ospf</p>
<p>[LSW1-ospf-1]area 0</p>
<p>[LSW1-ospf-1-area-0.0.0.0]network 10.0.12.0 0.0.0.255</p>
<p>[LSW1-ospf-1-area-0.0.0.0]network 100.1.1.1 0.0.0.255</p>
<p>[LSW1-ospf-1-area-0.0.0.0]network 192.168.10.0 0.0.0.255</p>
<p>[LSW1-ospf-1-area-0.0.0.0]network 192.168.30.0 0.0.0.255</p>
<p>[LSW1-ospf-1-area-0.0.0.0]network 192.168.20.0 0.0.0.255<strong>LSW2</strong></p>
<p><Huawei>sys</Huawei></p>
<p>Enter system view, return user view with Ctrl+Z.</p>
<p>[Huawei]v b 12 10 20 40</p>
<p>[Huawei]sysn LSW2</p>
<p>[LSW2]int g0&#x2F;0&#x2F;4</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;4]p l t</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;4]p t a v 10 20</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;4]int g0&#x2F;0&#x2F;5</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;5]p l t</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;5]p t a v 10 20</p>
<p>[LSW2]int Eth-Trunk 1</p>
<p>[LSW2-Eth-Trunk1]mode lacp-static</p>
<p>[LSW2-Eth-Trunk1]max active-linknumber 2</p>
<p>[LSW2-Eth-Trunk1]trunkport g 0&#x2F;0&#x2F;1 0&#x2F;0&#x2F;2 0&#x2F;0&#x2F;3</p>
<p>[LSW2-Eth-Trunk1]q</p>
<p>[LSW2]int g0&#x2F;0&#x2F;2</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;2]lacp priority 32769 &#x2F;&#x2F;设置该端口在聚合时</p>
<p>为备份</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;2]int e 1</p>
<p>[LSW2-Eth-Trunk1]shutdown</p>
<p>[LSW2-Eth-Trunk1]undo shutdown &#x2F;&#x2F;非抢占 所以需要重启</p>
<p>[LSW2-Eth-Trunk1]p l t</p>
<p>[LSW2-Eth-Trunk1]p t a v 12 10 20</p>
<p>[LSW2-Eth-Trunk1]q</p>
<p>[LSW2]stp mode rs</p>
<p>[LSW2]stp root secondary</p>
<p>[LSW2]ip pool vlan20</p>
<p>[LSW2-ip-pool-vlan20]network 192.168.20.0 m 24</p>
<p>[LSW2-ip-pool-vlan20]g 192.168.20.254</p>
<p>[LSW2-ip-pool-vlan20]q</p>
<p>[LSW2]dhcp enable</p>
<p>[LSW2]int v 20</p>
<p>[LSW2-Vlanif20]ip add 192.168.20.254 24</p>
<p>[LSW2-Vlanif20]q[LSW2-Vlanif20]dhcp se g</p>
<p>[LSW2-Vlanif20]int v 12</p>
<p>[LSW2-Vlanif12]ip add 10.0.12.2 24</p>
<p>[LSW2-Vlanif12]q</p>
<p>-–</p>
<p>接下来为ac这部分配置</p>
<p>[LSW2]int g0&#x2F;0&#x2F;7</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;7]p l t</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;7]p t a v 40 50</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;7]int g0&#x2F;0&#x2F;6</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;6]p l t</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;6]p t a v 40 50 10 20 12</p>
<p>[LSW2-GigabitEthernet0&#x2F;0&#x2F;6]p t p v 40</p>
<p>[LSW2]ospf</p>
<p>[LSW2-ospf-1]area 0</p>
<p>[LSW2-ospf-1-area-0.0.0.0]network 192.168.20.0 0.0.0.255</p>
<p>[LSW2-ospf-1-area-0.0.0.0]network 10.0.12.0 0.0.0.255</p>
<p><strong>AC</strong></p>
<p><AC6005>sys</AC6005></p>
<p>Enter system view, return user view with Ctrl+Z.</p>
<p>[AC6005]sysn AC</p>
<p>[AC]int g0&#x2F;0&#x2F;1</p>
<p>[AC-GigabitEthernet0&#x2F;0&#x2F;1]q</p>
<p>[AC]v b 40 50</p>
<p>[AC]int g0&#x2F;0&#x2F;1</p>
<p>[AC-GigabitEthernet0&#x2F;0&#x2F;1]p l t</p>
<p>[AC-GigabitEthernet0&#x2F;0&#x2F;1]p t a v 40 50</p>
<p>[AC-GigabitEthernet0&#x2F;0&#x2F;1]q</p>
<p>[AC]int v 40</p>
<p>[AC-Vlanif40]ip add 192.168.40.254 24</p>
<p>[AC-ip-pool-vlan40]int v 50</p>
<p>[AC-Vlanif50]ip add 192.168.50.254 24</p>
<p>[AC-Vlanif50]int v 1</p>
<p>[AC-Vlanif1]ip add 10.0.11.2 24 &#x2F;&#x2F; 与ar1 通信[AC-Vlanif1]q</p>
<p>[AC]ip pool vlan40</p>
<p>[AC-ip-pool-vlan40]network 192.168.40.0 m 24</p>
<p>[AC-ip-pool-vlan40]g 192.168.40.254</p>
<p>[AC-ip-pool-vlan40]q</p>
<p>[AC]ip pool vlan50</p>
<p>[AC-ip-pool-vlan50]network 192.168.50.0 m 24</p>
<p>[AC-ip-pool-vlan50]g 192.168.50.254</p>
<p>[AC-ip-pool-vlan50]q</p>
<p>[AC-wlan-view]int v 40</p>
<p>[AC-Vlanif40]dhcp select g</p>
<p>[AC-Vlanif40]int v 50</p>
<p>[AC-Vlanif50]dhcp select global</p>
<p>[AC]capwap source interface Vlanif 40</p>
<p>[AC]wlan</p>
<p>[AC-wlan-view]ssid-profile name HCIA-WLAN</p>
<p>[AC-wlan-ssid-prof-HCIA-WLAN]ssid HCIA-WLAN</p>
<p>[AC-wlan-ssid-prof-HCIA-WLAN]q</p>
<p>[AC-wlan-view]security-profile name HCIA-WLAN</p>
<p>[AC-wlan-sec-prof-HCIA-WLAN]security wpa-wpa2 psk pass-phrase HCIA</p>
<p>Datacom aes</p>
<p>[AC-wlan-sec-prof-HCIA-WLAN]q</p>
<p>[AC-wlan-view]vap-profile name HCIA-WLAN</p>
<p>[AC-wlan-vap-prof-HCIA-WLAN]ssid-profile HCIA-WLAN</p>
<p>[AC-wlan-vap-prof-HCIA-WLAN]security-profile HCIA-WLAN</p>
<p>[AC-wlan-vap-prof-HCIA-WLAN]service-vlan vlan-id 50</p>
<p>[AC-wlan-vap-prof-HCIA-WLAN]forward-mode direct-forward</p>
<p>[AC-wlan-view]ap-group name ap-group1</p>
<p>[AC-wlan-ap-group-ap-group1]vap-profile HCIA-WLAN wlan 1 radio all</p>
<p>[AC-wlan-ap-group-ap-group1]q</p>
<p>[AC-wlan-view]ap-id 1 ap-mac 00E0-FC27-2F80</p>
<p>[AC-wlan-ap-1]ap-group ap-group1</p>
<p>[AC]ospf</p>
<p>[AC-ospf-1]area 0</p>
<p>[AC-ospf-1-area-0.0.0.0]network 10.0.11.0 0.0.0.255</p>
<p>[AC-ospf-1-area-0.0.0.0]network 192.168.50.0 0.0.0.255<strong>AR1</strong></p>
<p>[ar1]int g0&#x2F;0&#x2F;0</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;0]ip add 100.1.1.2 24</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;0]int g0&#x2F;0&#x2F;1</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;1]ip add 200.1.1.1 24</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;1]int g0&#x2F;0&#x2F;2</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;2]ip add 10.0.11.1 24</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;2]q</p>
<p>[ar1]ip route-static 0.0.0.0 0 200.1.1.2</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;2]ospf</p>
<p>[ar1-ospf-1]area 0</p>
<p>[ar1-ospf-1-area-0.0.0.0]network 100.1.1.0 0.0.0.255</p>
<p>[ar1-ospf-1-area-0.0.0.0]network 10.0.11.1 0.0.0.255</p>
<p>[ar1-ospf-1]default-route-advertise always</p>
<p>[ar1]acl 2000</p>
<p>[ar1-acl-basic-2000]rule permit source 192.168.10.0 0.0.0.255</p>
<p>[ar1-acl-basic-2000]rule permit source 192.168.20.0 0.0.0.255</p>
<p>[ar1-acl-basic-2000]rule permit source 192.168.50.0 0.0.0.255</p>
<p>ar1]int g0&#x2F;0&#x2F;1</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;1]nat outbound 2000</p>
<p>此时依然可以全部进行通信这是因为走默认路径可以直接出去 而且对端会回包</p>
<p>[ar1]acl 2001</p>
<p>[ar1-acl-basic-2001]rule permit source 192.168.10.0 0.0.0.255</p>
<p>[ar1-acl-basic-2001]rule permit source 192.168.20.0 0.0.0.255</p>
<p>rule deny source 0.0.0.0 255.255.255.255</p>
<p>[ar1-acl-basic-2001]q</p>
<p>[ar1]int g0&#x2F;0&#x2F;0</p>
<p>[ar1-GigabitEthernet0&#x2F;0&#x2F;1]traffic-filter inbound acl 2001</p>
<p><strong>AR2</strong></p>
<p>添加默认回程路由</p>
<p>[AR2]ip route-static 0.0.0.0 0 200.1.1.1</p>
<p>测试环回口[AR2]int LoopBack 0</p>
<p>[AR2-LoopBack0]ip add 2.2.2.2 24</p>
]]></content>
      <categories>
        <category>综合实验</category>
      </categories>
  </entry>
  <entry>
    <title>IGP高级特性</title>
    <url>/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="OSPF快速收敛"><a href="#OSPF快速收敛" class="headerlink" title="OSPF快速收敛"></a>OSPF快速收敛</h1><h2 id="PRC"><a href="#PRC" class="headerlink" title="PRC"></a>PRC</h2><img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809161634.png" alt="QQ截图20240809161634" style="zoom:67%;">

<h2 id="智能定时器"><a href="#智能定时器" class="headerlink" title="智能定时器"></a>智能定时器</h2><img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809162021.png" alt="QQ截图20240809162021" style="zoom:67%;">

<p><img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240809162324.png" alt="QQ截图20240809162324"></p>
<h2 id="OSPF-IP-FRR"><a href="#OSPF-IP-FRR" class="headerlink" title="OSPF IP FRR"></a>OSPF IP FRR</h2><p>OSPF IP FRR是动态IP FRR，利用<strong>LFA</strong>（Loop-Free Alternates）算法预先计算出备份路径，保存在转发表中，以备在故障时将流量快速切换到备份链路上，保证流量不中断，从而达到流量保护的目的，该功能可将故障恢复时间降低到50 ms以内。</p>
<p>LFA计算备份链路的基本思路是：以可提供备份链路的邻居为根节点，利用SPF算法计算出到目的节点的最短距离。然后，按照不等式计算出开销最小且无环的备份链路</p>
<img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809162757.png" alt="QQ截图20240809162757" style="zoom:67%;">

<img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809163017.png" alt="QQ截图20240809163017" style="zoom:67%;">

<h2 id="ospf与bfd联动"><a href="#ospf与bfd联动" class="headerlink" title="ospf与bfd联动"></a>ospf与bfd联动</h2><img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809163502.png" alt="QQ截图20240809163502" style="zoom:67%;">

<h2 id="等价路由"><a href="#等价路由" class="headerlink" title="等价路由"></a>等价路由</h2><p>当路由表中存在到达同一目的地址，且<strong>同一路由协议</strong>发现的多条路由时，若这几条路由的<strong>开销值也相同</strong>，那么这些路由就是等价路由，可以实现负载分担。</p>
<p>设备将按照负载分担的方式从多条等价路由发送报文到同一目的地址。     </p>
<p>设置进行负载分担的等价路由的最大数量：</p>
<p>[Huawei-ospf-1] maximum load-balancing number</p>
<img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809163956.png" alt="QQ截图20240809163956" style="zoom:67%;">

<h2 id="缺省路由"><a href="#缺省路由" class="headerlink" title="缺省路由"></a>缺省路由</h2><img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809164431.png" alt="QQ截图20240809164431" style="zoom:67%;">

<p>通告：</p>
<img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809164812.png" alt="QQ截图20240809164812" style="zoom:67%;">

<h2 id="过滤LSA"><a href="#过滤LSA" class="headerlink" title="过滤LSA"></a>过滤LSA</h2><img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809165622.png" alt="QQ截图20240809165622" style="zoom:67%;">

<img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809165629.png" alt="QQ截图20240809165629" style="zoom:67%;">

<img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809195947.png" alt="QQ截图20240809195947" style="zoom:67%;">

<img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809195954.png" alt="QQ截图20240809195954" style="zoom:67%;">

<img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809200001.png" alt="QQ截图20240809200001" style="zoom:67%;">

<img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240809200006.png" alt="QQ截图20240809200006" style="zoom:67%;">

<h2 id="ospf与bgp联动"><a href="#ospf与bgp联动" class="headerlink" title="ospf与bgp联动"></a>ospf与bgp联动</h2><p>当有新的设备加入到网络中，或者设备重启时，可能会出现在BGP收敛期间内网络流量丢失的现象。这是IGP收敛速度比BGP快造成的。<img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240809200417.png" alt="QQ截图20240809200417"></p>
<h2 id="FA"><a href="#FA" class="headerlink" title="FA"></a>FA</h2><p>FA（Forwarding Address，转发地址）：到达所通告的目的地的数据包应该被转发到的地址，如果转发地址为0.0.0.0，那么数据包将被转发到始发<strong>ASBR</strong>上。</p>
<p>OSPF的Type5 LSA和Type7 LSA中包含一个特别的字段FA，FA的引入使得OSPF在某些特殊的场景下可以避免次优路径问题。</p>
<p><img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240809200658.png" alt="QQ截图20240809200658"></p>
<p>当ASBR引入外部路由时，若Type5 LSA中的FA字段为0，表示路由器认为到达目的网段的数据包应该发往该ASBR；</p>
<p>若Type5 LSA中的FA字段不为0，表示路由器认为到达目的网段的数据包应该发往这个FA所标识的设备。</p>
<p>当以下条件全部满足时，FA字段才可以被设置为非0：</p>
<p>ASBR在其连接外部网络的接口（外部路由的出接口）上激活了OSPF；</p>
<p>该接口没有被配置为Silent-Interface；该接口的OSPF网络类型为Broadcast或NBMA；</p>
<p>该接口的IP地址在OSPF配置的network命令指定的网段范围内；</p>
<p>到达FA地址的路由必须是OSPF区域内部路由或区域间路由，这样接收到该外部LSA的路由器才能够加载该LSA进入路由表。加载的外部LSA生成的路由条目下一跳与到达FA地址的下一跳相同。</p>
<p>NSSA区域Type7 LSA转化为Type5 LSA：<br>缺省情况下，转换路由器是NSSA区域<strong>中Router ID最大的区域边界路由器（ABR）</strong>。<br>LSA头部Options字段中的P-bit（Propagate bit）用于告知转化路由器该条Type7 LSA是否需要转化为Type5 LSA。<strong>只有P-bit置位并且FA不为0的Type7 LSA才能转化为Type5 LSA。</strong><br>区域边界路由器产生的Type7 LSA缺省路由不会置位P-bit。<br>注意：所有的OSPF LSA有相同的LSA头部，P-bit在LSA头部中的Options字段。</p>
<h2 id="GR"><a href="#GR" class="headerlink" title="GR"></a>GR</h2><p>GR（Graceful Restart，平滑重启）技术保证了设备在重启过程中转发层面能够继续指导数据的转发，同时控制层面邻居关系的重建以及路由计算等动作不会影响转发层面的功能，从而避免了路由振荡引发的业务中断，保证了关键业务的数据转发，提高了整网的可靠性。</p>
<h1 id="ISIS高级特性"><a href="#ISIS高级特性" class="headerlink" title="ISIS高级特性"></a>ISIS高级特性</h1><h2 id="I-SPF"><a href="#I-SPF" class="headerlink" title="I-SPF"></a>I-SPF</h2><p>I-SPF的工作原理：当网络拓扑改变的时候，只对<strong>受影响的节点</strong>进行路由计算，而不是对全部节点重新进行路由计算，从而加快了路由的计算。</p>
<p>使用SPF算法进行路由计算：当网络拓扑中有一个节点发生变化时，SPF算法需要重新计算网络中的所有节点，计算时间长，占用过多的CPU资源，影响整个网络的收敛速度。</p>
<p>I-SPF改进了SPF算法，除了第一次SPF计算时需要计算全部节点外，之后每次都通过I-SPF计算受到影响的节点，而最后生成的最短路径树与原来的算法所计算的结果相同，大大降低了CPU的占用率，提高了网络收敛速度。</p>
<p><strong>在IS-IS网络中，I-SPF和PRC结合使用。</strong></p>
<p>如果I-SPF计算后的最短路径树改变，PRC会只处理那个<strong>变化的节点上</strong>的所有叶子（路由）。如果经过I-SPF计算后的最短路径树并没有变化，则PRC只处理变化的叶子信息。比如一个节点使能一个IS-IS接口，则整个网络拓扑的最短路径树是不变的，这时PRC只更新这个节点的接口路由，从而节省CPU占用率。</p>
<p><img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240812185722.png" alt="QQ截图20240812185722"></p>
<p>（注意区分PRC，I-SPF是计算变化的节点，PRC计算变化的路由）</p>
<h2 id="LSP快速扩散"><a href="#LSP快速扩散" class="headerlink" title="LSP快速扩散"></a>LSP快速扩散</h2><p>LSP快速扩散：此特性可以加快LSP的扩散速度。</p>
<p>正常情况下，当IS-IS路由器收到其它路由器发来的LSP时，如果此LSP比本地LSDB中相应的LSP要新，则更新LSDB中的LSP，并用一个定时器定期将LSDB内已更新的LSP扩散出去。</p>
<p>LSP快速扩散特性改进了这种方式，使能了此特性的设备收到一个或多个较新的LSP时，在路由计算之前，<strong>先将小于指定数目的LSP扩散出去，</strong>加快LSDB的同步过程。这种方式在很大程度上可以提高整个网络的收敛速度。</p>
<p> 配置LSP快速扩散：</p>
<p>[Huawei-isis-1] flash-flood [ lsp-count | max-timer-interval interval | [ level-1 | level-2 ] ]</p>
<p>注意：用户可以指定每次扩散的LSP数量，这个数量是针对所有IS-IS接口的。如果需要发送的LSP的数量大于这个数，则就发送lsp-count个LSP。如果配置了定时器，在路由计算之前如果这个定时器未超时，则立即扩散；否则在该定时器超时后发送。</p>
<p>lsp-count：指定每个接口一次扩散LSP的最大数量。整数形式，取值范围是1～15。缺省值是5。</p>
<p>max-timer-interval interval：指定LSP扩散的最大间隔时间。整数形式，取值范围是10～50000，单位是毫秒。缺省值是10毫秒。</p>
<p>level-1：表示在Level-1中使能此特性。如果命令中没有指定级别，则缺省同时在Level-1和Level-2中使能此功能。</p>
<p>level-2：表示在Level-2中使能此特性。如果命令中没有指定级别，则缺省同时在Level-1和Level-2中使能此功能。</p>
<h2 id="等价路由-1"><a href="#等价路由-1" class="headerlink" title="等价路由"></a>等价路由</h2><p>当IS-IS网络中有多条冗余链路时，可能会出现多条等价路由，</p>
<p>此时可以采取两种方式：配置负载分担。</p>
<p>流量会被均匀的分配到每条链路上。该方式可以提高网络中链路的利用率及减少某些链路负担过重造成阻塞发生的情况。但是由于对流量转发具有一定的随机性，因此可能不利于对业务流量的管理。</p>
<p>配置等价路由优先级。</p>
<p>针对等价路由中的每一条路由，明确指定其优先级，优先级高的路由将被优选，优先级低的路由可以作为备用链路。当IS-IS网络中有多条冗余链路时，可能会出现多条等价路由，即达到某一目的网段有多条等开销路径。配置等价路由优先级可以在不修改原有配置的基础上，<strong>指定某条路由被优选</strong>，便于业务的管理，同时提高网络的可靠性。注意：配置等价路由优先级后，IS-IS设备在转发到达目的网段的流量时，将不采用负载分担方式，而是将流量转发到优先级最高的下一跳。</p>
<img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240812190929.png" alt="QQ截图20240812190929" style="zoom:67%;">

<h2 id="缺省路由-1"><a href="#缺省路由-1" class="headerlink" title="缺省路由"></a>缺省路由</h2><p>在IS-IS中，主要通过以下3种方式控制缺省路由的生成和发布。</p>
<p>在Level-1-2设备上，控制其产生的Level-1 LSP中ATT位的置位情况。</p>
<p>在Level-1设备上，通过配置使其即使收到ATT位置位的Level-1 LSP也不会自动产生缺省路由。</p>
<p>在IS-IS中发布缺省路由</p>
<p><img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240812191212.png" alt="QQ截图20240812191212"></p>
<p><strong>设置ATT置位控制产生缺省路由</strong>:</p>
<p>IS-IS规定，如果IS-IS Level-1-2设备根据LSDB判断通过Level-2区域比Level-1区域能够到达更多的区域，该设备会在所发布的Level-1 LSP内将ATT位置位。对于收到ATT位置位的LSP报文的Level-1设备，会生成一条目的地为发送该LSP的Level-1-2设备地址的<strong>缺省路由</strong>。</p>
<p>以上是协议的默认原则，在实际应用中，可以根据需要对ATT比特位进行手动配置以更好地为网络服务。</p>
<p><img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240812191438.png" alt="QQ截图20240812191438"></p>
<p>命令：</p>
<p><strong>[Huawei-isis-1] attached-bit advertise { always | never }always：</strong>指定ATT位永远置位，收到该LSP的Level-1设备会生成缺省路由。never：指定ATT位永不置位，可以避免Level-1设备生成缺省路由，减小路由表的规模。</p>
<p>虽然ATT位同时在Level-1 LSP和Level-2 LSP中进行了定义，但是它只会在Level-1 LSP中被置位，并且只有Level-1-2设备会设置这个字段，因此，该命令仅对Level-1-2设备生效。</p>
<p>配置Level-1设备不将缺省路由下发到路由表，有以下两种方式可以实现：</p>
<p>在Level-1-2设备上配置<strong>attached-bit advertise never</strong>命令，使得其不会发布ATT位置位的LSP。</p>
<p>在与Level-1-2设备相连的Level-1设备上配置<strong>attached-bit avoid-learning</strong>命令。其中，attached-bit avoid-learning命令适用于需要针对指定设备配置的情况。</p>
<p><strong>ISIS发布缺省路由</strong></p>
<p>在具有外部路由的边界设备上配置IS-IS发布缺省路由可以使该设备在IS-IS路由域内发布一条0.0.0.0&#x2F;0的缺省路由。</p>
<p>在执行此配置后，IS-IS域内的其他设备在转发流量时，将所有去往外部路由域的流量首先转发到该设备，然后通过该设备去往外部路由域。</p>
<p>通常，当网络中部署了IS-IS和其他路由协议时，为了实现IS-IS域内的流量可以到达IS-IS域外，通常有如下两种方式：在边界设备上配置IS-IS设备向IS-IS域发布缺省路由。该方式较为简单，不需要学习外部路由。在边界设备上将其他路由域的路由引入到IS-IS中。</p>
<p><strong>[Huawei-isis-1] default-route-advertise [ always | match default | route-policy route-policy-name ] [ cost cost | tag tag | [ level-1 | level-1-2 | level-2 ] ] [ avoid-learning ]</strong></p>
<h2 id="LSP分片"><a href="#LSP分片" class="headerlink" title="LSP分片"></a>LSP分片</h2><img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ截图20240812192048.png" alt="QQ截图20240812192048" style="zoom:67%;">

<p><img src="/2024/08/09/IGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20240812192150.png" alt="QQ截图20240812192150"></p>
<p>Mode-2工作原理：虚拟系统不参与路由SPF计算，网络中所有路由器都知道虚拟系统生成的LSP实际属于初始系统。</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>IGP高级特性</tag>
      </tags>
  </entry>
  <entry>
    <title>IPv6</title>
    <url>/2024/08/06/IPv6/</url>
    <content><![CDATA[<h1 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h1><img src="/2024/08/06/IPv6/QQ截图20240806184336.png" alt="QQ截图20240806184336" style="zoom:67%;">

<img src="/2024/08/06/IPv6/QQ截图20240806184510.png" alt="QQ截图20240806184510" style="zoom:67%;">

<p>地址结构：</p>
<p><img src="/2024/08/06/IPv6/QQ%E6%88%AA%E5%9B%BE20240806184703.png" alt="QQ截图20240806184703"></p>
<h1 id="接口标识"><a href="#接口标识" class="headerlink" title="接口标识"></a>接口标识</h1><p><img src="/2024/08/06/IPv6/QQ%E6%88%AA%E5%9B%BE20240806184817.png" alt="QQ截图20240806184817"></p>
<p>基于mac地址，第七位取反，中间插入FFFE（16位），mac（48位）+FFFE（16位）&#x3D;接口id（64位）</p>
<h1 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h1><p><img src="/2024/08/06/IPv6/QQ%E6%88%AA%E5%9B%BE20240806185442.png" alt="QQ截图20240806185442"></p>
<p>单播地址（Unicast Address）：标识一个接口，目的地址为单播地址的报文会被送到被标识的接口。在IPv6中，一个接口拥有多个IPv6地址是非常常见的现象。</p>
<p>IPv6单播地址分成以下几种类型：</p>
<ol>
<li>全局单播地址 (Global Unicast Addresses)</li>
<li>链路本地地址 (Link Local Addresses)</li>
<li>唯一本地地址 (Unique Local Addresses - ULA)</li>
<li>环回地址 (Loopback (::1))</li>
<li>未指定地址 (Unspecified (::))</li>
</ol>
<p>组播地址（Multicast Address）：标识多个接口，目的地址为组播地址的报文会被送到被标识的所有接口。只有加入相应组播组的设备接口才会侦听发往该组播地址的报文。</p>
<p>任播地址（Anycast Address）：任播地址标识一组网络接口（通常属于不同的节点）。目标地址是任播地址的数据包将发送给其中路由意义上最近的一个网络接口。</p>
<p><strong>IPv6没有定义广播地址（Broadcast Address）</strong></p>
<h2 id="全球单播地址"><a href="#全球单播地址" class="headerlink" title="全球单播地址"></a>全球单播地址</h2><p>GUA（Global Unicast Address，全球单播地址），也被称为可聚合全球单播地址。该类地址全球唯一，用于需要有互联网访问需求的主机，<strong>相当于IPv4的公网地址</strong>。2000::&#x2F;3</p>
<p>****这种类型的地址允许路由前缀的聚合，从而限制了全球路由表项的数量****。</p>
<p><img src="/2024/08/06/IPv6/QQ%E6%88%AA%E5%9B%BE20240806190604.png" alt="QQ截图20240806190604"></p>
<h2 id="唯一本地地址"><a href="#唯一本地地址" class="headerlink" title="唯一本地地址"></a>唯一本地地址</h2><p>ULA（Unique Local Address，唯一本地地址）<strong>是IPv6私网地址</strong>，只能够在内网中使用。该地址空间在IPv6公网中不可被路由，因此不能直接访问公网。</p>
<p>唯一本地地址使用<strong>FC00::&#x2F;7</strong>地址块，目前仅使用了<strong>FD00::&#x2F;8地</strong>址段。FC00::&#x2F;8预留为以后拓展用。ULA虽然只在有限范围内有效，但也具有全球唯一的前缀（虽然随机方式产生，但是冲突概率很低）。</p>
<img src="/2024/08/06/IPv6/QQ截图20240806191000.png" alt="QQ截图20240806191000" style="zoom:67%;">

<h2 id="链路本地地址"><a href="#链路本地地址" class="headerlink" title="链路本地地址"></a>链路本地地址</h2><p>LLA（Link-Local Address，链路本地地址）是IPv6中另一种应用范围受限制的地址类型。LLA的有效范围是本地链路，前缀为FE80::&#x2F;10。</p>
<p><img src="/2024/08/06/IPv6/QQ%E6%88%AA%E5%9B%BE20240806191119.png" alt="QQ截图20240806191119"></p>
<p>LLA用于一条单一链路层面的通信，例如IPv6地址无状态自动配置、IPv6邻居发现等。源或目的IPv6地址为链路本地地址的数据包将不会被转发到始发的链路之外，换句话说，链路本地地址的有效范围为本地链路。每一个IPv6接口都必须具备一个链路本地地址。华为设备支持自动生成和手工指定两种配置方式。</p>
<h2 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a>组播地址</h2><img src="/2024/08/06/IPv6/QQ截图20240806191334.png" alt="QQ截图20240806191334" style="zoom:67%;">

<p>FF02::1（链路本地的所有结点）</p>
<p>FF02::2（链路本地的所有路由器）</p>
<p>FF02::5（所有启用ospfv3的路由器）</p>
<p>FF02::6（ospfv3DR和BDR侦听的地址）</p>
<p>DD02::D（PIMv2路由器侦听的地址）</p>
<p><strong>组播mac地址</strong></p>
<img src="/2024/08/06/IPv6/QQ截图20240806192244.png" alt="QQ截图20240806192244" style="zoom:67%;">

<p>前16bit 33：33，后32bit从组播ipv6地址后32bit映射</p>
<p>复习（IPv4组播MAC地址的高24bit为0x01005E，第25bit为0，低23bit为IPv4组播地址的低23bit映射。）</p>
<p><strong>被请求节点的组播地址</strong></p>
<p>当一个节点具有了单播或任播地址，就会对应生成一个被请求节点组播地址，并且加入这个组播组。</p>
<p>该地址主要用于邻居发现机制和地址重复检测功能。被请求节点组播地址的有效范围为本地链路范围。</p>
<p><img src="/2024/08/06/IPv6/QQ%E6%88%AA%E5%9B%BE20240806192626.png" alt="QQ截图20240806192626"></p>
<p>被请求节点组播地址的应用场景举例：</p>
<p>在IPv6中，ARP及广播都被取消，当设备需要请求某个IPv6地址对应的MAC地址时，设备依然需要发送请求报文，但是该报文是一个组播报文，其目的IPv6地址是目标IPv6单播地址对应的被请求节点组播地址，由于只有目标节点才会侦听这个被请求节点组播地址，所以该组播报文可以被目标节点所接收，同时不会占用其他非目标节点的网络性能。</p>
<img src="/2024/08/06/IPv6/QQ截图20240806192905.png" alt="QQ截图20240806192905" style="zoom:67%;">

<h2 id="任播地址"><a href="#任播地址" class="headerlink" title="任播地址"></a>任播地址</h2><img src="/2024/08/06/IPv6/QQ截图20240806193123.png" alt="QQ截图20240806193123" style="zoom:67%;">

<p>任播过程涉及一个任播报文发起方和一个或多个响应方。<br>任播报文的发起方通常为请求某一服务（例如，Web服务）的主机。<br>任播地址与单播地址在格式上无任何差异，唯一的区别是一台设备可以给多台具有相同地址的设备发送报文。</p>
<p>网络中运用任播地址有很多优势：<br>业务冗余。比如，用户可以通过多台使用相同地址的服务器获取同一个服务（例如，Web服务）。这些服务器都是任播报文的响应方。如果不是采用任播地址通信，当其中一台服务器发生故障时，用户需要获取另一台服务器的地址才能重新建立通信。如果采用的是任播地址，当一台服务器发生故障时，任播报文的发起方能够自动与使用相同地址的另一台服务器通信，从而实现业务冗余。<br>提供更优质的服务。</p>
<p>比如，某公司在A省和B省各部署了一台提供相同Web服务的服务器。基于路由优选规则，A省的用户在访问该公司提供的Web服务时，会优先访问部署在A省的服务器，提高访问速度，降低访问时延，大大提升了用户体验。</p>
<h1 id="ICMPv6"><a href="#ICMPv6" class="headerlink" title="ICMPv6"></a>ICMPv6</h1><p>报文格式</p>
<img src="/2024/08/06/IPv6/QQ截图20240806193603.png" alt="QQ截图20240806193603" style="zoom:80%;">

<p>icmpv6常用报文</p>
<img src="/2024/08/06/IPv6/QQ截图20240806193733.png" alt="QQ截图20240806193733" style="zoom: 67%;">

<h1 id="NDP"><a href="#NDP" class="headerlink" title="NDP"></a>NDP</h1><img src="/2024/08/06/IPv6/QQ截图20240806193907.png" alt="QQ截图20240806193907" style="zoom:80%;">

<img src="/2024/08/06/IPv6/QQ截图20240806193941.png" alt="QQ截图20240806193941" style="zoom:80%;">

<p>路由器发现</p>
<img src="/2024/08/06/IPv6/QQ截图20240806194353.png" alt="QQ截图20240806194353" style="zoom:80%;">

<img src="/2024/08/06/IPv6/QQ截图20240806194601.png" alt="QQ截图20240806194601" style="zoom:80%;">

<img src="/2024/08/06/IPv6/QQ截图20240806194653.png" alt="QQ截图20240806194653" style="zoom:80%;">

<p>ipv6 nd ra { max-interval maximum-interval | min-interval minimum-interval }命令用来配置发送周期。</p>
<h2 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h2><p>IPv6地址解析通过ICMPv6（NS和NA报文）来实现。</p>
<p>在三层完成地址解析，</p>
<p>主要带来以下几个好处：地址解析在三层完成，不同的二层介质可以采用相同的地址解析协议。</p>
<p>可以使用三层的安全机制避免地址解析攻击。使用组播方式发送请求报文，减少了二层网络的性能压力。</p>
<p><img src="/2024/08/06/IPv6/QQ%E6%88%AA%E5%9B%BE20240806194918.png" alt="QQ截图20240806194918"></p>
<p>类似arp协议，ipv6没有广播，所以用组播，目的地址时被请求节点的地址，FF02::1:FFxx:xx(xx是目的ip地址后24位，前104位固定)</p>
<h2 id="ipv6邻居状态"><a href="#ipv6邻居状态" class="headerlink" title="ipv6邻居状态"></a>ipv6邻居状态</h2><img src="/2024/08/06/IPv6/QQ截图20240806200147.png" alt="QQ截图20240806200147" style="zoom:80%;">

<p>R1先发送NS报文，并生成缓存条目，此时，邻居状态为Incomplete。<br>若收到R2回复的NA报文，则邻居状态由Incomplete变为Reachable，否则固定时间后邻居状态由Incomplete变为Empty。<br>经过邻居可达时间（默认30s），邻居状态由Reachable变为Stale，即未知是否可达。<br>如果在Reachable状态，R1收到R2的非请求NA报文，且其中携带的R2的链路层地址和表项中不同，则邻居状态马上变为Stale。<br>在Stale状态若R1要向R2发送数据，则邻居状态由Stale变为Delay，并发送NS请求。<br>在经过一段固定时间后，邻居状态由Delay变为Probe，其间若有NA应答，则邻居状态由Delay变为Reachable。<br>在Probe状态，R1每隔一定时间间隔（默认1s）发送单播NS，发送固定次数后，有应答则邻居状态变为Reachable，否则邻居状态变为Empty。</p>
<h2 id="重复地址检测"><a href="#重复地址检测" class="headerlink" title="重复地址检测"></a>重复地址检测</h2><img src="/2024/08/06/IPv6/QQ截图20240806200510.png" alt="QQ截图20240806200510" style="zoom:80%;">

<p>一个地址在通过重复地址检测之前称为“tentative地址”，即“试验地址”。</p>
<p>此时该接口不能使用这个试验地址进行单播通讯。若2个节点配置相同地址，同时作重复地址检测时，当一方收到对方发出的DAD NS报文，则接收方将不启用该地址。</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><img src="/2024/08/06/IPv6/QQ截图20240806200624.png" alt="QQ截图20240806200624" style="zoom:80%;">

<h1 id="IPv6无状态自动获取地址"><a href="#IPv6无状态自动获取地址" class="headerlink" title="IPv6无状态自动获取地址"></a>IPv6无状态自动获取地址</h1><p>不需要IPv6地址分配服务器保存和管理每个节点的状态信息的一种IPv6地址自动配置方式，称之为IPv6无状态地址自动配置。</p>
<p>无状态地址自动配置方式基<strong>于NDP</strong>来实现。</p>
<img src="/2024/08/06/IPv6/QQ截图20240806203236.png" alt="QQ截图20240806203236" style="zoom:67%;">

<img src="/2024/08/06/IPv6/QQ截图20240806203314.png" alt="QQ截图20240806203314" style="zoom:80%;">

<img src="/2024/08/06/IPv6/QQ截图20240806203640.png" alt="QQ截图20240806203640" style="zoom:67%;">

<h1 id="DHCPv6"><a href="#DHCPv6" class="headerlink" title="DHCPv6"></a>DHCPv6</h1><p>DHCPv6又分为如下三种：</p>
<p>DHCPv6有状态自动配置：DHCPv6服务器自动配置IPv6地址&#x2F;前缀及其他网络配置参数（DNS、NIS、SNTP服务器地址等参数）。</p>
<p>DHCPv6无状态自动配置：主机IPv6地址仍然通过路由通告方式自动生成，DHCPv6服务器只分配除IPv6地址以外的配置参数，包括DNS服务器等参数。</p>
<p>DHCPv6 PD（Prefix Delegation，前缀代理）自动配置：下层网络路由器不需要再手工指定用户侧链路的IPv6地址前缀，它只需要向上层网络路由器提出前缀分配申请，上层网络路由器便可以分配合适的地址前缀给下层路由器，下层路由器把获得的前缀（前缀一般长度小于64）进一步自动细分成64位前缀长度的子网网段，把细分的地址前缀再通过路由通告(RA)至与IPv6主机直连的用户链路上，实现主机的地址自动配置，从而完成整个IPv6网络的层次化布局。</p>
<img src="/2024/08/06/IPv6/QQ截图20240806204001.png" alt="QQ截图20240806204001" style="zoom:67%;">

<p>四步交互</p>
<img src="/2024/08/06/IPv6/QQ截图20240806204030.png" alt="QQ截图20240806204030" style="zoom:67%;">

<p>两步交互</p>
<img src="/2024/08/06/IPv6/QQ截图20240806204054.png" alt="QQ截图20240806204054" style="zoom:67%;">

<p>dhcpv6报文总结</p>
<img src="/2024/08/06/IPv6/QQ截图20240806204243.png" alt="QQ截图20240806204243" style="zoom:80%;">

<h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p><img src="/2024/08/06/IPv6/QQ%E6%88%AA%E5%9B%BE20240806204414.png" alt="QQ截图20240806204414"></p>
<p><img src="/2024/08/06/IPv6/QQ%E6%88%AA%E5%9B%BE20240806204420.png" alt="QQ截图20240806204420"></p>
<p>路由器配置全球单播地址之后才能配置生成链路本地地址，PC可以自己直接生成链路本地地址</p>
<p>配置案例</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>IPv6</tag>
        <tag>DHCPv6</tag>
        <tag>ICMPv6</tag>
      </tags>
  </entry>
  <entry>
    <title>IS-IS总结</title>
    <url>/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="IS-IS的介绍"><a href="#IS-IS的介绍" class="headerlink" title="IS-IS的介绍"></a>IS-IS的介绍</h1><p>IS-IS   —中间系统到中间系统</p>
<p>Is-is最开始是在osi模型中，适用于CLNP网络，现在的Isis指的是集成Isis</p>
<p>集成IS-IS特点:<br>支持CLNP网络、IP网络<br>采用数据链路层封装</p>
<p>OSPF特点:<br>只支持IP网络<br>采用IP报文封装</p>
<p>应用场景：</p>
<p>ospf：园区网络</p>
<p>Isis：ISP骨干网</p>
<h1 id="NASP"><a href="#NASP" class="headerlink" title="NASP"></a>NASP</h1><p>CLNP协议中不实用IP地址，使用的是NSAP地址</p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps1.jpg" alt="img"> </p>
<p><strong>NET</strong>（Network Entity Title，网络实体名称）是OSI协议栈中设备的网络层信息，主要用于路由计算，由区域地址（Area ID）和System ID组成，可以看作是特殊的NSAP（SEL为00的NSAP）。<br>NET的长度与NSAP的相同，<strong>最长为20Byte，最短为8Byte</strong>。<br>在IP网络中运行IS-IS时，只需配置NET，根据NET地址设备可以获取到Area ID以及System ID。<br><strong>System ID必须唯一</strong>，类似ospf中的router id</p>
<img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/QQ截图20240721214923.png" alt="QQ截图20240721214923" style="zoom:50%;">

<p>示例：</p>
<img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/QQ截图20240721215039.png" alt="QQ截图20240721215039" style="zoom:50%;">

<h1 id="IS-IS拓扑结构"><a href="#IS-IS拓扑结构" class="headerlink" title="IS-IS拓扑结构"></a>IS-IS拓扑结构</h1><p>IS-IS在自治系统内采用骨干区域与非骨干区域两级的分层结构：Level-1路由器部署在非骨干区域。Level-2路由器和Level-1-2路由器部署在骨干区域。每一个非骨干区域都通过Level-1-2路由器与骨干区域相连。</p>
<p>1）IS-IS中路由器的分类</p>
<p>Leverl-1：只能和同区域的L1、L1&#x2F;2路由器建立L1的邻接关系，只能有本区域的L1 LSDB数据库</p>
<p>level-2：可以和同区域的或者不同 区域L2、L1&#x2F;2路由器建立L2的邻接关系，拥有L2的LSDB</p>
<p>level1-2：可以 和同区域的L1路由器建立L1的邻接关系，也可以和同区域或者不同区域的L2路由器建立L2的邻接关系</p>
<p>2）Isis支持 的网络类型</p>
<p>广播和点到点</p>
<p>广播（Broadcast）： 如Ethernet。<br>点到点（P2P）： 如PPP、 HDLC等。</p>
<p>3）Isis的开销值</p>
<p>IS-IS使用Cost（开销）作为路由度量值，Cost值越小，则路径越优。IS-IS链路的Cost与设备的<strong>接口</strong>有关，与OSPF类似，每一个激活了IS-IS的接口都会维护接口Cost。然而与OSPF不同的是，IS-IS接口的Cost在缺省情况下<strong>并不与接口带宽相关</strong>（在实际部署时，IS-IS也支持根据带宽调整Cost值），无论接口带宽多大，<strong>缺省时Cost为10。</strong>一条IS-IS路径的Cost等于本路由器到达目标网段沿途的所有链路的Cost总和。</p>
<p>IS-IS有三种方式来确定接口的开销，按照优先级由高到低分别是：<br>接口开销：为单个接口设置开销。<br>全局开销：为所有接口设置开销。<br>自动计算开销：根据接口带宽自动计算开销。</p>
<h1 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h1><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/QQ截图20240721215844.png" alt="QQ截图20240721215844" style="zoom:50%;">

<p>通用头部解释：</p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/QQ%E6%88%AA%E5%9B%BE20240721220027.png" alt="QQ截图20240721220027"></p>
<img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/QQ截图20240721220242.png" alt="QQ截图20240721220242" style="zoom:50%;">

<p>TLV：</p>
<img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/QQ截图20240721220332.png" alt="QQ截图20240721220332" style="zoom:50%;">



<h1 id="IS-IS协议工作原理"><a href="#IS-IS协议工作原理" class="headerlink" title="IS-IS协议工作原理"></a>IS-IS协议工作原理</h1><p>工作原理：①建立邻接；②同步LSDB；③计算路由；</p>
<h2 id="邻接建立"><a href="#邻接建立" class="headerlink" title="邻接建立"></a>邻接建立</h2><p>IS-IS按如下原则建立邻接关系：</p>
<p>只有同一层次的相邻路由器才有可能成为邻接。<br>对于Level-1路由器来说，Area ID必须一致。<br>链路两端IS-IS接口的网络类型必须一致。<br>链路两端IS-IS接口的地址必须处于同一网段（默认情况下）。</p>
<p>使用<strong>IIH（Isis hello ）</strong>：发现邻居；建立邻接关系；维护邻接关系，</p>
<p>广播网络：level-1 LAN IIH、level-2 LAN IIH、</p>
<p>Level-1 IIH和Level-2 IIH发送的组播地址分别为<strong>01-80-C2-00-00-14、01-80-C2-00-00-15。</strong></p>
<p>点到点网络中：P2P  IIH</p>
<p><strong>IIH：</strong></p>
<p>P2P IIH中相对于LAN IIH来说，多了一个表示本地链路ID的Local Circuit ID字段，缺少了表示广播网中DIS的优先级的Priority字段以及表示DIS和伪节点System ID的LAN ID字段。</p>
<p><strong>图1-68</strong> IS-IS Hello消息格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------------------------------------+------------</span><br><span class="line">|  Intradomain Routing Protocol Discriminator  |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|               Length Indicator               |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|        Version/Protocol ID Extension         |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|                  ID Length                   |     PDU</span><br><span class="line">+----------------------------------------------+    Common</span><br><span class="line">| R | R | R |          PDU Type                |    Header</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|                    Version                   |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|                   Reserved                   |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|             Maximum Area Addresses           |      |</span><br><span class="line">+----------------------------------------------+------------</span><br><span class="line">|             Reserved/Circuit Type            |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|                  Source ID                   |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|                 Holding Time                 |      |</span><br><span class="line">+----------------------------------------------+     PDU</span><br><span class="line">|                  PDU Length                  |    Specific</span><br><span class="line">+----------------------------------------------+    Header</span><br><span class="line">| R |                 Priority                 |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|                    LAN ID                    |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|               Local Circuit ID               |      |</span><br><span class="line">+----------------------------------------------+------------</span><br><span class="line">|         Variable Length Fields (CLV)         |</span><br><span class="line">+----------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>Reserved&#x2F;Circuit Type：表示路由器的类型（01表示L1，10表示L2，11表示L1&#x2F;L2）。 </p>
<p>Source ID  ：发出Hello报文的路由器的System ID。 </p>
<p>Holding Time ： 保持时间。在此时间内如果没有收到邻接发来的Hello报文，则中止已建立的邻接关系。  </p>
<p>Priority ：选举DIS的优先级，取值范围为0～127。数值越大，优先级越高。该字段只在广播网中的Hello消息(LAN IIH消息)携带；点到点网络的Hello消息(P2P IIH消息)没有此字段，也没有此字段之前的R保留位。 </p>
<p>LAN ID ： 包括DIS的System ID和伪节点ID。该字段只在广播网中的Hello消息(LAN IIH消息)携带；点到点网络的Hello消息(P2P IIH消息)没有此字段。</p>
<p> Local Circuit ID ：本地链路ID。该字段只在点到点网络的Hello消息(P2P IIH消息)携带；广播网中的Hello消息(LAN IIH消息)没有此字段。 </p>
<p>广播类型：</p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps2.jpg" alt="img"> </p>
<p>点到点类型：</p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps3.jpg" alt="img"> </p>
<p><strong>选举DIS：</strong></p>
<p>在广播网络中，IS-IS需要在一个广播网络中的所有的路由器中选举一个路由器作为DIS（Designated Intermediate System）。<br>DIS用来创建和更新伪节点（Pseudonodes），并负责生成伪节点的LSP，用来描述这个网络上有哪些网络设备。伪节点是用来模拟广播网络的一个虚拟节点，并非真实的路由器。在IS-IS中，伪节点用DIS的System ID和Circuit ID（非0值）标识。</p>
<p>Level-1和Level-2的DIS是分别选举的，用户可以为不同级别的DIS选举设置不同的优先级。</p>
<p>DIS选举原则：</p>
<p>①优先级：0-127  默认64，越大越优，优先级0也参与选举</p>
<p>②MAC地址：越大越优</p>
<p>DIS发送Hello PDU的时间间隔是普通路由器的1&#x2F;3，这样可以确保DIS出现故障时能够被更快速地被发现。</p>
<p><strong>IS-IS中DIS与OSPF协议中DR（Designated Router）的区别</strong>：<br>1.在IS-IS广播网中，优先级为0的路由器也参与DIS的选举，而在OSPF中优先级为0的路由器则不参与DR的选举。<br>2.在IS-IS广播网中，当有新的路由器加入，并符合成为DIS的条件时，这个路由器会被选中成为新的DIS，原有的伪节点被删除。此更改会引起一组新的LSP泛洪。而在OSPF中，当一台新路由器加入后，即使它的DR优先级值最大，也不会立即成为该网段中的DR。—-ISis中的DIS支持抢占，ospf中的DR和BDR不支持抢占<br>3.在IS-IS广播网中，同一网段上的同一级别的路由器之间都会形成邻接关系，包括所有的非DIS路由器之间也会形成邻接关系。而在OSPF中，路由器只与DR和BDR建立邻接关系。 –<strong>-Isis中建立的都是邻接的关系</strong></p>
<h2 id="同步链路状态数据库"><a href="#同步链路状态数据库" class="headerlink" title="同步链路状态数据库"></a>同步链路状态数据库</h2><p>L1和L2分别有自己的LSDB</p>
<p>LSDB中包含的就是LSP，LSP描述路由器的链路状态信息</p>
<p><R1> display isis lsdb<br>               Database information for ISIS(1)<br>Level-1 Link State Database<br>LSPID               Seq Num    Checksum  Holdtime  Length  ATT&#x2F;P&#x2F;OL<br>-——————————————————————————————–<br>0100.0000.1001.00-00*  0x00000005  0x13a8    1187      97     0&#x2F;0&#x2F;0<br>0100.0000.1001.01-00*   0x00000001  0xda2e    1185      55     0&#x2F;0&#x2F;0<br>0100.0000.2002.00-00   0x00000004  0x94e9    1188      86     1&#x2F;0&#x2F;0<br>Total LSP(s): 5<br>  <em>(In TLV)-Leaking Route, <em>(By LSPID)-Self LSP, +-Self LSP(Extended),<br>     ATT-Attached, P-Partition, OL-Overload<br>0100.0000.1001（路由器的系统ID）.00（实节点还是伪节点，00表示实节点，非0表示伪节点）-00（LSP分片）</em>（</em>表示是本路由器产生的）</R1></p>
<p> <strong>LSP</strong></p>
<p><strong>图1-70</strong> L1&#x2F;L2 LSP格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------------------------------------+------------</span><br><span class="line">|  Intradomain Routing Protocol Discriminator  |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|               Length Indicator               |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|        Version/Protocol ID Extension         |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|                  ID Length                   |     PDU</span><br><span class="line">+----------------------------------------------+    Common</span><br><span class="line">| R | R | R |          PDU Type                |    Header</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|                    Version                   |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|                   Reserved                   |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|             Maximum Area Addresses           |      |</span><br><span class="line">+----------------------------------------------+------------</span><br><span class="line">|                   PDU Length                 |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|             Remaining Lifetime               |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|                    LSP ID                    |     PDU</span><br><span class="line">+----------------------------------------------+    Specific</span><br><span class="line">|               Sequency Number                |    Header</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">|                     Checksum                 |      |</span><br><span class="line">+----------------------------------------------+      |</span><br><span class="line">| P |            ATT            | OL | IS Type |      |</span><br><span class="line">+----------------------------------------------+------------</span><br><span class="line">|         Variable Length Fields(CLV)          |</span><br><span class="line">+----------------------------------------------+</span><br></pre></td></tr></table></figure>



<p>Remaining Lifetime : LSP的生存时间，以秒为单位。</p>
<p> LSP ID:由三部分组成，System ID、伪节点ID和LSP分片后的编号。</p>
<p> Sequence Number: LSP的序列号。在路由器启动时所发送的第一个LSP报文中的序列号为1，以后当需要生成新的LSP时，新LSP的序列号在前一个LSP序列号的基础上加1。更高的序列号意味着更新的LSP。</p>
<p>Checksum ： LSP的校验和。 </p>
<p>ATT（Attachment）：由Level-1-2路由器产生，用来指明始发路由器是否与其它区域相连。虽然此标志位也存在于Level-1和Level-2的LSP中，但实际上此字段只和Level-1-2路由器始发的L1 LSP有关。</p>
<p>OL（LSDB Overload，1bit）：过载标志位。设置了过载标志位的LSP虽然还会在网络中扩散，但是在计算通过超载路由器的路由时不会被采用。即对路由器设置过载位后，其它路由器在进行SPF计算时不会考虑这台路由器。当路由器内存不足时，系统自动在发送的LSP报文中设置过载标志位。 IS Type(2bit)：生成LSP的路由器的类型。用来指明是Level-1还是Level-2路由器（01表示Level-1，11表示Level-2）。 </p>
<img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/QQ截图20240721222135.png" alt="QQ截图20240721222135" style="zoom:50%;">

<img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/QQ截图20240721222141.png" alt="QQ截图20240721222141" style="zoom:50%;">



<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps4.jpg" alt="img"> </p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps5.jpg" alt="img"> </p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps6.jpg" alt="img"> </p>
<p>3）Isis路由计算</p>
<p>①L1的路由器只能通过L1的LSBD计算学习到L1的路由  —只有L1邻接关系的路由</p>
<p>②L2的路由器维护L2的LSDB，但是可以学习所有的路由，包括L1和L2的路由—全网路由</p>
<p>③L1&#x2F;2会向L1区域下发一条L1的缺省路由，L1可以通过该缺省路由到达L2</p>
<p>④路由渗透：将L2路由在L1&#x2F;2路由器上进行引入，让L1路由器可以学习到L2的明细路由</p>
<p>[R2-isis-1]import-route isis level-2 into level-1 </p>
<p> 4、IS-IS协议的报文</p>
<p>ospf–Isis报文的对应</p>
<p>Hello  —&gt;IIH</p>
<p>DD  —&gt;CSNP</p>
<p>LSR  —&gt;PSNP</p>
<p>LSU  —&gt;LSP</p>
<p>LSACK  —&gt;PSNP</p>
<p>LSA  —&gt;LSP</p>
<p>根据报文的种类，认证可以分为以下三类：<br>接口认证：在接口视图下配置，对Level-1和Level-2的Hello报文进行认证。<br>区域认证：在IS-IS进程视图下配置，对Level-1的CSNP、PSNP和LSP报文进行认证。<br>路由域认证：在IS-IS进程视图下配置，对Level-2的CSNP、PSNP和LSP报文进行认证。</p>
<p>根据报文的认证方式，可以分为以下四类：<br>简单认证：将配置的密码直接加入报文中，这种加密方式安全性较其他两种方式低。<br>MD5认证：通过将配置的密码进行MD5算法加密之后再加入报文中，提高密码的安全性。<br>Keychian认证：通过配置随时间变化的密码链表来进一步提升网络的安全性。<br>HMAC-SHA256认证：通过将配置的密码进行HMAC-SHA256算法加密之后再加入报文中，提高密码的安全性。</p>
<p>5、IS-IS协议配置</p>
<p>[r1]isis  进入Isis进程，默认进程1   </p>
<p>[r1-isis-1]network-entity 49.0001.0000.0000.0001.00   配置NET地址，其中system id必须唯一</p>
<p>[r1-isis-1]is-level level-1  修改路由的级别，默认为L1&#x2F;2路由器 </p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;0]isis enable  100   宣告网段进入Isis进程100</p>
<p>[R2-isis-1]is-name R2   将system id用name表示</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1]isis circuit-level level-2  修改接口的链路级别</p>
<p>[r1-GigabitEthernet0&#x2F;0&#x2F;0]isis circuit-type p2p   修改接口的链路类型</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;2]isis dis-priority 127 level-2   修改接口的优先级，影响DIS的选举，可以只针对某个level进行更改</p>
<p><img src="/2024/04/20/IS-IS%E6%80%BB%E7%BB%93/wps7.jpg" alt="img"> </p>
<p>查看命令</p>
<p>Display  isis peer  查看Isis邻居</p>
<p>Display Isis interface  查看DIS的选举、</p>
<p>Display Isis  route  查看Isis路由</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>IS-IS</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLS</title>
    <url>/2023/12/05/MPLS/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>MPLS（Multiprotocol Label Switching）多协议标签转发复习总结<br>首先我们要先知道MPLS是为何出现的？<br>MPLS是基于传统IP网络（RIP，OSPF等）的缺陷由IETF确定的</p>
<p><strong>顺便先复习一下路由器查路由表 转发的过程：</strong></p>
<p>传统的IP转发中，物理层从交换机的一个端口收到一个报文，上送到数据链路层。数据链路层去掉链路层封装，根据报文的协议域上送给相应的网络层。网络层首先看报文是否是送给本机的，若是，去掉网络层封装，上送给它的上层协议。若不是，则根据报文的目的地址查找路由表，若找到路由，将报文送给相应端口的数据链路层，数据链路层封装后，发送报文。若找不到路由，将报文丢弃。传统的IP转发采用的是逐跳转发，数据报文经过每一台交换机，都要执行上述过程（如图中SWA收到目的地址为10.2.0.1的数据包，SWA会依次查找路由表，根据匹配的路由表项的进行转发，SWB、SWC、SWD都会进行类似的处理），所以速度缓慢。并且所有的交换机需要知道全网的路由或者默认路由。另外，由于传统IP转发是面向无连接的，所以无法提供好的Qos保证。</p>
<p>传统IP网络基于IGP Metric计算最优路径，这是远远不够的，往往在现实网络中还需考虑带宽、链路属性等其他因素；基于IP的流量工程是基于IGP面向目的地址的转发，是hop-by-hop（逐跳）的转发，无法实现根据来源来控制流量转发；另外基于IP的流量工程是面向无连接的，不能实现显式路径（Explicit Routing）。</p>
<p>MPLS的出现<br>从A到走到B有三种方法：<br><strong>1.广播</strong>（如以太网）：直接把数据发给每一个地方<br><strong>2.逐跳寻径</strong>：走到一个地方，问一下路接下来该怎么走（也就是上面说的根据路由协议，查路由表）<br><strong>3.源路由</strong>：提前规划好路线，到哪里怎么走，不常用。</p>
<p>而<strong>MPLS</strong>是第四种走法：<br>跟在“向导”后面走，向导在走过的路上做好标记，你只要沿着标记的指示走就可以了。这也就是“标签交换”</p>
<p>MPLS结合了三层路由技术与二层交换技术，所以可以把它看成“<strong>2.5层</strong>”的<br>其中的MP多协议指的是支持多种网络协议，如ipv4，ipv6，CLNP，IPX等</p>
<p>MPLS是一种标签转发技术，它采用无连接的控制平面和面向连接的数据平面（具体的MPLS架构下面还有介绍），无连接的控制平面实现路由信息的传递和标签的分发，面向连接的数据平面实现报文在建立的标签转发路径上传送。MPLS域内，交换机不需要查看每个报文的目的IP地址，只需要根据封装在IP头外面的标签进行转发即可，这样可以大大提高效率</p>
<p>MPLS转发与IP逐跳转发的关系<br>MPLS是IP的承载层：MPLS转发与IP转发不冲突，它们的关系是如果能够使用MPLS转发，那么IP包会先封装成MPLS数据帧来转发。如果不能MPLS转发，就还是原来的ip逐跳转发。<br><strong>（也就是尽量优先MPLS，因为它会更快）</strong></p>
<p><img src="/2023/12/05/MPLS/mnvc7761.png" alt="mnvc7761"></p>
<p>看上面的图，我们需要理解：整个MPLS域（可以进行MPLS转发的区域）是嵌在IP域上的，也就是MPLS域外部是IP域，它本身也运行IP域。</p>
<p><strong>MPLS中一些基本概念，名词</strong><br>标签（Label）：是一个定长的，比较短的，只具有本地意义的标识。<br><strong>FEC（转发等价类）</strong>：一组或一类数据，这组数据分配的标签相同，这些数据流在转发过程中被网络节点以<strong>相同方式处理</strong>。在MPLS网络中，FEC可以通过多种方式划分，例如基于目的IP地址及网络掩码、DSCP等特征来划分。数据属于哪一个LSP，由数据进入MPLS域时的Ingress LSR决定。<br><strong>LSP（标签交换通道）</strong>：一个FEC的数据流，在不同的节点被赋予确定的标签,数据转发按照<br>这些标签进行。数据流所走的路径就是LSP。LSP是一个从“起点”到“终点”的<strong>单向</strong>路径，若需要双向数据互通，则需要在双方之间建立双向的LSP。<br><strong>LSR（Label Switching Router</strong>）： LSR是MPLS的网络的核心交换机，它提供标签交<br>换和标签分发功能。<br><strong>LER（Label Switching Edge Router）</strong>：在MPLS的网络边缘，进入到MPLS网络的流量由LER分为不同的FEC，并为这些FEC请求相应的标签。它提供流量分类和标签的映射、标签的移除功能。</p>
<p>从IP域进入MPLS域的时候，LER（标记边缘路由器）要做一个压入（push），出MPLS域的时候做一个弹出（pop），而LSR（标记交换路由器）负责转发。所以LER实际工作量比LSR大很多。LSP（标记交换路径）就是从进入到离开 走的路径。这条路径是在转发报文之前就已经通过各种协议确定并建立的，报文会在特定的LSP上传递。（也可以把LSP看成一个隧道）</p>
<h1 id="标签报文格式"><a href="#标签报文格式" class="headerlink" title="标签报文格式"></a>标签报文格式</h1><p><img src="/2023/12/05/MPLS/QQ%E6%88%AA%E5%9B%BE20240815174315.png" alt="QQ截图20240815174315"></p>
<p>MPLS Header长度为<strong>32bits</strong>，包括长度为<strong>20bits的标签（Label）</strong>，该标签用于报文转发；长度为3bits的EXP通常用来承载IP报文中的优先级；长度为<strong>1bit的栈底标志S</strong>用来表明是否是最后一个标签（MPLS标签可以多层嵌套）；长度为<strong>8bits的TTL</strong>，作用类似IP头部的TTL，用来防止报文环路等。</p>
<p><strong>标签空间：</strong></p>
<p><img src="/2023/12/05/MPLS/QQ%E6%88%AA%E5%9B%BE20240815174644.png" alt="QQ截图20240815174644"></p>
<h1 id="MPLS转发过程"><a href="#MPLS转发过程" class="headerlink" title="MPLS转发过程"></a>MPLS转发过程</h1><p>依据三张表：</p>
<img src="/2023/12/05/MPLS/QQ截图20240815175251.png" alt="QQ截图20240815175251" style="zoom:67%;">

<p><strong>Tunnel ID：</strong>为了给使用隧道的上层应用（如VPN、路由管理）提供统一的接口，系统自动为隧道分配了一个ID，也称为Tunnel ID。该Tunnel ID的长度为32比特，只是本地有效。在MPLS转发过程中，FIB、ILM和NHLFE表项是通过Tunnel ID关联的。</p>
<img src="/2023/12/05/MPLS/QQ截图20240815175654.png" alt="QQ截图20240815175654" style="zoom:67%;">

<p>在Ingress LSR，通过查询FIB表（得到FTN信息）和NHLFE表指导报文的转发。</p>
<p>当IP报文进入MPLS域时，首先查看FIB表，<strong>检查目的IP地址对应的Tunnel ID值是否为0x0。如果Tunnel ID值为0x0，则进入正常的IP转发流程。如果Tunnel ID值不为0x0，则进入MPLS转发流程</strong>。</p>
<img src="/2023/12/05/MPLS/QQ截图20240815175659.png" alt="QQ截图20240815175659" style="zoom:67%;">

<p>在Transit LSR，通过查询ILM表和NHLFE表指导MPLS报文的转发。</p>
<img src="/2023/12/05/MPLS/QQ截图20240815175703.png" alt="QQ截图20240815175703" style="zoom:67%;">

<p>在Egress LSR，通过查询ILM表指导MPLS报文的转发。</p>
<img src="/2023/12/05/MPLS/QQ截图20240815175711.png" alt="QQ截图20240815175711" style="zoom:67%;">



<p>例：</p>
<img src="/2023/12/05/MPLS/mplszfgc813341.png" alt="mplszfgc813341" style="zoom:67%;">

<p>1.Push：首先从IP数据包从ip域进入MPLS域，入口LER做 push 操作，分析转发等价类，为数据包“打上标签”，绑定LSP通道；图中A的标签转发表内容大概如下：</p>
<p><img src="/2023/12/05/MPLS/a008298.png" alt="a008298"></p>
<p>2.Swap：B，C两个LSR根据标签转发表，用下一跳分配的标签，替换MPLS报文的标签并转发</p>
<p><img src="/2023/12/05/MPLS/bc66327448.png" alt="bc66327448"></p>
<p>3.Pop：转发到出口LER D时，进行pop弹出操作，去掉标签</p>
<p>MPLS转发的过程到这里结束。</p>
<p><img src="/2023/12/05/MPLS/d4kg2110.png" alt="d4kg2110"></p>
<p><strong>PHP</strong>（倒数第二跳弹出。Penultimate Hop Popping ，和web开发的php可没关系）：上面的过程我们可以发现，C在发给D时，其实带标签的数据已经没有意义，因为下一跳就要弹出标签了，所以完全可以在C就把标签弹出，然后以ip报文形式转发给D。<br>这样可以大大降低最后的出口LER的工作量，是现在MPLS普遍采用的方法。<br>默认情况下，设备支持PHP特性，支持PHP的Egress节点即出口LER 分配给倒数第二跳节点的标签值为3。</p>
<h1 id="MPLS标签转发表与LDP"><a href="#MPLS标签转发表与LDP" class="headerlink" title="MPLS标签转发表与LDP"></a>MPLS标签转发表与LDP</h1><p>我们知道，<br>交换机中的MAC地址表是通过逆向学习法产生的；<br>路由器中的路由表是通过路由协议学习或自己配置静态路由产生的。<br>那么MPLS中标签转发表是怎么产生的呢？</p>
<p>答案是也会有一个类似的路由器学习的协议，这个协议叫做LDP（Label Distribution Protocol 标签分发协议），这个也是MPLS技术的核心协议之一。LDP来完成标签的分配控制和保持</p>
<p>从整个MPLS架构看这个协议的位置：</p>
<img src="/2023/12/05/MPLS/QQ截图20240815175011.png" alt="QQ截图20240815175011" style="zoom:67%;">

<p>MPLS包括两个平面：控制平面和数据平面。<br>控制平面负责产生和维护路由信息以及标签信息。数据平面负责普通IP报文的转发以及带MPLS标签报文的转发。<br>控制平面中路由协议模块（Routing Protocol）用来传递路由信息，生成路由信息表；标签分发协议模块（Label Distribution Protocol）用来完成标签信息的交换，建立标签转发路径。<br>数据平面包括IP转发表和标签转发表，当收到普通IP报文时（Incoming IP Packets），如果是普通IP转发，则查找IP路由表转发，如果需要标签转发，则按照标签转发表转发；当收到带有标签的报文时（Incoming Labeled Packets）时，如果需要按照标签转发，根据标签转发表转发，如果需要转发到IP网络，则去掉标签后根据IP转发表转发。</p>
<img src="/2023/12/05/MPLS/QQ截图20240815185202.png" alt="QQ截图20240815185202" style="zoom:80%;">

<p>LDP消息：</p>
<img src="/2023/12/05/MPLS/QQ截图20240815185809.png" alt="QQ截图20240815185809" style="zoom: 80%;">

<p>LDP消息承载在UDP或TCP之上，端口号均为646 。其中发现消息基于UDP传递；会话消息、通告消息、通知消息都基于TCP传递。</p>
<img src="/2023/12/05/MPLS/QQ截图20240815190515.png" alt="QQ截图20240815190515" style="zoom: 80%;">

<img src="/2023/12/05/MPLS/QQ截图20240815190658.png" alt="QQ截图20240815190658" style="zoom:80%;">

<img src="/2023/12/05/MPLS/QQ截图20240815190854.png" alt="QQ截图20240815190854" style="zoom:80%;">

<img src="/2023/12/05/MPLS/QQ截图20240815191105.png" alt="QQ截图20240815191105" style="zoom:80%;">

<p>标签分配：LSR从本地标签空间中取出一个标签与FEC绑定。标签分发：LSR将标签与FEC的绑定关系通知给上游LSR。</p>
<img src="/2023/12/05/MPLS/QQ截图20240815191132.png" alt="QQ截图20240815191132" style="zoom: 80%;">

<img src="/2023/12/05/MPLS/QQ截图20240815191811.png" alt="QQ截图20240815191811" style="zoom:80%;">

<img src="/2023/12/05/MPLS/QQ截图20240815191817.png" alt="QQ截图20240815191817" style="zoom: 80%;">

<img src="/2023/12/05/MPLS/QQ截图20240815191822.png" alt="QQ截图20240815191822" style="zoom:80%;">

<p>Liberal方式的最大优点在于路由发生变化时能够快速建立新的LSP进行数据转发，因为Liberal方式保留了所有的标签。缺点是需要分发和维护不必要的标签映射。</p>
<img src="/2023/12/05/MPLS/QQ截图20240815191828.png" alt="QQ截图20240815191828" style="zoom:80%;">

<p>Conservative方式的优点在于只需保留和维护用于转发数据的标签，以达到节约标签的目的。</p>
<img src="/2023/12/05/MPLS/QQ截图20240815192347.png" alt="QQ截图20240815192347" style="zoom:80%;">

<img src="/2023/12/05/MPLS/QQ截图20240815192352.png" alt="QQ截图20240815192352" style="zoom:80%;">





<p>LDP的标签管理与保留方式主要内容有下面三部分</p>
<ol>
<li><strong>标签分配模式</strong></li>
</ol>
<p>DoD：下游按需标记分发<br>DU：下游自主标记分发<br>2. <strong>标签控制模式</strong></p>
<p>有序方式<br>独立方式</p>
<ol start="3">
<li><strong>标签保持模式</strong></li>
</ol>
<p>保守模式<br>自由模式<br>最常用的组合是 <strong>下游自主（DU） + 有序 + 自由</strong></p>
<p>下面来具体介绍什么意思</p>
<p><img src="/2023/12/05/MPLS/shangxiayou6291.png" alt="shangxiayou6291"></p>
<p>这里先要理解上游，下游的概念，MPLS入口出为最上游；出口处为最下游。标签的产生可以理解为是下游为上游产生的，下游产生的IN标签作为上游的OUT标签（比如图中R3左边要接收的IN标签为100，那么R2向右的OUT标签就要是100，因为R3只要为100的标签）</p>
<p>然后具体介绍上面的三个部分：<br><strong>Ⅰ.标签的控制模式</strong>（即标签是怎么产生的）：<br>有序（常用）：只有最下游路由器才能产生标签，最下游的上游收到最下游的标签映射消息后，然后才能再往自己的上游发送标签映射关系。<br>独立：中间的路由器也可以直接产生标签</p>
<p><strong>Ⅱ.标签的分发模式：</strong><br>下游按需 ：需要的时候上游再向下游询问标签信息；<br>下游自主：不管有没有问，下游路由器都自主的向上游发送标签映射信息（主动向上汇报）<br><strong>Ⅲ.标签的保留模式</strong>：如果有两条路径，也就会有两个标签，那么路由器保留哪个。<br>保守：只保留路由表中的”最佳路径“，跳数比较少的；<br>自由：保留所有的标签，虽然占用了更多的标签空间，但是收敛会快</p>
<h1 id="基础实验"><a href="#基础实验" class="headerlink" title="基础实验"></a>基础实验</h1><p><img src="/2023/12/05/MPLS/tuoputump181224.png" alt="tuoputump181224"></p>
<p><strong>配置步骤：</strong></p>
<p>完成ip和ospf配置：</p>
<p>R1的配置如下： </p>
<p>[R1] interface GigabitEthernet0&#x2F;0&#x2F;0 </p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;0] ip address 12.1.1.1 24 </p>
<p>[R1] interface loopback0</p>
<p>[R1-Loopback0] ip address 1.1.1.1 32 </p>
<p>[R1] ospf 1 router-id 1.1.1.1 </p>
<p>[R1-ospf-1] area 0 </p>
<p>[R1-ospf-1-0.0.0.0] network 12.1.1.0 0.0.0.255 </p>
<p>[R1-ospf-1-0.0.0.0] network 1.1.1.1 0.0.0.0 </p>
<p>R2的配置如下： </p>
<p>[R2] interface GigabitEthernet0&#x2F;0&#x2F;0 </p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;0] ip address 12.1.1.2 24 </p>
<p>[R2] interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1] ip address 23.1.1.2 24 </p>
<p>[R2] interface loopback0 </p>
<p>[R2-Loopback0] ip address 2.2.2.2 32 </p>
<p>[R2] ospf 1 router-id 2.2.2.2 </p>
<p>[R2-ospf-1] area 0 </p>
<p>[R2-ospf-1-0.0.0.0] network 12.1.1.0 0.0.0.255 </p>
<p>[R2-ospf-1-0.0.0.0] network 23.1.1.0 0.0.0.255 </p>
<p>[R2-ospf-1-0.0.0.0] network 2.2.2.2 0.0.0.0 </p>
<p>R3的配置如下： </p>
<p>[R3] interface GigabitEthernet0&#x2F;0&#x2F;0 </p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;0] ip address 23.1.1.3 24 </p>
<p>[R3] interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;1] ip address 34.1.1.3 24 </p>
<p>[R3] interface loopback0 </p>
<p>[R3-Loopback0] ip address 3.3.3.3 32 </p>
<p>[R3] ospf 1 router-id 3.3.3.3 </p>
<p>[R3-ospf-1] area 0 </p>
<p>[R3-ospf-1-0.0.0.0] network 23.1.1.0 0.0.0.255 </p>
<p>[R3-ospf-1-0.0.0.0] network 34.1.1.0 0.0.0.255 </p>
<p>[R3-ospf-1-0.0.0.0] network 1.1.1.1 0.0.0.0 </p>
<p>R4的配置如下： </p>
<p>[R4] interface GigabitEthernet0&#x2F;0&#x2F;0</p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;0] ip address 34.1.1.4 24 </p>
<p>[R4] interface loopback0 </p>
<p>[R4-Loopback0] ip address 4.4.4.4 32 </p>
<p>[R4] ospf 1 router-id 4.4.4.4 </p>
<p>[R4-ospf-1] area 0 </p>
<p>[R4-ospf-1-0.0.0.0] network 34.1.1.0 0.0.0.255 </p>
<p>[R4-ospf-1-0.0.0.0] network 4.4.4.4 0.0.0.0 </p>
<p><strong>激活mpls并激活ldp</strong></p>
<p>（全局和接口下都需要激活）</p>
<p>R1的配置如下： </p>
<p>[R1] mpls lsr-id 1.1.1.1 </p>
<p>#配置MPLS LSR ID </p>
<p>[R1] mpls </p>
<p>#全局激活MPLS </p>
<p>[R1-mpls] quit </p>
<p>[R1] mpls ldp </p>
<p>#全局激活LDP </p>
<p>[R1-mpls-ldp] quit </p>
<p>[R1] Interface GigabitEthernet 0&#x2F;0&#x2F;0 </p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;0] mpls </p>
<p>#在接口上激活MPLS </p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;0] mpls ldp </p>
<p>#在接口上激活LDP </p>
<p>R2的配置如下： </p>
<p>[R2] mpls lsr-id 2.2.2.2 </p>
<p>[R2] mpls </p>
<p>[R2-mpls] quit </p>
<p>[R2] mpls ldp </p>
<p>[R2-mpls-ldp] quit </p>
<p>[R2] Interface GigabitEthernet 0&#x2F;0&#x2F;0 </p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;0] mpls</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;0] mpls ldp </p>
<p>[R2] Interface GigabitEthernet 0&#x2F;0&#x2F;1 </p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1] mpls </p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1] mpls ldp </p>
<p>R3的配置如下： </p>
<p>[R3] mpls lsr-id 3.3.3.3 </p>
<p>[R3] mpls </p>
<p>[R3-mpls] quit </p>
<p>[R3] mpls ldp </p>
<p>[R3-mpls-ldp] quit </p>
<p>[R3] Interface GigabitEthernet 0&#x2F;0&#x2F;0 </p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;0] mpls </p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;0] mpls ldp </p>
<p>[R3] Interface GigabitEthernet 0&#x2F;0&#x2F;1 </p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;1] mpls </p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;1] mpls ldp </p>
<p>R4的配置如下： </p>
<p>[R4] mpls lsr-id 4.4.4.4 </p>
<p>[R4] mpls </p>
<p>[R4-mpls] quit </p>
<p>[R4] mpls ldp </p>
<p>[R4-mpls-ldp] quit </p>
<p>[R4] Interface GigabitEthernet 0&#x2F;0&#x2F;0 </p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;0] mpls </p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;0] mpls ldp</p>
<p><strong>验证</strong>： </p>
<p><R1>display mpls ldp peer</R1></p>
<p> LDP Peer Information in Public network</p>
<p> A ‘*’ before a peer means the peer is being deleted.</p>
<p> -—————————————————————————–</p>
<p> PeerID         TransportAddress  DiscoverySource</p>
<p> -—————————————————————————–</p>
<p> 2.2.2.2:0        2.2.2.2       GigabitEthernet0&#x2F;0&#x2F;0</p>
<p> -—————————————————————————–</p>
<p> TOTAL: 1 Peer(s) Found.</p>
<p>以上输出的是R1的LDP邻居表，从表中可以看出R1已经发现了一个LDP邻居，那就是R2。</p>
<p><R1>disp mpls ldp session  verbose </R1></p>
<p> LDP Session(s) in Public Network</p>
<p> -—————————————————————————–</p>
<p> Peer LDP ID   : 2.2.2.2:0      Local LDP ID  : 1.1.1.1:0</p>
<p> TCP Connection  : 1.1.1.1 &lt;- 2.2.2.2</p>
<p> Session State  : Operational    Session Role  : Passive</p>
<p> Session FT Flag : Off         MD5 Flag    : Off</p>
<p> Reconnect Timer : —         Recovery Timer : —</p>
<p> Keychain Name  : —</p>
<p> Negotiated Keepalive Hold Timer  : 45 Sec</p>
<p> Configured Keepalive Send Timer  : —</p>
<p> Keepalive Message Sent&#x2F;Rcvd    : 153&#x2F;153 (Message Count)</p>
<p> Label Advertisement Mode      : Downstream Unsolicited</p>
<p> Label Resource Status(Peer&#x2F;Local) : Available&#x2F;Available</p>
<p> Session Age            : 0000:00:38 (DDDD:HH:MM)</p>
<p> Session Deletion Status      : No</p>
<p> Capability:</p>
<p>  Capability-Announcement     : Off</p>
<p>  P2MP Capability         : Off</p>
<p> Outbound&amp;Inbound Policies applied : NULL</p>
<p> Addresses received from peer: (Count: 3)</p>
<p> 2.2.2.2       12.1.1.2       23.1.1.2      </p>
<p> -—————————————————————————–</p>
<p>以上输出的是LDP会话的详细信息，邻居的状态必须为<strong>Operational</strong>才是最终的稳态，另外从TCP连接1.1.1.1 &lt; 2.2.2.2可以验证一点，LDP的会话建立是由传输地址大的一方发起的。</p>
<p><R1>display mpls ldp lsp </R1></p>
<p> LDP LSP Information</p>
<p> -——————————————————————————</p>
<p> DestAddress&#x2F;Mask  In&#x2F;OutLabel   UpstreamPeer   NextHop     OutInterface</p>
<p> -——————————————————————————</p>
<p> 1.1.1.1&#x2F;32     3&#x2F;NULL     2.2.2.2     127.0.0.1    InLoop0</p>
<p>*1.1.1.1&#x2F;32     Liberal&#x2F;1026          DS&#x2F;2.2.2.2</p>
<p> 2.2.2.2&#x2F;32     NULL&#x2F;3     -        12.1.1.2     GE0&#x2F;0&#x2F;0</p>
<p> 2.2.2.2&#x2F;32     1026&#x2F;3     2.2.2.2     12.1.1.2     GE0&#x2F;0&#x2F;0</p>
<p> 3.3.3.3&#x2F;32     NULL&#x2F;1024    -        12.1.1.2     GE0&#x2F;0&#x2F;0</p>
<p> 3.3.3.3&#x2F;32     1024&#x2F;1024    2.2.2.2     12.1.1.2     GE0&#x2F;0&#x2F;0</p>
<p> 4.4.4.4&#x2F;32     NULL&#x2F;1025    -        12.1.1.2     GE0&#x2F;0&#x2F;0</p>
<p> 4.4.4.4&#x2F;32     1025&#x2F;1025    2.2.2.2     12.1.1.2     GE0&#x2F;0&#x2F;0</p>
<p> -——————————————————————————</p>
<p> TOTAL: 7 Normal LSP(s) Found.</p>
<p> TOTAL: 1 Liberal LSP(s) Found.</p>
<p> TOTAL: 0 Frr LSP(s) Found.</p>
<p> A ‘*’ before an LSP means the LSP is not established</p>
<p> A ‘*’ before a Label means the USCB or DSCB is stale</p>
<p> A ‘*’ before a UpstreamPeer means the session is stale</p>
<p> A ‘*’ before a DS means the session is stale</p>
<p> A ‘*’ before a NextHop means the LSP is FRR LSP</p>
<p>以上输出的是R1的LFIB（标签转发信息库），可以看到已经建立好的LSP。 </p>
<p>实际上，当我们再R1、R2、R3、R4上运行OSPF后，全网的路由已经被打通，也就是每台路由器都拥有全网的路由，其中包括互联网段的路由，以及各设备的Loopback路由。随后我们激活各设备的MPLS和LDP，每台设备会基于自己的路由表中的路由前缀进行标签捆绑，并且将为路由前缀（FEC）所捆绑的标签分发给自己的LDP邻居。默认情况下在我司的设备上，仅为&#x2F;32的主机路由分发标签，并且默认水平分割规则并未打开。</p>
<p>现在，来测试一下，从R1去tracert 4.4.4.4： </p>
<p><R1>tracert lsp ip 4.4.4.4 32</R1></p>
<p> LSP Trace Route FEC: IPV4 PREFIX 4.4.4.4&#x2F;32 , press CTRL_C to break.</p>
<p> TTL  Replier       Time   Type    Downstream </p>
<p> 0                 Ingress  12.1.1.2&#x2F;[1025 ]</p>
<p> 1   12.1.1.2      20 ms  Transit  23.1.1.3&#x2F;[1024 ]</p>
<p> 2   23.1.1.3      20 ms  Transit  34.1.1.4&#x2F;[3 ]</p>
<p> 3   4.4.4.4       20 ms  Egress </p>
<p>从tracert的结果我们可以看到数据包行走的路径，以及被压入的标签。</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>mpls</tag>
        <tag>ldp</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLSVPN实验</title>
    <url>/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>网络架构</p>
<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240816211302.png" alt="QQ截图20240816211302" style="zoom:67%;">

<p>MPLS VPN不是单一的一种VPN技术，是多种技术结合的综合解决方案，主要包含下列技术：MP-BGP：负责在PE与PE之间传递站点内的路由信息。LDP：负责PE与PE之间的隧道建立。VRF：负责PE的VPN用户管理。静态路由、IGP、BGP：负责PE与CE之间的路由信息交换。</p>
<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240816211714.png" alt="QQ截图20240816211714" style="zoom:80%;">





<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240816211801.png" alt="QQ截图20240816211801" style="zoom:80%;">

<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240816211834.png" alt="QQ截图20240816211834" style="zoom:80%;">

<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240816211845.png" alt="QQ截图20240816211845" style="zoom:80%;">

<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240816211901.png" alt="QQ截图20240816211901" style="zoom:80%;">

<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240816212112.png" alt="QQ截图20240816212112" style="zoom:80%;">

<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240816212116.png" alt="QQ截图20240816212116" style="zoom:80%;">

<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240816212144.png" alt="QQ截图20240816212144" style="zoom:80%;">

<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240816212148.png" alt="QQ截图20240816212148" style="zoom:80%;">





<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p><img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ%E6%88%AA%E5%9B%BE20240701192326.png" alt="QQ截图20240701192326"></p>
<p>配置接口ip地址以及loopback 0地址：略</p>
<p>目的：CE1和CE2之间不能互访，CE1和CE2可以访问CE3</p>
<p><strong>创建VPN实例</strong></p>
<p>ip vpn-instance CE1<br> ipv4-family<br>  route-distinguisher 100:1<br>  vpn-target 100:1 export-extcommunity<br>  vpn-target 100:1 import-extcommunity</p>
<p>[PE1-GigabitEthernet0&#x2F;0&#x2F;0]ip binding vpn-instance CE1 （接口绑定）</p>
<p>注意：绑定VPN实例后，接口配置会消失，注意重新配置ip</p>
<p>ip vpn-instance CE2<br> ipv4-family<br>  route-distinguisher 200:1<br>  vpn-target 200:1 export-extcommunity<br>  vpn-target 100:1 import-extcommunity</p>
<p>[PE1-GigabitEthernet0&#x2F;0&#x2F;1]ip binding vpn-instance CE2</p>
<p>PE2上创建VPN实例CE3</p>
<p>ip vpn-instance CE3<br> ipv4-family<br>  route-distinguisher 100:1<br>  vpn-target 100:1 export-extcommunity<br>  vpn-target 100:1 200:1 import-extcommunity</p>
<p>[PE2-GigabitEthernet0&#x2F;0&#x2F;1]ip binding vpn-instance CE3</p>
<p><strong>PE2和CE3之间OSPF配置</strong></p>
<p>PE2：</p>
<p>ospf 1 vpn-instance CE3 （注意在vpn实例中）<br> area 0.0.0.0<br>  network 10.0.56.0 0.0.0.255</p>
<p>CE3：</p>
<p>ospf 1<br> area 0.0.0.0<br>  network 10.0.56.0 0.0.0.255</p>
<p><strong>配置CE1和PE1之间的EBGP：</strong></p>
<p>CE1：</p>
<p>bgp 100<br> router-id 1.1.1.1<br> peer 10.0.12.2 as-number 200</p>
<p>PE1：</p>
<p>bgp 200<br> router-id 3.3.3.3<br>[PE1-bgp]ipv4-family vpn-instance CE1	（注意在vpn实例中建立）<br>[PE1-bgp-CE1]peer 10.0.12.1 as-number 100</p>
<p>查看bgp邻居关系：</p>
<p>[PE1]display bgp vpnv4 vpn-instance CE1 peer </p>
<p><strong>运营商网络之间的OSPF配置</strong></p>
<p>PE1：</p>
<p>ospf 1<br> area 0.0.0.0<br>  network 10.0.24.0 0.0.0.255<br>  network 3.3.3.3 0.0.0.0</p>
<p>P：</p>
<p>ospf 1<br> area 0.0.0.0<br>  network 10.0.24.0 0.0.0.255<br>  network 10.0.45.0 0.0.0.255<br>  network 4.4.4.4 0.0.0.0</p>
<p>PE2：</p>
<p>ospf 2 （注意是进程2，因为进程1在VPN实例CE3中使用过了，ospf本地进程唯一）<br> area 0.0.0.0<br>  network 10.0.45.0 0.0.0.255<br>  network 5.5.5.5 0.0.0.0</p>
<p><strong>运营商网络的MPLS配置</strong></p>
<p>PE1：</p>
<p>mpls lsr-id 3.3.3.3<br>mpls<br>mpls ldp</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;2<br> mpls<br> mpls ldp</p>
<p>剩余重复操作略</p>
<p><strong>PE1和PE2之间bgp建立</strong></p>
<p>PE2：</p>
<p>bgp 200<br> peer 3.3.3.3 as-number 200<br> peer 3.3.3.3 connect-interface LoopBack0<br> ipv4-family vpnv4<br>  peer 3.3.3.3 enable</p>
<p>PE1同理操作</p>
<p><strong>路由</strong></p>
<p>在CE1上创建loopback 1接口：10.10.10.10</p>
<p>在CE1上network宣告进入bgp进程</p>
<p><PE2>dis bgp vpnv4 all routing-table</PE2></p>
<p>查看已经学习到了10.10.10.10网段的路由</p>
<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240701184638.png" alt="QQ截图20240701184638" style="zoom:50%;">

<p>此时这条路由可以到达PE2</p>
<p>无法到达CE3</p>
<p>[PE2-ospf-1]import-route bgp </p>
<p>在PE2上ospf 1进程引入bgp，此时CE3可以学习到</p>
<p>（注意是进程1，进程2是运营商网络的ospf，进程1是VPN实例CE3的ospf）</p>
<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240701185128.png" alt="QQ截图20240701185128" style="zoom: 50%;">

<p>CE3上也添加一条loopback 1</p>
<p>[CE3-LoopBack1]ip address 30.30.30.30 32</p>
<p>[CE3-ospf-1]import-route direct （引入）</p>
<p>将右边ospf引入bgp</p>
<p>[PE2]bgp 200</p>
<p>[PE2-bgp]ipv4-family vpn-instance CE3 （注意在实例中引入）</p>
<p>[PE2-bgp-CE3]import-route ospf 1 （注意指明进程，默认是1）</p>
<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240701190120.png" alt="QQ截图20240701190120" style="zoom:67%;">

<p>此时bgp进程中学习到了30.30.30.30网段</p>
<p>在CE1上pingCE3的30.30.30.30（注意ping的时候加源地址-a）</p>
<p><img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ%E6%88%AA%E5%9B%BE20240701190246.png" alt="QQ截图20240701190246"></p>
<p>可以通了</p>
<p>CE2的路由</p>
<p>[PE1]ip route-static vpn-instance CE2 2.2.2.2 32 10.0.23.1</p>
<p>添加一条关于VPN实例CE2的静态路由，</p>
<p>PE1上查看CE2实例路由表</p>
<img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ截图20240701190835.png" alt="QQ截图20240701190835" style="zoom: 50%;">

<p>可以学习到了</p>
<p>PE1在BGP中引入静态路由</p>
<p>[PE1]bgp 200</p>
<p>[PE1-bgp]ipv4-family vpn-instance CE2  （注意在实例中）</p>
<p>[PE1-bgp-CE2]import-route static</p>
<p>CE2上添加默认路由</p>
<p>[CE2]ip route-static 0.0.0.0 0 10.0.23.2</p>
<p>此时CE2可以ping通CE3的30.30.30.30</p>
<p><img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ%E6%88%AA%E5%9B%BE20240701192215.png" alt="QQ截图20240701192215"></p>
<p>实验瑕疵：</p>
<p>[PE1]dis bgp vpnv4 all routing-table</p>
<p><img src="/2024/07/01/MPLSVPN%E5%AE%9E%E9%AA%8C/QQ%E6%88%AA%E5%9B%BE20240701192933.png" alt="QQ截图20240701192933"></p>
<p>可以看到，10.10.10.10网段可能传递给CE2的VPN实例</p>
<p>但是CE1和CE2之间仍然不能互访，这是因为CE2的2.2.2.2不会传递给CE1的VPN实例</p>
<p>原因：CE1和CE2的RT值设置原因，CE1的export 是100：1，CE2的import是100:1，就导致CE2也会接受CE1传递的VPN实例，但是CE2传递的，CE1不会接受，所以理论上也实现了实验要求，但是不够完美。</p>
<p>总结<strong>注意的几个点：</strong></p>
<p>1.没有建立mpls，bgp学习到的路由不被优选，原因是mp-bgp传递路由带标签，基于一个隧道转发，需要基于mpls协议，所以需要建立mpls才行</p>
<p>2.PE设备上ospf注意区分运营商网络的igp和ce到pe之间的ospf进程号</p>
<p>3.讲的情况是运营商之间的bgp和ce之间的igp互相引入，但是考虑真实情况，可以不把bgp的路由引入ce之间的igp，可以下发缺省路由，但是需要在vpn实例进程中下发，对端也要配置路由才行</p>
<p>4.运营商网络之间建立ibgp，P设备上不建，注意开启邻居vpnv4的功能</p>
<p>5.区分路由和数据的概念，本质上mpls是为了传递数据的，所以不同的vpn实例带不同的标签是为了区分不同vpn的数据。mp-bgp是为了区分不同vpn的路由（RT，RD），所以需要结合使用</p>
<p>6.如果ce和pe之间是静态，注意在vpn实例中配置路由</p>
<p>7.查看bgp路由，dis bgp vpnv4 all（代表所有vpn实例）routing-table</p>
<p>8.注意接口绑定vpn实例后，ip会消失，重新配置</p>
<p>9.RD值本地路由器唯一就行</p>
<p>10.RT值可以携带多个，注意规划合理，发布出去的export带上所有配置的RT export值，对端查看，只要有一个import能匹配上就可以接受</p>
]]></content>
      <categories>
        <category>ie实验</category>
      </categories>
      <tags>
        <tag>RT</tag>
        <tag>MPLS VPN</tag>
        <tag>MP-BGP</tag>
      </tags>
  </entry>
  <entry>
    <title>MPLSVPN跨域</title>
    <url>/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="Option-A"><a href="#Option-A" class="headerlink" title="Option A"></a>Option A</h1><p>跨域VPN-OptionA是基本BGP&#x2F;MPLS IP VPN在跨域环境下的应用，ASBR之间不需要运行MPLS，也不需要为跨域进行特殊配置。这种方式下，两个AS的边界路由器ASBR直接相连，ASBR同时也是各自所在自治系统的PE。两个ASBR都把对端ASBR看作自己的CE设备，通过EBGP对等体关系向对端发布IPv4路由。<img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240820214403.png" alt="QQ截图20240820214403"></p>
<p>注意，每个跨域vpn在asbr PE上都需要一个接口绑定相应的VRF</p>
<p>跨域VPN-OptionA是基本IPv4 L3VPN在跨域环境下的应用，ASBR之间不需要运行MPLS，也不需要为跨域进行特殊配置。这种方式下，两个AS的边界ASBR直接相连，ASBR同时也是各自所在自治系统的PE。<strong>两个ASBR都把对端ASBR看作自己的CE设备</strong>，将会为每一个VPN创建VPN实例，使用<strong>EBGP</strong>方式向对端发布IPv4路由。（ASBR PE在VPN实例下建立EBGP，传递IPv4路由）</p>
<p>采用跨域VPN-OptionA方案，要求AS的边界设备ASBR支持VPN实例，能够管理VPN路由。并且，ASBR上必须需要为每个跨域的VPN准备专用的接口（可以是子接口、物理接口、捆绑的逻辑接口）。因此，此方案对ASBR的性能要求较高，但ASBR上不必为跨域做任何特殊的配置。</p>
<img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ截图20240820214904.png" alt="QQ截图20240820214904" style="zoom:67%;">

<p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240820215101.png" alt="QQ截图20240820215101"></p>
<p>我们只通过单方向来解释控制平面的工作过程，同时假设在站点Site1有一VPN路由Client1连接，如上图，现在需要把Client1这条路由从CE1穿过AS100和AS200传递到CE2：</p>
<p>在AS100中，通过运行LDP协议，PE1分配一个与去往PE1的路由相关联的隧道标签(外层标签)T1给P1。</p>
<p>在AS100中，通过运行LDP协议，P1分配一个与去往PE1的路由相关联的隧道标签(外层标签)T2给ASBR-PE1。</p>
<p>在AS200中，同样通过运行LDP协议，ASBR-PE2分配一个与去往ASBR-PE2的路由相关联的隧道标签(外层标签)T3给P2。</p>
<p>在AS200中，通过运行LDP协议，P2分配一个与去往ASBR-PE2的路由相关联的隧道标签(外层标签)T4给PE2。</p>
<p>CE1 通告路由Client1给PE1，路由的下一跳为CE1的接口地址。</p>
<p>PE1将IPv4路由Client1通过MP-BGP重发布为VPNv4路由，并且下一跳改为PE1，分配一个VPN标签V1，然后通告给ASBR-PE1。</p>
<p>ASBR-PE1将VPNv4路由变为IPv4路由，把IPv4路由Client1通告给ASBR-PE2，并且下一跳指向ASBR-PE1。</p>
<p>ASBR-PE2将IPv4路由Client1通过MP-BGP重发布为VPNv4路由，并且下一跳为ASBR-PE2，为该路由分配一个VPN标签V2，将其通告给PE2。PE2将VPNv4路由转变为IPv4路由Client1，把路由Client1通告给CE2，并且下一跳指向PE2。</p>
<p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240820215108.png" alt="QQ截图20240820215108"></p>
<p>通过前文的过程分析，我们从反向来分析转发平面的工作过程，即CE2要发送一个目的地为Client1的IP报文给CE1，如上图所示：</p>
<p>CE2发送一个目的地为Client1的IP报文给PE2。PE2收到IP报文后进行MPLS标签的封装，先封装VPN标签V2，再封装外层标签T4，然后将此报文发送给P2。</p>
<p>P2进行标签交换，把外层标签T4换成T3，然后将此报文发送给ASBR-PE2。</p>
<p>ASBR-PE2去掉所有标签，将报文(普通IP报文)转发给ASBR-PE1。</p>
<p>ASBR-PE1收到IP报文后进行MPLS标签的封装，先封装VPN标签V1，再封装外层标签T2，然后将此报文发送给P1。</p>
<p>P1进行标签交换，把外层标签T2换成T1，然后将此报文发送给PE1。PE1收到后去掉所有标签，将报文(普通IP报文)转发给CE1。</p>
<p>实验：</p>
<p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240820215303.png" alt="QQ截图20240820215303"></p>
<p>R10和R11属于VPN aa能够互通，R1和R8属于VPN bb能够互通。</p>
<p>配置接口ip</p>
<p>创建VPN实例aa和bb，绑定接口</p>
<p>配置CE和PE之间的EBGP（PE在实例配）</p>
<p>配置骨干网的igp协议</p>
<p>配置骨干网的MP-BGP（ibgp 开启vpnv4）</p>
<p>R4R5配置EBGP（实例中，因为有两个vpn所以需要额外创建一个子接口绑定bb，建立EBGP）</p>
<p>基本配置不再赘述，基本和单域的一致</p>
<p>R4所有配置</p>
<p>sysname R4<br>#</p>
<p>ip vpn-instance aa<br> ipv4-family<br>  route-distinguisher 500:1<br>  vpn-target 1:1 export-extcommunity<br>  vpn-target 1:1 import-extcommunity<br>#</p>
<p>ip vpn-instance bb<br> ipv4-family<br>  route-distinguisher 700:1<br>  vpn-target 2:2 export-extcommunity<br>  vpn-target 2:2 import-extcommunity<br>#<br>mpls lsr-id 4.4.4.4<br>mpls<br>#<br>mpls ldp<br>#<br>interface GigabitEthernet0&#x2F;0&#x2F;0<br> ip address 10.0.34.4 255.255.255.0<br> mpls<br> mpls ldp<br>#<br>interface GigabitEthernet0&#x2F;0&#x2F;1<br> ip binding vpn-instance aa<br> ip address 10.0.45.4 255.255.255.0<br>#<br>interface GigabitEthernet0&#x2F;0&#x2F;1.1（子接口绑定VPN bb）<br> dot1q termination vid 10<br> ip binding vpn-instance bb<br> ip address 10.0.54.4 255.255.255.0<br> arp broadcast enable</p>
<h1 id><a href="#" class="headerlink" title></a></h1><p>interface LoopBack0<br> ip address 4.4.4.4 255.255.255.255<br>#<br>bgp 100<br> peer 2.2.2.2 as-number 100<br> peer 2.2.2.2 connect-interface LoopBack0</p>
<h1 id="-1"><a href="#-1" class="headerlink" title></a></h1><p> ipv4-family vpnv4<br>  policy vpn-target<br>  peer 2.2.2.2 enable<br> #<br> ipv4-family vpn-instance aa<br>  peer 10.0.45.5 as-number 200<br> #<br> ipv4-family vpn-instance bb（子接口的EBGP）<br>  peer 10.0.54.5 as-number 200<br>#<br>ospf 1<br> area 0.0.0.0<br>  network 10.0.34.0 0.0.0.255<br>  network 4.4.4.4 0.0.0.0</p>
<p>R5所有配置</p>
<p>sysname R5</p>
<h1 id="-2"><a href="#-2" class="headerlink" title></a></h1><p>ip vpn-instance aa<br> ipv4-family<br>  route-distinguisher 600:1<br>  vpn-target 3:3 export-extcommunity<br>  vpn-target 3:3 import-extcommunity<br>#<br>ip vpn-instance bb<br> ipv4-family<br>  route-distinguisher 800:1<br>  vpn-target 4:4 export-extcommunity<br>  vpn-target 4:4 import-extcommunity<br>#<br>mpls lsr-id 5.5.5.5<br>mpls<br>#<br>mpls ldp<br>#<br>isis 1<br> is-level level-2<br> network-entity 49.0000.0000.0005.00<br>#<br>interface GigabitEthernet0&#x2F;0&#x2F;0<br> ip binding vpn-instance aa<br> ip address 10.0.45.5 255.255.255.0<br>#<br>interface GigabitEthernet0&#x2F;0&#x2F;0.1<br> dot1q termination vid 10<br> ip binding vpn-instance bb<br> ip address 10.0.54.5 255.255.255.0<br> arp broadcast enable<br>#<br>interface GigabitEthernet0&#x2F;0&#x2F;1<br> ip address 10.0.56.5 255.255.255.0<br> isis enable 1<br> mpls<br> mpls ldp<br>#<br>interface LoopBack0<br> ip address 5.5.5.5 255.255.255.255<br> isis enable 1<br>#<br>bgp 200<br> peer 7.7.7.7 as-number 200<br> peer 7.7.7.7 connect-interface LoopBack0<br> #<br> ipv4-family unicast<br>  undo synchronization<br>  peer 7.7.7.7 enable<br> #<br> ipv4-family vpnv4<br>  policy vpn-target<br>  peer 7.7.7.7 enable<br> #<br> ipv4-family vpn-instance aa<br>  peer 10.0.45.4 as-number 100<br> #<br> ipv4-family vpn-instance bb<br>  peer 10.0.54.4 as-number 100<br>#</p>
<p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240820220218.png" alt="QQ截图20240820220218"></p>
<p>此时R11能学习到R10的10.10.10.10路由，能通</p>
<p>同理下边的VPN也是</p>
<h1 id="Option-B"><a href="#Option-B" class="headerlink" title="Option B"></a>Option B</h1><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ截图20240820220343.png" alt="QQ截图20240820220343" style="zoom:80%;">

<p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240820220442.png" alt="QQ截图20240820220442"></p>
<p>从PE1传递到ASBR1，再到ASBR2，之间不比较RT，RT还是之前最原始的RT，<strong>所以PE1和PE2的RT要匹配（一样）</strong></p>
<p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240820220446.png" alt="QQ截图20240820220446"></p>
<p>当VPN实例数量较多时，可以部署专门的RR设备。如图，AS内的PE和ASBR设备只与RR设备建立MP-BGP邻居关系，由RR负责路由的反射传递，PE和ASBR之间无需建立BGP邻居。RR只负责控制平面的VPNv4路由传递，数据转发时，流量不经过RR。</p>
<p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240820220451.png" alt="QQ截图20240820220451"></p>
<p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240820222821.png" alt="QQ截图20240820222821"></p>
<p>配置思路：</p>
<p>各AS内的MPLS骨干网上分别配置MPLS基本能力和MPLS LDP，建立LDP LSP。（略）</p>
<p>各AS内，PE与ASBR-PE之间建立MP-IBGP对等体关系，交换VPN路由信息。（略）</p>
<p>各AS内，与CE相连的PE上需配置VPN实例，PE与CE之间建立EBGP对等体关系，交换VPN路由信息。（略）</p>
<p><strong>在ASBR上与另一ASBR相连接口上分别使能MPLS</strong>，且ASBR之间建立MP-EBGP对等体关系，<strong>并且不对接收的VPNv4路由进行VPN-target过滤。</strong> </p>
<p>（OptionA中ASBR之间走的是ipv4，所以不需要，mpls，ipv4报文携带数据过去。OptionB中两个ASBR之间传递vpnv4路由，所以要开启mpls走隧道，并且要开启分配标签apply-label per-nexthop，并且不比较RT undo policy vpn-target）两端的RT必须一样才能接受</p>
<p>R4配置</p>
<p>sysname R4<br>#</p>
<h1 id="-3"><a href="#-3" class="headerlink" title></a></h1><p>mpls lsr-id 4.4.4.4<br>mpls<br>#<br>mpls ldp<br>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;0<br> ip address 10.0.34.4 255.255.255.0<br> mpls<br> mpls ldp<br>#<br>interface GigabitEthernet0&#x2F;0&#x2F;1<br> ip address 10.0.45.4 255.255.255.0<br> mpls<br>#</p>
<h1 id="-4"><a href="#-4" class="headerlink" title></a></h1><p>interface LoopBack0</p>
<p> ip address 4.4.4.4 255.255.255.255<br>#<br>bgp 100<br> peer 2.2.2.2 as-number 100<br> peer 2.2.2.2 connect-interface LoopBack0<br> peer 10.0.45.5 as-number 200<br> #<br> ipv4-family unicast<br>  undo synchronization<br>  peer 2.2.2.2 enable<br>  peer 10.0.45.5 enable（ASBR之间开启MP-BGP）<br> #<br> ipv4-family vpnv4<br>  undo policy vpn-target（不比较RT）<br>  apply-label per-nexthop（给ASBR之间喷配标签）<br>  peer 2.2.2.2 enable<br>  peer 10.0.45.5 enable<br>#</p>
<p>ospf 1<br> area 0.0.0.0<br>  network 10.0.34.0 0.0.0.255<br>  network 4.4.4.4 0.0.0.0</p>
<p>R5</p>
<h1 id="-5"><a href="#-5" class="headerlink" title></a></h1><p>sysname R5<br>#<br>mpls lsr-id 5.5.5.5<br>mpls<br>#<br>mpls ldp<br>#<br>isis 1<br> is-level level-2<br> network-entity 49.0000.0000.0005.00<br>#<br>interface GigabitEthernet0&#x2F;0&#x2F;0<br> ip address 10.0.45.5 255.255.255.0<br> mpls<br>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1<br> ip address 10.0.56.5 255.255.255.0<br> isis enable 1<br> mpls<br> mpls ldp<br>#<br>interface GigabitEthernet0&#x2F;0&#x2F;2<br>#<br>interface GigabitEthernet0&#x2F;0&#x2F;3<br>#<br>interface LoopBack0<br> ip address 5.5.5.5 255.255.255.255<br> isis enable 1<br>#<br>bgp 200<br> peer 7.7.7.7 as-number 200<br> peer 7.7.7.7 connect-interface LoopBack0<br> peer 10.0.45.4 as-number 100<br> #<br> ipv4-family unicast<br>  undo synchronization<br>  peer 7.7.7.7 enable<br>  peer 10.0.45.4 enable<br> #<br> ipv4-family vpnv4<br>  undo policy vpn-target<br>  apply-label per-nexthop<br>  peer 7.7.7.7 enable<br>  peer 10.0.45.4 enable<br>#</p>
<h2 id="有RR"><a href="#有RR" class="headerlink" title="有RR"></a>有RR</h2><p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240821110859.png" alt="QQ截图20240821110859"></p>
<p>两端RT一样</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;0<br> ip address 10.0.31.1 255.255.255.0</p>
<p>RR1配置</p>
<p>interface LoopBack0<br> ip address 11.11.11.11 255.255.255.255<br>#<br>bgp 100<br> peer 2.2.2.2 as-number 100<br> peer 2.2.2.2 connect-interface LoopBack0<br> peer 4.4.4.4 as-number 100<br> peer 4.4.4.4 connect-interface LoopBack0<br> #<br> ipv4-family unicast<br>  undo synchronization<br>  peer 2.2.2.2 enable<br>  peer 4.4.4.4 enable<br> #<br> ipv4-family vpnv4<br>  undo policy vpn-target<br>  peer 2.2.2.2 enable<br>  peer 2.2.2.2 reflect-client<br>  peer 4.4.4.4 enable<br>  peer 4.4.4.4 reflect-client<br>#<br>ospf 1<br> area 0.0.0.0<br>  network 10.0.31.0 0.0.0.255<br>  network 11.11.11.11 0.0.0.0</p>
<h1 id="Option-C"><a href="#Option-C" class="headerlink" title="Option C"></a>Option C</h1><p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240821223635.png" alt="QQ截图20240821223635"></p>
<p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240821223709.png" alt="QQ截图20240821223709"></p>
<p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240821223805.png" alt="QQ截图20240821223805"></p>
<p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240821223809.png" alt="QQ截图20240821223809"></p>
<p><img src="/2024/08/20/MPLSVPN%E8%B7%A8%E5%9F%9F/QQ%E6%88%AA%E5%9B%BE20240821223814.png" alt="QQ截图20240821223814"></p>
]]></content>
      <categories>
        <category>ie实验</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>PPP/PPPoE</title>
    <url>/2024/05/02/PPP-PPPoE/</url>
    <content><![CDATA[<p>PPP（点到点协议 ），该协议支持认证（PAP、CHAP）、该协议中还包括LCP、NCP协议</p>
<p>PPP链路的建立有三个阶段的协商过程，链路层协商、认证协商（可选）和网络层协商。<br>1）链路层协商：通过LCP报文进行链路参数协商，建立链路层连接。</p>
<p>链路层协议（LCP）协商的参数有MRU（最大接收单元）、认证方式（不认证、PAP、CHAP）、魔术字（检测是否有环路）</p>
<img src="/2024/05/02/PPP-PPPoE/微信截图_20240531153136.png" alt="微信截图_20240531153136" style="zoom:67%;">

<p><img src="/2024/05/02/PPP-PPPoE/wps1.jpg" alt="img"> </p>
<p><img src="/2024/05/02/PPP-PPPoE/wps2.jpg" alt="img"> </p>
<p><img src="/2024/05/02/PPP-PPPoE/wps3.jpg" alt="img"> </p>
<p>2）认证协商（可选）：通过链路建立阶段协商的认证方式进行链路认证。</p>
<p><img src="/2024/05/02/PPP-PPPoE/wps4.jpg" alt="img"> </p>
<p><img src="/2024/05/02/PPP-PPPoE/wps5.jpg" alt="img"> </p>
<p>3）网络层协商 ：通过NCP协商来选择和配置一个网络层协议并进行网络层参数协商。</p>
<p><img src="/2024/05/02/PPP-PPPoE/wps6.jpg" alt="img"> </p>
<p><img src="/2024/05/02/PPP-PPPoE/wps7.jpg" alt="img"> </p>
<p>PPP协商时接口状态的变化：</p>
<p><img src="/2024/05/02/PPP-PPPoE/wps8.jpg" alt="img"> </p>
<p>正常PPP链路建立需要经历链路建立阶段、认证阶段和网络层协商阶段，详细过程如下：<br>通信双方开始建立PPP链路时，先进入到Establish阶段。<br>在Establish阶段，进行LCP协商：协商通信双方的MRU（Maximum Receive Unit，最大接收单元）、认证方式和魔术字（Magic Number）等选项。协商成功后进入Opened状态，表示底层链路已建立。<br>如果配置了认证，将进入Authenticate阶段。否则直接进入Network阶段。<br>在Authenticate阶段，会根据连接建立阶段协商的认证方式进行链路认证。认证方式有两种：PAP和CHAP。如果认证成功，进入Network阶段，否则进入Terminate阶段，拆除链路，LCP状态转为Down。<br>在Network阶段，PPP链路进行NCP协商。通过NCP协商来选择和配置一个网络层协议并进行网络层参数协商。最常见的NCP协议是IPCP，用来协商IP参数。<br>在Terminate阶段，如果所有的资源都被释放，通信双方将回到Dead阶段。<br>PPP运行过程中，可以随时中断连接，物理链路断开、认证失败、超时定时器时间到、管理员通过配置关闭连接等动作都可能导致链路进入Terminate阶段。</p>
<p>网络运营商如何对用户上网行为进行收费和控制 ？ 针对特定的数据包，就必须识别发送方的身份。</p>
<ol>
<li>在以太网链路上，以太网技术虽然具有简单易用，成本低等特点，但是以太网广播网络的属性，使得其通信双方无法相互验证对方的身份，因而通信是不安全的。</li>
<li>在PPP链路上，<strong>由于PPP协议自带认证功能</strong>，因此可以完美的解决上述问题。但是，PPP链路又无法实现多用户上网的需求。</li>
<li>为了解决这个矛盾问题，解决用户上网行为管理和收费的问题，提出了<strong>将PPP数据帧封装在以太网数据帧里边</strong>从而在以太网网络中传输的技术——PPPoE技术。</li>
</ol>
<blockquote>
<p>这里的PPP，就是指的PPP协议数据帧，而o就是over的意思，E就是Ethernet的意思，因此，PPPoE形象的说就是<strong>“在以太网上的PPP协议”</strong>。</p>
</blockquote>
<p>PPPoE技术可以将用户连接到远程接入设备上，并提供良好访问控制功能，提供了一种经济的用户接入技术，并实现了对用户的控制。</p>
<p>PPPoE协议采用Client&#x2F;Server模式，普通用户一般为Client，而运营商为Server。</p>
<p>PPPoE的建立分为<strong>Discover阶段</strong>和<strong>PPP Session阶段</strong>。</p>
<ul>
<li><p><strong>Discover阶段：</strong>主要是选择PPPoE服务器，并确定所要建立的会话标识符Session ID。</p>
<p>当Client要运行PPPoE时，首先以广播的形式发送一个<strong>PADI（PPPoE Active Discovery Initiation）报文</strong>，该报文中含有Client端要请求的服务信息</p>
<p>PPPoE服务器在收到该报文后，会以单播的方式发送一个<strong>PADO（PPPoE Active Discovery Offer）报文</strong>，对Client端的PADI报文进行回应。</p>
<p>PPPoE Client端在收到这个报文后，会向PPPoE Server发送<strong>PADR（PPPoE Active Discovery Request）报文</strong>。在这个报文中，PPPoE Client会创建并携带一个<strong>PPPoE Session</strong>。</p>
<p>PPPoE Server还会向客户端发送<strong>PADS（PPPoE Active Discovery Session-confirmation）报文</strong>，表示收到了该Session ID。</p>
<p>发送<strong>PADT（PPPOE Active Discovery Terminate）</strong>报文，终止连接</p>
</li>
<li><p><strong>PPP Session阶段：</strong>即执行标准的PPP过程，包括LCP协商、PAP&#x2F;CHAP认证、NCP协商等阶段。</p>
<p>PPP会话阶段包括<strong>LCP协商、PAP&#x2F;CHAP认证、NCP协商</strong>等阶段。需结合PPP链路建立过程来分析</p>
</li>
<li><p><img src="/2024/05/02/PPP-PPPoE/wc07_r.jpg" alt="wc07_r"></p>
</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><img src="/2024/05/02/PPP-PPPoE/image-20240716200823058.png" alt="image-20240716200823058" style="zoom:67%;">

<img src="/2024/05/02/PPP-PPPoE/image-20240716200936313.png" alt="image-20240716200936313" style="zoom: 67%;">
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>PPP</tag>
        <tag>PPPoE</tag>
      </tags>
  </entry>
  <entry>
    <title>STP/RSTP/MSTP总结</title>
    <url>/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="STP"><a href="#STP" class="headerlink" title="STP"></a>STP</h1><p>以太网交换网络中为了进行链路备份，提高网络可靠性，通常会使用冗余链路。但是使用冗余链路会在交换网络上产生环路，引发广播风暴以及MAC地址表不稳定等故障现象，从而导致用户通信质量较差，甚至通信中断。为解决交换网络中的环路问题，提出了生成树协议STP（Spanning Tree Protocol）。</p>
<p>与众多协议的发展过程一样，生成树协议也是随着网络的发展而不断更新的，从最初的IEEE <strong>802.1D</strong>中定义的STP到IEEE <strong>802.1W</strong>中定义的快速生成树协议RSTP（Rapid Spanning Tree Protocol），再到最新的IEEE <strong>802.1S</strong>中定义的多生成树协议MSTP（Multiple Spanning Tree Protocol）。</p>
<p>生成树协议中，<strong>MSTP兼容</strong>RSTP、STP，RSTP兼容STP。</p>
<table>
<thead>
<tr>
<th>生成树协议</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>STP</td>
<td>形成一棵无环路的树，解决广播风暴并实现冗余备份。收敛速度较慢。</td>
<td>无需区分用户或业务流量，所有VLAN共享一棵生成树。</td>
</tr>
<tr>
<td>RSTP</td>
<td>形成一棵无环路的树，解决广播风暴并实现冗余备份。收敛速度快。</td>
<td></td>
</tr>
<tr>
<td>MSTP</td>
<td>形成多棵无环路的树，解决广播风暴并实现冗余备份。收敛速度快。多棵生成树在VLAN间实现负载均衡，不同VLAN的流量按照不同的路径转发。</td>
<td>需要区分用户或业务流量，并实现负载分担。不同的VLAN通过不同的生成树转发流量，每棵生成树之间相互独立。</td>
</tr>
</tbody></table>
<h2 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h2><p>1.广播风暴</p>
<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529135327.png" alt="QQ截图20240529135327" style="zoom: 67%;">

<p>根据交换机的转发原则，如果交换机从一个端口上接收到的是一个广播帧，或者是一个目的MAC地址未知的单播帧，则会将这个帧向除源端口之外的所有其他端口转发（泛洪）。如果交换网络中有环路，则这个帧会被无限转发，此时便会形成广播风暴，网络中也会充斥着重复的数据帧。</p>
<p>SWB，SWA和SWC也会将此帧转发到除了接收此帧的其他所有端口，结果此帧又会被再次转发给SWB，这种循环会一直持续，于是便产生了广播风暴。交换机性能会因此急速下降，并会导致业务中断。</p>
<p>2.MAC地址表震荡</p>
<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529135546.png" alt="QQ截图20240529135546" style="zoom:67%;">

<p>交换机是根据所接收到的数据帧的源地址和接收端口生成MAC地址表项的。</p>
<p>（1）主机A向外发送一个单播帧，假设此单播帧的目的MAC地址在网络中所有交换机的MAC地址表中都暂时不存在。SWB收到此数据帧之后，在MAC地址表中生成一个MAC地址表项：</p>
<table>
<thead>
<tr>
<th>SWB的MAC地址表</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>MAC地址</td>
<td>端口</td>
</tr>
<tr>
<td>00-05-06-07-08-AA</td>
<td>GE0&#x2F;0&#x2F;3</td>
</tr>
</tbody></table>
<p>​     将其从G0&#x2F;0&#x2F;1和G0&#x2F;0&#x2F;2端口转发。此例仅以SWB从G0&#x2F;0&#x2F;1端口转发此帧为例进行说明。</p>
<p>（2）SWA接收到此帧后，由于MAC地址表中没有对应此帧目的MAC地址的表项，所以SWA会将此帧从G0&#x2F;0&#x2F;2转发出去。</p>
<p>（3）SWC接收到此帧后，由于MAC地址表中也没有对应此帧目的MAC地址的表项，所以SWC会将此帧从G0&#x2F;0&#x2F;2端口发送回SWB，也会发给主机B。</p>
<p>（4）SWB从G0&#x2F;0&#x2F;2接口接收到此数据帧之后，会在MAC地址表中删除原有的相关表项，生成一个新的表项：</p>
<table>
<thead>
<tr>
<th>SWB的MAC地址表</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>MAC地址</td>
<td>端口</td>
</tr>
<tr>
<td>00-05-06-07-08-AA</td>
<td>GE0&#x2F;0&#x2F;3</td>
</tr>
<tr>
<td>00-05-06-07-08-AA</td>
<td>GE0&#x2F;0&#x2F;2</td>
</tr>
</tbody></table>
<p>此过程会不断重复，从而导致MAC地址表震荡。</p>
<h2 id="STP基本概念"><a href="#STP基本概念" class="headerlink" title="STP基本概念"></a>STP基本概念</h2><p>根桥</p>
<p>树形的网络结构必须有树根，于是STP引入了根桥（Root Bridge）概念。</p>
<p>对于一个STP网络，根桥在全网中只有一个，它是整个网络的逻辑中心，但不一定是物理中心。根桥会根据网络拓扑的变化而动态变化。</p>
<p>网络收敛后，根桥会按照一定的时间间隔产生并向外发送配置BPDU，其他设备收到该配置BPDU后，如果优先级比自己的配置BPDU高，则非根桥设备会根据收到的配置BPDU中携带的信息更新自己STP端口存储的配置BPDU信息，否则会丢弃该配置BPDU。</p>
<ul>
<li><p>BID：桥ID</p>
<p>IEEE 802.1D标准中规定BID是由16位的桥优先级（Bridge Priority）与桥MAC地址构成。BID桥优先级占据高16位，其余的低48位是MAC地址。</p>
<p>在STP网络中，桥ID最小的设备会被选举为根桥。</p>
</li>
<li><p>PID：端口ID</p>
<p>PID由两部分构成的，高4位是端口优先级，低12位是端口号。</p>
<p>PID只在某些情况下对选择指定端口有作用。</p>
</li>
</ul>
<p>桥优先级：0-65535，默认32768，必须是4095倍数</p>
<p>端口优先级：0-240，默认128，步长16，必须是16的倍数</p>
<h2 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h2><p>1.选举根桥（BID&#x3D;优先级+MAC，优先级越小越优，如果优先级相等，MAC小的成为根桥）</p>
<p>在一个交换网络中选举一个根桥</p>
<p>2.选举根端口（RPC小的优+上行交换机的BID+上行交换机的PID+本地PID）</p>
<p>在每个非根交换机选举一个根端口</p>
<p>3.选举指定端口（RPC小的优+本端口的BID+本端口的PID）</p>
<p>每个网段选举一个指定端口</p>
<p>4.阻塞非指定端口</p>
<p>阻塞交换机上的所有非根，非指定端口</p>
<p> 在初始形成STP树的过程中<strong>，所有STP交换机</strong>会周期性地（HelloTime，缺省为2s）主 动产生并发送配置BPDU，大家都认为自己是根桥。 ▫ 随着BPDU的泛洪和收集，各交换机根据BPDU包含的信息进行比较，并选举出根桥。 ▫ 在此之后（即STP树形成后的稳定期），<strong>只有根桥会周期性地（缺省为2s</strong>）主动产生 并发送配置BPDU。相应的，非根桥交换机会从自己的根端口周期性地接收到配置 BPDU，并立即触发产生自己的配置BPDU，然后从自己的指定端口发出。——这一 过程看起来就像是，根桥发出的配置BPDU逐跳地“经过”了其他的交换机。也可以 理解为：从根桥倒一盆水下来，水顺着这棵无环的树从上往下不断地往下流。</p>
<p><img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/fig_dc_fd_stp_000504.png" alt="fig_dc_fd_stp_000504"></p>
<p>▫ Disabled状态：端口无法接收和发出任何帧（即：端口不仅不处理BPDU报文，也不 转发用户流量），端口处于关闭（down）状态。</p>
<p> ▫ Blocking状态：端口只能接收并处理BPDU，不能发送BPDU，也不能转发用户数据帧 （用户流量），是阻塞端口的最终状态。</p>
<p> ▫ Listening状态：端口可以接收并发送BPDU，<strong>但不进行MAC地址学习</strong>，也不能转发用 户数据帧。这是过渡状态，用于确定端口角色，将选举出根桥、根端口和指定端口， 同时用于防止临时环路。 </p>
<p>▫ Learning状态：端口可以接收并发送BPDU，<strong>也可以进行MAC地址学习</strong>，根据收到的 用户流量<strong>构建MAC地址表</strong>，但不能转发用户数据帧（用户流量）。这也是过渡状态， 用于防止MAC地址表未建立，网络中出现大量数据帧泛洪。</p>
<p> ▫ Forwarding状态：端口可以接收并发送BPDU，也可以进行MAC地址学习，同时能够 转发用户数据帧（用户流量）。<strong>只有根端口或指定端口才能进入Forwarding状态。</strong></p>
<p> • 端口状态迁移： </p>
<ol>
<li>STP交换机的端口在初始启动时，会从Disabled状态进入到Blocking状态。<strong>在 Blocking状态，端口只接收和分析BPDU，但不发送。</strong></li>
<li>在整个过程中，端口一但被关闭或发生了链路故障，就会进入Disabled状态。 </li>
<li>如果端口被选为根端口或指定端口，则会进入Listening状态，此时端口接收并发送 BPDU，这种状态会持续一个Forward Delay的时间长度，缺省为15s，是为了防止临 时环路：因为此时网络中可能还存在因STP树的计算过程不同步而产生的临时环路。 </li>
<li>在端口状态迁移过程中，如果端口的角色被判定为非根端口或非指定端口，则其端 口状态就会立即退回到Blocking状态。 </li>
<li>如果没有因“意外情况”回到Disabled状态，那么端口会进入Learning状态，此时端口 不但可以接收并发送BPDU，<strong>还会开始构建MAC地址表，为用户流量的转发做好准备。</strong> 这个状态也会持续一个Forward Delay的时间长度，缺省为15s，是为了防止此时交 换机的MAC地址表还未建立，导致大量的数据帧被泛洪。 </li>
<li>最后，端口进入Forwarding状态，开始转发用户流量。</li>
</ol>
<p>对于STP，影响端口状态和端口收敛有以下3个参数。</p>
<ul>
<li><p>Hello Time（2s）</p>
<p>运行STP协议的设备发送配置消息BPDU的时间间隔，用于设备检测链路是否存在故障。设备每隔Hello Time时间会向周围的设备发送hello报文，以确认链路是否存在故障。</p>
<p>当网络拓扑稳定之后，该计时器的修改只有在根桥修改后才有效。新的根桥会在发出的BPDU报文中填充适当的字段以向其他非根桥传递该计时器修改的信息。但当拓扑变化之后，<strong>TCN BPDU的发送不受这个计时器的管理。</strong></p>
</li>
<li><p>Forward Delay（15s）</p>
<p>设备状态迁移的延迟时间。链路故障会引发网络重新进行生成树的计算，生成树的结构将发生相应的变化。不过重新计算得到的新配置消息无法立刻传遍整个网络，如果新选出的根端口和指定端口立刻就开始数据转发的话，可能会造成临时环路。为此，STP采用了一种状态迁移机制，新选出的根端口和指定端口要经过<strong>2倍的Forward Delay</strong>延时后才能进入转发状态，这个延时保证了新的配置消息传遍整个网络，从而防止了临时环路的产生。30s</p>
<p>Forward Delay Timer指一个端口处于Listening和Learning状态的各自持续时间，默认是15秒。即Listening状态持续15秒，随后Learning状态再持续15秒。这两个状态下的端口不转发用户流量，这正是STP用于避免临时环路的关键。</p>
</li>
<li><p>Max Age（20s）</p>
<p>端口的BPDU报文老化时间，可在根桥上通过命令人为改动老化时间。</p>
<p>Max Age通过配置BPDU报文的传输，可保证Max Age在整网中一致。运行STP协议的网络中非根桥设备收到配置BPDU报文后，报文中的Message Age和Max Age会进行比较：</p>
<ul>
<li>如果Message Age小于等于Max Age，则该非根桥设备继续转发配置BPDU报文。</li>
<li>如果Message Age大于Max Age，则该配置BPDU报文将被老化。该非根桥设备直接丢弃该配置BPDU，可认为网络直径过大，导致根桥连接失败。</li>
</ul>
<p>如果配置BPDU是根桥发出的，则Message Age为0。否则，Message Age是从根桥发送到当前桥接收到BPDU的总时间，包括传输延时等。实际实现中，配置BPDU报文经过一个桥，Message Age增加1。</p>
</li>
</ul>
<h2 id="STP报文格式"><a href="#STP报文格式" class="headerlink" title="STP报文格式"></a>STP报文格式</h2><ul>
<li>配置BPDU是一种心跳报文，只要端口使能STP，则配置BPDU就会按照Hello Time定时器规定的时间间隔从指定端口发出。</li>
<li>TCN BPDU是在设备检测到网络拓扑发生变化时才发出。</li>
</ul>
<p>通常所说的BPDU报文多数指配置BPDU。</p>
<p>在初始化过程中，每个桥都主动发送配置BPDU。在网络拓扑稳定以后，每台设备的指定端口都会周期性的发送配置BPDU。配置BPDU的长度至少要35个字节，包含了桥ID、路径开销和端口ID等参数。只有当发送者的BID或端口的PID两个字段中至少有一个和本桥接收端口不同，BPDU报文才会被处理，否则丢弃。这样避免了处理和本端口信息一致的BPDU报文。</p>
<p>配置BPDU在以下3种情况下会产生：</p>
<ul>
<li>只要端口使能STP，则配置BPDU就会按照Hello Time定时器规定的时间间隔从指定端口发出。</li>
<li>当根端口收到配置BPDU时，如果优先级比自己的配置BPDU高，则会根据收到的配置BPDU中携带的信息更新自己STP端口存储的配置BPDU信息并从指定接口向下游发送，否则会丢弃该配置BPDU。</li>
<li>当指定端口收到比自己差的配置BPDU时，会立刻向下游设备发送自己的BPDU。</li>
</ul>
<h2 id="STP拓扑变更"><a href="#STP拓扑变更" class="headerlink" title="STP拓扑变更"></a>STP拓扑变更</h2><ol>
<li>在网络拓扑发生变化后，下游设备会不间断地向上游设备发送TCN BPDU报文。</li>
<li>上游设备收到下游设备发来的TCN BPDU报文后，只有指定端口处理TCN BPDU报文。其它端口也有可能收到TCN BPDU报文，但不会处理。</li>
<li>上游设备会把配置BPDU报文中的Flags的TCA位设置1，然后发送给下游设备，告知下游设备停止发送TCN BPDU报文。</li>
<li>上游设备复制一份TCN BPDU报文，向根桥方向发送。</li>
<li>重复步骤1、2、3、4，直到根桥收到TCN BPDU报文。</li>
<li>根桥把配置BPDU报文中的Flags的TC位置1后发送，通知下游设备直接删除桥MAC地址表项。</li>
</ol>
<p>详情请看<a href="https://www.yangzhiyu.top/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/">STP拓扑变更机制 | 沃德发 (yangzhiyu.top)</a></p>
<h2 id="STP故障收敛时间"><a href="#STP故障收敛时间" class="headerlink" title="STP故障收敛时间"></a>STP故障收敛时间</h2><p><img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ%E6%88%AA%E5%9B%BE20240529144316.png" alt="QQ截图20240529144316"></p>
<p> sw1的fa0&#x2F;1的接口down了，但是它还是可以从block端口中接收到sw0的bpdu，那么它与root的联系就没有断开，它此时做的操作是根据根桥发送的bpdu重新计算根端口，然后经历<strong>30s</strong>的收敛，将fa0&#x2F;2变为根端口。</p>
<p><img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ%E6%88%AA%E5%9B%BE20240529144351.png" alt="QQ截图20240529144351"></p>
<p>sw2的fa0&#x2F;2断开down了，我们知道block端口时不会对bpdu进行发送的，于是fa0&#x2F;1就相当于与root断开了，一段时间后，他就会从fa0&#x2F;1发送自己是根桥的bpdu，但是sw1是不会理睬的，因为它知道sw0的bpdu才是最好的，因为sw0的bpdu中的根桥ID的优先级是最高的， 经过20s后，sw1的fa0&#x2F;2因为没有从swfa0&#x2F;1上接收到bpdu，所以它会将端口转换为指定端口将bpdu信息进行转发，这个过程大概50s。</p>
<h1 id="RSTP"><a href="#RSTP" class="headerlink" title="RSTP"></a>RSTP</h1><p>IEEE于2001年发布的802.1w标准定义了快速生成树协议RSTP（Rapid Spanning Tree Protocol），该协议基于STP协议，对原有的STP协议进行了更加细致的修改和补充。</p>
<p>STP协议虽然能够解决环路问题，但是由于网络拓扑收敛慢，影响了用户通信质量。如果网络中的拓扑结构频繁变化，网络也会随之频繁失去连通性，从而导致用户通信频繁中断，这是用户无法忍受的。</p>
<p>STP的不足之处如下：</p>
<ul>
<li><p>STP没有细致区分端口状态和端口角色，不利于初学者学习及部署。</p>
<p>网络协议的优劣往往取决于协议是否对各种情况加以细致区分。</p>
<ul>
<li><p>从用户角度来讲，Listening、Learning和Blocking状态并没有区别，都同样不转发用户流量。</p>
</li>
<li><p>从使用和配置角度来讲，端口之间最本质的区别并不在于端口状态，而是在于端口扮演的角色。</p>
<p>根端口和指定端口可以都处于Listening状态，也可能都处于Forwarding状态。</p>
</li>
</ul>
</li>
<li><p>STP算法是被动的算法，<strong>依赖定时器</strong>等待的方式判断拓扑变化，收敛速度慢。</p>
</li>
<li><p>STP算法要求在稳定的拓扑中，根桥主动发出配置BPDU报文，而其他设备进行处理，传遍整个STP网络。</p>
<p>这也是导致拓扑收敛慢的主要原因之一。</p>
</li>
</ul>
<h2 id="端口角色改进"><a href="#端口角色改进" class="headerlink" title="端口角色改进"></a>端口角色改进</h2><p>根据STP的不足，RSTP删除了3种端口状态，新增加了2种端口角色</p>
<p>RSTP的端口角色共有4种：根端口、指定端口、Alternate端口和Backup端口。</p>
<ul>
<li><p>从配置BPDU报文发送角度来看：</p>
<ul>
<li>Alternate端口就是由于学习到其它网桥发送的配置BPDU报文而阻塞的端口。</li>
<li>Backup端口就是由于学习到自己发送的配置BPDU报文而阻塞的端口。</li>
</ul>
</li>
<li><p>从用户流量角度来看：</p>
<ul>
<li>Alternate端口提供了从指定桥到根的另一条可切换路径，作为根端口的备份端口。</li>
<li>Backup端口作为指定端口的备份，提供了另一条从根桥到相应网段的备份通路。</li>
</ul>
<p>给一个RSTP域内所有端口分配角色的过程就是整个拓扑收敛的过程。</p>
</li>
</ul>
<h2 id="端口状态改进"><a href="#端口状态改进" class="headerlink" title="端口状态改进"></a>端口状态改进</h2><p>RSTP的状态规范把原来的5种状态缩减为3种。根据端口是否转发用户流量和学习MAC地址来划分:</p>
<ul>
<li>如果不转发用户流量也不学习MAC地址，那么端口状态就是Discarding状态。</li>
<li>如果不转发用户流量但是学习MAC地址，那么端口状态就是Learning状态。</li>
<li>如果既转发用户流量又学习MAC地址，那么端口状态就是Forwarding状态。</li>
</ul>
<table>
<thead>
<tr>
<th>STP端口状态</th>
<th>RSTP端口状态</th>
<th>端口在拓扑中的角色</th>
</tr>
</thead>
<tbody><tr>
<td>Forwarding</td>
<td>Forwarding</td>
<td>包括根端口、指定端口</td>
</tr>
<tr>
<td>Learning</td>
<td>Learning</td>
<td>包括根端口、指定端口</td>
</tr>
<tr>
<td>Listening</td>
<td>Discarding</td>
<td>包括根端口、指定端口</td>
</tr>
<tr>
<td>Blocking</td>
<td>Discarding</td>
<td>包括Alternate端口、Backup端口</td>
</tr>
<tr>
<td>Disabled</td>
<td>Discarding</td>
<td>包括Disable端口</td>
</tr>
</tbody></table>
<h2 id="配置BPDU-RST-BPDU"><a href="#配置BPDU-RST-BPDU" class="headerlink" title="配置BPDU-RST BPDU"></a>配置BPDU-RST BPDU</h2><img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240727180230.png" alt="QQ截图20240727180230" style="zoom:67%;">

<h2 id="配置BPDU的处理"><a href="#配置BPDU的处理" class="headerlink" title="配置BPDU的处理"></a>配置BPDU的处理</h2><ul>
<li><p>拓扑稳定后，配置BPDU报文的发送方式</p>
<p>拓扑稳定后，根桥按照Hello Timer规定的时间间隔发送配置BPDU。其他非根桥设备在收到上游设备发送过来的配置BPDU后，才会触发发出配置BPDU，此方式使得STP协议计算复杂且缓慢。</p>
<p>RSTP对此进行了改进，即在拓扑稳定后，无论非根桥设备是否接收到根桥传来的配置BPDU报文，非根桥设备仍然按照Hello Timer规定的时间间隔发送配置BPDU，该行为完全由每台设备自主进行。</p>
</li>
<li><p>更短的BPDU超时计时（6s）</p>
<p>如果一个端口在超时时间（超时时间＝Hello Time × 3 × Timer Factor）内没有收到上游设备发送过来的配置BPDU，那么该设备认为与此邻居之间的协商失败。而不像STP那样需要先等待一个Max Age。</p>
</li>
<li><p>处理次等BPDU</p>
<p> STP只有指定端口会立即处理次优BPDU，其他端口会忽略次优BPDU，等到Max Age 计时器超时后，缓存的次优BPDU才会老化，然后发送自身更优的BPDU，进行新一轮 的拓扑收敛。</p>
<p>当一个端口收到上游的指定桥发来的RST BPDU报文时，该端口会将自身存储的RST BPDU与收到的RST BPDU进行比较。</p>
<p>如果该端口存储的RST BPDU的优先级高于收到的RST BPDU，那么该端口会直接丢弃收到的RST BPDU，立即回应自身存储的RST BPDU。当上游设备收到下游设备回应的RST BPDU后，上游设备会根据收到的RST BPDU报文中相应的字段立即更新自己存储的RST BPDU。</p>
<p>由此，RSTP处理次等BPDU报文不再依赖于任何定时器通过超时解决拓扑收敛，从而加快了拓扑收敛。</p>
</li>
</ul>
<h2 id="快速收敛（端口切换）"><a href="#快速收敛（端口切换）" class="headerlink" title="快速收敛（端口切换）"></a>快速收敛（端口切换）</h2><p>如果网络中一个根端口失效，那么网络中最优的 Alternate端口将成为根端口，进入Forwarding状态。 因为通过这个Alternate端口连接的网段上必然有个指 定端口可以通往根桥。</p>
<p>如果网络中一指定端口失效，那么网络中最优的 Backup端口将成为指定端口，进入Forwarding状态。 因为Backup端口作为指定端口的备份，提供了另一 条从根桥到相应网段的备份通路。</p>
<h2 id="快速收敛（边缘端口）"><a href="#快速收敛（边缘端口）" class="headerlink" title="快速收敛（边缘端口）"></a>快速收敛（边缘端口）</h2><p>• 在RSTP里面，如果某一个端口位于整个网络的边 缘，即不再与其他交换设备连接，而是直接与终 端设备直连，这种端口可以设置为边缘端口。</p>
<p>• 边缘端口不参与RSTP计算，可以由Discarding直 接进入Forwarding状态。</p>
<p> • 但是一旦边缘端口收到配置BPDU，就丧失了边 缘端口属性，成为普通STP端口，并重新进行生 成树计算，从而引起网络震荡。</p>
<h2 id="快速收敛（P-A机制）"><a href="#快速收敛（P-A机制）" class="headerlink" title="快速收敛（P&#x2F;A机制）"></a>快速收敛（P&#x2F;A机制）</h2><p> 事实上对于STP，指定端口的选择可以很快完成，主要的速度瓶颈在于：为了避免环路，必 须等待足够长的时间，使全网的端口状态全部确定，也就是说必须要等待至少一个Forward  Delay所有端口才能进行转发。</p>
<p>  而RSTP的主要目的就是消除这个瓶颈，通过阻塞自己的非根端口来保证不会出现环路。而 使用P&#x2F;A机制加快了上游端口进入Forwarding状态的速度。</p>
<p>当一个端口被选举成为指定端口之后，在STP中，该端口至少要等待一个Forward Delay（Learning）时间才会迁移到Forwarding状态。而在RSTP中，此端口会先进入Discarding状态，再通过Proposal&#x2F;Agreement机制快速进入Forward状态。这种机制必须在点到点全双工链路上使用。Proposal&#x2F;Agreement机制简称P&#x2F;A机制</p>
<p>Proposal&#x2F;Agreement机制，其目的是使一个指定端口尽快进入Forwarding状态。如图所示，根桥S1和S2之间新添加了一条链路。在当前状态下，S2的另外几个端口p2是Alternate端口，p3是指定端口且处于Forwarding状态，p4是边缘端口。</p>
<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529151927.png" alt="QQ截图20240529151927" style="zoom:67%;">

<p>新链路连接成功后，P&#x2F;A机制协商过程如下：</p>
<ol>
<li>p0和p1两个端口马上都先成为指定端口，发送RST BPDU。</li>
<li>S2的p1口收到更优的RST BPDU，马上意识到自己将成为根端口，而不是指定端口，停止发送RST BPDU。</li>
<li>S1的p0进入Discarding状态，于是发送的RST BPDU中把proposal置1。</li>
<li>S2收到根桥发送来的携带proposal的RST BPDU，开始将自己的所有端口进入sync变量置位。</li>
<li>p2已经阻塞，状态不变；p4是边缘端口，不参与运算；所以只需要阻塞非边缘指定端口p3。</li>
<li>各端口的synced变量置位后，p2、p3进入Discarding状态，p1进入Forwarding状态并向S1返回Agreement位置位的回应RST BPDU。</li>
<li>当S1判断出这是对刚刚发出的Proposal的回应，于是端口p0马上进入Forwarding状态。</li>
</ol>
<p>下游设备继续执行P&#x2F;A协商过程。</p>
<p>要成功进行PA快速协商机制只会出现在上<strong>边DP下边RP的情况下</strong>。首先两台设备比BPDU确定谁是上游DP，谁是下游RP（或AP）。所谓P&#x2F;A机制，就是在这个过程以后，上游DP捉急要进入转发状态，这才向下发P置位BPDU的请求。P&#x2F;A协商根本目的就是为了加快某DP端口和RP端口互联链路上两端口快速进入转发状态而无需等30s（2倍forwarding delay ）。</p>
<p><strong>注：如果下游的接口并未被选举为RP而只是个普通AP怎么办？</strong><br>如果下游设备发现这个接口收到的BPDU没其他某个接口（如现存的RP接口）收到的BPDU优先则下游设备会认为这个接口角色应为AP接口而不是RP。则该(AP)接口就不会去回应上游发送A置位BPDU而只发送普通BPDU。这样上游会一直每两秒发一个P置位BPDU，下游一直不响应A置位BPDU。直到等待1个forwarding delay后该上游DP才会由discarding变为learning状态，再等一个forwarding delay后上游DP才会变为forwarding状态</p>
<h2 id="保护功能"><a href="#保护功能" class="headerlink" title="保护功能"></a>保护功能</h2><table>
<thead>
<tr>
<th>保护功能</th>
<th>场景</th>
<th>原理</th>
</tr>
</thead>
<tbody><tr>
<td>BPDU保护</td>
<td>在交换设备上，通常将直接与用户终端（如PC机）或文件服务器等非交换设备相连的端口配置为边缘端口。正常情况下，边缘端口不会收到RST BPDU。如果有人伪造RST BPDU恶意攻击交换设备，当边缘端口接收到RST BPDU时，交换设备会自动将边缘端口设置为非边缘端口，并重新进行生成树计算，从而引起网络震荡。</td>
<td>交换设备上启动了BPDU保护功能后，如果边缘端口收到RST BPDU，边缘端口将被error-down，但是边缘端口属性不变，同时通知网管系统。</td>
</tr>
<tr>
<td>根保护</td>
<td>由于维护人员的错误配置或网络中的恶意攻击，网络中合法根桥有可能会收到优先级更高的RST BPDU，使得合法根桥失去根地位，从而引起网络拓扑结构的错误变动。这种不合法的拓扑变化，会导致原来应该通过高速链路的流量被牵引到低速链路上，造成网络拥塞。</td>
<td>对于启用Root保护功能的指定端口，其端口角色只能保持为指定端口。一旦启用Root保护功能的指定端口收到优先级更高的RST BPDU时，端口状态将进入Discarding状态，不再转发报文。在经过一段时间（通常为两倍的Forward Delay），如果端口一直没有再收到优先级较高的RST BPDU，端口会自动恢复到正常的Forwarding状态。<strong>说明：</strong>Root保护功能只能在指定端口上配置生效。</td>
</tr>
<tr>
<td>环路保护</td>
<td>在运行RSTP协议的网络中，根端口和其他阻塞端口状态是依靠不断接收来自上游交换设备的RST BPDU维持。当由于链路拥塞或者单向链路故障导致这些端口收不到来自上游交换设备的RST BPDU时，此时交换设备会重新选择根端口。原先的根端口会转变为指定端口，而原先的阻塞端口会迁移到转发状态，从而造成交换网络中可能产生环路。</td>
<td>在启动了环路保护功能后，如果根端口或Alternate端口长时间收不到来自上游的RST BPDU时，则向网管发出通知信息（如果是根端口则进入Discarding状态）。而阻塞端口则会一直保持在阻塞状态，不转发报文，从而不会在网络中形成环路。直到根端口或Alternate端口收到RST BPDU，端口状态才恢复正常到Forwarding状态。<strong>说明：</strong>环路保护功能只能在根端口或Alternate端口上配置生效。</td>
</tr>
<tr>
<td>防TC-BPDU攻击</td>
<td>交换设备在接收到TC BPDU报文后，会执行MAC地址表项和ARP表项的删除操作。如果有人伪造TC BPDU报文恶意攻击交换设备时，交换设备短时间内会收到很多TC BPDU报文，频繁的删除操作会给设备造成很大的负担，给网络的稳定带来很大隐患。</td>
<td>启用防TC-BPDU报文攻击功能后，在单位时间内，交换设备处理TC BPDU报文的次数可配置。如果在单位时间内，交换设备在收到TC BPDU报文数量大于配置的阈值，那么设备只会处理阈值指定的次数。对于其他超出阈值的TC BPDU报文，定时器到期后设备只对其统一处理一次。这样可以避免频繁的删除MAC地址表项和ARP表项，从而达到保护设备的目的。</td>
</tr>
</tbody></table>
<h2 id="RSTP拓扑变更"><a href="#RSTP拓扑变更" class="headerlink" title="RSTP拓扑变更"></a>RSTP拓扑变更</h2><p>判断拓扑变化唯一标准：一个非边缘端口迁移到Forwarding状态<br>为本交换设备的所有非边缘指定端口启动一个TC While Timer，该计时器值是H<strong>ello Time的两倍</strong>。在这个时间内，清空状态发生变化的端口上学习到的MAC地址。同时，由这些端口向外发送RST BPDU，其中TC置位。一旦TC While Timer超时，则停止发送RST BPDU。<br>其他交换设备接收到RST BPDU后，清空所有端口学习到MAC地址，<strong>除了收到RST BPDU的端口</strong>。然后也为自己所有的非边缘指定端口和根端口启动TC While Timer，重复上述过程。 如此，网络中就会产生RST BPDU的泛洪。 </p>
<p><img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/1580705-20200812101447639-1540837884.png" alt="1580705-20200812101447639-1540837884"></p>
<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529153721.png" alt="QQ截图20240529153721" style="zoom:67%;">

<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529153729.png" alt="QQ截图20240529153729" style="zoom:67%;">

<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529153735.png" alt="QQ截图20240529153735" style="zoom:67%;">

<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529153742.png" alt="QQ截图20240529153742" style="zoom:67%;">

<img src="/2024/05/29/STP-RSTP-MSTP%E6%80%BB%E7%BB%93/QQ截图20240529153750.png" alt="QQ截图20240529153750" style="zoom:67%;">
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>STP</tag>
        <tag>RSTP</tag>
        <tag>MSTP</tag>
      </tags>
  </entry>
  <entry>
    <title>STP拓扑变更机制</title>
    <url>/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="为什么要有STP拓扑变化机制"><a href="#为什么要有STP拓扑变化机制" class="headerlink" title="为什么要有STP拓扑变化机制"></a>为什么要有STP拓扑变化机制</h1><p>网络中发生拓扑变化时，例如链路中断或接口异常Down等情况，由于MAC地址老化时间的存在（缺省为5分钟），如果不及时通知上游设备，则可能会导致上游设备的报文在这段时间内一直向一个不可达的链路发送。</p>
<h5 id="拓扑改变导致MAC地址表错误"><a href="#拓扑改变导致MAC地址表错误" class="headerlink" title="拓扑改变导致MAC地址表错误"></a>拓扑改变导致MAC地址表错误</h5><p><img src="/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/1stp3434.png" alt="1stp3434"></p>
<p> 本例中，SW3中的MAC地址表项定义了通过端口GigabitEthernet 0&#x2F;0&#x2F;2可以到达主机1，通过端口GigabitEthernet 0&#x2F;0&#x2F;3可以到达主机2。由于SW2的根端口产生故障，导致生成树拓扑重新收敛，在生成树拓扑完成收敛之后，从主机1到主机2的帧仍然不能到达目的地。这是因为MAC地址表项老化时间是300秒，主机2发往主机1的帧到达SW3后，SW3会继续通过端口GigabitEthernet 0&#x2F;0&#x2F;2转发该数据帧。那么该怎么快速恢复转发？</p>
<p><img src="/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/2stp821462.png" alt="2stp821462"></p>
<p>   拓扑变更以及MAC地址表项更新的具体过程如下：</p>
<p>SW2感知到网络拓扑发生变化后，会立即向SW3发送TCN BPDU报文。<br>SW3收到SW2发来的TCN BPDU报文后，会把配置BPDU报文中的Flags的TCA位设置1，然后发送给SW2，告知SW2我已经收到你发送的TCN BPDU。<br>SW3向根桥转发TCN BPDU报文。<br>SW1把配置BPDU报文中的Flags的TC位和TCA位设置为1后发送，通知下游设备我已经收到你发送的TCN BPDU，并通知下游交换机把MAC地址表项的老化时间由默认的300 s修改为Forward Delay的时间（默认为15 s），之后会持续不断的发送TC bit &#x3D; 1的BPDU持续35s。<br>最多等待15 s之后，SW3中的错误MAC地址表项会被自动清除。此后，SW3就能重新开始MAC表项的学习及转发操作。</p>
<p>说明：</p>
<ul>
<li>TCN BPDU报文主要用来向上游设备乃至根桥通知拓扑变化。</li>
<li>TCA标记置位的配置BPDU报文主要是上游设备用来告知下游设备已经知道拓扑变化，通知下游设备停止发送TCN BPDU报文。</li>
<li>置位的TC标记的配置BPDU报文主要是上游设备用来告知下游设备拓扑发生变化，请下游设备直接删除桥MAC地址表项，从而达到快速收敛的目的。</li>
</ul>
<h5 id="感知拓扑改变"><a href="#感知拓扑改变" class="headerlink" title="感知拓扑改变"></a>感知拓扑改变</h5><p>什么情况下STP会感知到拓扑发生了改变呢？有下面四种！</p>
<p>（1）当DP端口进入到Forwarding状态认为拓扑发生了改变。</p>
<p><img src="/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/bian1014293.png" alt="bian1014293"></p>
<p>如上图当S2的g0&#x2F;0&#x2F;3接口(与主机直接相连的接口都是DP端口)经过大概30s进入到Forwarding状态之后，S2的RP端口会立即向根桥发送一个TCN BPDU告知根桥拓扑发生了改变，根桥也会向S2交换机回复一个TC bit &#x3D; 1和TCA bit &#x3D; 1的BPDU，并且根桥会将TC bit &#x3D; 1的报文泛洪到全网交换机，持续35s。 S3的DP接口从shutdown重新进入到Forwarding状态与此情况类似。</p>
<p>（2）根桥的DP失效直接发送TC BPDU。<br><img src="/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/bian272946542.png" alt="bian272946542"></p>
<p> 如上图，当根桥的DP失效之后，S3交换机的RP也随即失效，DP立即成为RP并向S2的AP持续不断的发送TCN BPDU。当S2的AP经过大概30s进入到Forwarding状态之后会向S3的DP回复一个TCA bit &#x3D; 1的BPDU，告知S3我已收到你发送的TCN BPDU并且通过自己的RP将TCN BPDU发送给根桥，根桥也会向S2交换机回复一个TC bit &#x3D; 1和TCA bit &#x3D; 1的BPDU，并且根桥会将TC bit &#x3D; 1的报文泛洪到全网交换机持续35s。</p>
<p>(3)RP失效或者RP进入到Forwarding状态。<br>        S3的RP失效其实等同于根桥的DP失效导致S3的RP失效。S2的RP失效等同于 1.拓扑改变导致MAC地址表错误。<br>(4)非根桥的DP端口失效不认为拓扑发生了改变。<br><img src="/2024/05/08/STP%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4%E6%9C%BA%E5%88%B6/bian44841788.png" alt="bian44841788"></p>
<p>如上图两种情况，非根桥的DP失效都不会认为拓扑发生了改变。</p>
<p>总结：<strong>stp发生拓扑变更的条件</strong>：<br>1、处于转发状态或者监听状态的端口过渡到阻塞状态，这个状态通常是链路故障<br>2、处于未启用状态的端口进入转发状态，这个状态通常是增加了新的链路<br>3、交换机从指定端口收到TCNBPDU报文。</p>
<p><strong>stp缺点</strong>：1.收敛速度慢，故障切换时间太长（30-50秒）2.网络中大量主机频繁上下线，会导致TCN BPDU大量发送，导致Mac地址表不稳定</p>
<h1 id="RSTP对STP的改进："><a href="#RSTP对STP的改进：" class="headerlink" title="RSTP对STP的改进："></a>RSTP对STP的改进：</h1><ul>
<li>RSTP对STP的改进：<ul>
<li>通过端口角色的增补，简化了生成树协议的理解及部署；</li>
<li>端口状态的重新划分；</li>
<li>配置BPDU格式的改变，充分利用了STP协议报文中的Flag字段，明确了端口角色；</li>
<li>配置BPDU的处理发生变化；</li>
<li>快速收敛；</li>
<li>增加保护功能。</li>
</ul>
</li>
</ul>
<h5 id="改进点1：端口角色的改进："><a href="#改进点1：端口角色的改进：" class="headerlink" title="改进点1：端口角色的改进："></a>改进点1：端口角色的改进：</h5><p>RSTP的端口角色共有4种：根端口、指定端口、Alternate端口和Backup端口。</p>
<p> 根端口和指定端口的作用同STP中定义，Alternate端口和Backup端口的描述如下：  </p>
<ul>
<li>从配置BPDU报文发送角度来看：<ul>
<li>Alternate端口就是由于学习到其它网桥发送的配置BPDU报文而阻塞的端口</li>
<li>Backup端口就是由于学习到自己发送的配置BPDU报文而阻塞的端口</li>
</ul>
</li>
<li>从用户流量角度来看：<ul>
<li>Alternate端口提供了从指定桥到根的另一条可切换路径，作为根端口的备份端口</li>
<li>Backup端口作为指定端口的备份，提供了另一条从根桥到相应网段的备份通路</li>
</ul>
</li>
</ul>
<blockquote>
<p> 给一个RSTP域内所有端口分配角色的过程就是整个拓扑收敛的过程 </p>
</blockquote>
<h5 id="改进点2：端口状态的改进"><a href="#改进点2：端口状态的改进" class="headerlink" title="改进点2：端口状态的改进"></a>改进点2：端口状态的改进</h5><p>RSTP的状态规范缩减为3种，根据端口是否转发用户流量和学习MAC地址来划分:</p>
<ul>
<li>Discarding状态：不转发用户流量也不学习MAC地址</li>
<li>Learning状态：不转发用户流量但是学习MAC地址</li>
<li>Forwarding状：既转发用户流量又学习MAC地址。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">STP端口状态</th>
<th align="left">RSTP端口状态</th>
<th align="left">端口在拓扑中的角色</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Forwarding</td>
<td align="left">Forwarding</td>
<td align="left">包括根端口、指定端口</td>
</tr>
<tr>
<td align="left">Learning</td>
<td align="left">Learning</td>
<td align="left">包括根端口、指定端口</td>
</tr>
<tr>
<td align="left">Listening</td>
<td align="left">Discarding</td>
<td align="left">包括根端口、指定端口</td>
</tr>
<tr>
<td align="left">Blocking</td>
<td align="left">Discarding</td>
<td align="left">包括Alternate端口、Backup端口</td>
</tr>
<tr>
<td align="left">Disabled</td>
<td align="left">Discarding</td>
<td align="left">包括Disable端口</td>
</tr>
</tbody></table>
<h5 id="改进点3：配置BPDU-RST-BPDU"><a href="#改进点3：配置BPDU-RST-BPDU" class="headerlink" title="改进点3：配置BPDU - RST BPDU"></a>改进点3：配置BPDU - RST BPDU</h5><p><strong>RSTP的配置BPDU充分利用了STP报文中的Flag字段，明确了端口角色</strong></p>
<ul>
<li>除了保证和STP格式基本一致之外，RSTP作了如下变化：<ul>
<li>Type字段：配置BPDU类型不再是0而是2，所以运行STP的设备收到RSTP的配置BPDU时会丢弃</li>
<li>Flag字段：使用了原来保留的中间6位，这样改变的配置BPDU叫做RST BPDU</li>
</ul>
</li>
</ul>
<h6 id="RST-BPDU报文格式："><a href="#RST-BPDU报文格式：" class="headerlink" title="RST BPDU报文格式："></a>RST BPDU报文格式：</h6><h6 id="RST-BPDU与STP配置BPDU报文格式不同点"><a href="#RST-BPDU与STP配置BPDU报文格式不同点" class="headerlink" title="RST BPDU与STP配置BPDU报文格式不同点"></a>RST BPDU与STP配置BPDU报文格式不同点</h6><ul>
<li>BPDU类型，1 Byte，RST BPDU的类型值为0x02。</li>
<li>标志，1 Byte，包括：<ul>
<li>bit 7：TCA，表示拓扑变化确认；</li>
<li>bit 6：Agreement，表示同意，用于P&#x2F;A机制；</li>
<li>bit 5：Forwarding，表示转发状态；</li>
<li>bit 4：Learning，表示学习状态；</li>
<li>bit 3和bit 2：表示端口角色, 00表示未知端口, 01表示替代或备份端口, 10表示根端口, 11表示指定端口</li>
<li>bit 1：Proposal，表示提议，用于P&#x2F;A机制；</li>
<li>bit 0：TC，表示拓扑变化。</li>
</ul>
</li>
</ul>
<h5 id="改进点4：配置BPDU的处理"><a href="#改进点4：配置BPDU的处理" class="headerlink" title="改进点4：配置BPDU的处理"></a>改进点4：配置BPDU的处理</h5><h6 id="RSTP对配置BPDU的发送方式进行了改进"><a href="#RSTP对配置BPDU的发送方式进行了改进" class="headerlink" title="RSTP对配置BPDU的发送方式进行了改进"></a>RSTP对配置BPDU的发送方式进行了改进</h6><blockquote>
<p> 在拓扑稳定后，无论非根桥设备是否接收到根桥传来的配置BPDU报文，非根桥设备仍然按照Hello Time规定的时间间隔发送配置BPDU，该行为完全由每台设备自主进行 </p>
</blockquote>
<h6 id="更短的BPDU超时时间"><a href="#更短的BPDU超时时间" class="headerlink" title="更短的BPDU超时时间"></a>更短的BPDU超时时间</h6><p>如果一个端口在超时时间（即三个周期，超时时间＝Hello Time×3）内没有收到上游设备发送过来的配置BPDU，那么该设备认为与此邻居之间的协商失败</p>
<blockquote>
<p> STP需要先等待一个Max Age </p>
</blockquote>
<h6 id="处理次优BPDU"><a href="#处理次优BPDU" class="headerlink" title="处理次优BPDU"></a>处理次优BPDU</h6><p>当一个端口收到上游的指定桥发来的RST BPDU报文时，该端口会将自身缓存的RST BPDU与收到的RST BPDU进行比较如果该端口缓存的RST BPDU优于收到的RST BPDU，那么该端口会直接丢弃收到的RST BPDU，立即回应自身缓存的RST BPDU，从而加快收敛速度</p>
<ul>
<li>STP：      STP只有指定端口会立即处理次优BPDU，其他端口会忽略次优BPDU，等到Max Age计时器超时后，缓存的次优BPDU才会老化，然后发送自身更优的BPDU，进行新一轮的拓扑收敛。 </li>
<li>RSTP：   RSTP处理次优BPDU报文不再依赖于任何定时器，解决拓扑收敛，同时RSTP的任何端口角色都会处理次优BPDU，从而加快了拓扑收敛。</li>
</ul>
<h5 id="改进点5：快速收敛机制"><a href="#改进点5：快速收敛机制" class="headerlink" title="改进点5：快速收敛机制"></a>改进点5：快速收敛机制</h5><h6 id="快速收敛机制："><a href="#快速收敛机制：" class="headerlink" title="快速收敛机制："></a>快速收敛机制：</h6><ul>
<li>如果网络中一个根端口失效，那么网络中最优的Alternate端口将成为根端口，进入Forwarding状态。因为通过这个Alternate端口连接的网段上必然有个指定端口可以通往根桥 </li>
<li>如果网络中一指定端口失效，那么网络中最优的Backup端口将成为指定端口，进入Forwarding状态。因为Backup端口作为指定端口的备份，提供了另一条从根桥到相应网段的备份通路</li>
</ul>
<p> ##### 边缘端口 (Edge Port)机制：  </p>
<blockquote>
<p> 在RSTP里面，如果某一个端口位于整个网络的边缘，即不再与其他交换设备连接，而是直接与终端设备直连，这种端口可以设置为边缘端口 </p>
</blockquote>
<p>边缘端口不参与RSTP计算，可以由Discarding直接进入Forwarding状态，同时边缘端口的UP和Down，不会引起网络拓扑的变动</p>
<p>但是一旦边缘端口收到配置BPDU，就丧失了边缘端口属性，成为普通STP端口，并重新进行生成树计算，从而引起网络震荡</p>
<h6 id="Proposal-Agreement机制："><a href="#Proposal-Agreement机制：" class="headerlink" title="Proposal&#x2F;Agreement机制："></a>Proposal&#x2F;Agreement机制：</h6><p>简称P&#x2F;A机制，RSTP通过P&#x2F;A机制加快了上游端口进入Forwarding状态的速度。 当一个端口被选举成为指定端口之后,会先进入Discarding状态，再通过P&#x2F;A机制快速进入Forwarding状态</p>
<p>事实上对于STP，指定端口的选择可以很快完成，主要的速度瓶颈在于：为了避免环路，必须等待足够长的时间，使全网的端口状态全部确定，也就是说必须要等待至少一个Forward Delay所有端口才能进行转发。 而RSTP的主要目的就是消除这个瓶颈，通过阻塞自己的非根端口来保证不会出现环路。而使用P&#x2F;A机制加快了上游端口进入Forwarding状态的速度。</p>
<h5 id="改进点6：拓扑变更机制"><a href="#改进点6：拓扑变更机制" class="headerlink" title="改进点6：拓扑变更机制"></a>改进点6：拓扑变更机制</h5><p>在RSTP中检测拓扑是否发生变化只有一个标准：一个非边缘端口迁移到Forwarding状态。</p>
<p>一旦检测到拓扑发生变化，将进行如下处理： 为本交换设备的所有非边缘指定端口和根端口启动一个TC While Timer，该计时器值是Hello Time的两倍。在这个时间内，清空状态发生变化的端口上学习到的MAC地址。 同时，由非边缘指定端口和根端口向外发送RST BPDU，其中TC置位。一旦TC While Timer超时，则停止发送RST BPDU。 其他交换设备接收到RST BPDU后，清空所有端口（除了收到RST BPDU的端口和边缘端口）学习到MAC地址，然后也为自己所有的非边缘指定端口和根端口启动TC While Timer，重复上述过程。 如此，网络中就会产生RST BPDU的泛洪。</p>
<h4 id="RSTP与STP的兼容"><a href="#RSTP与STP的兼容" class="headerlink" title="RSTP与STP的兼容"></a>RSTP与STP的兼容</h4><blockquote>
<p> RSTP可以兼容STP：RSTP可以和STP互操作，但是此时会丧失快速收敛等RSTP优势。 </p>
</blockquote>
<p>当一个网段里既有运行STP的交换设备又有运行RSTP的交换设备，STP交换设备会忽略RSTP的BPDU</p>
<p>运行RSTP的交换设备在某端口上接收到运行STP的交换设备发出的配置BPDU，在两个Hello Time时间之后，便把自己的端口转换到STP工作模式，发送配置BPDU，从而实现了互操作。</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>stp拓扑变更</tag>
      </tags>
  </entry>
  <entry>
    <title>USG5500防火墙基础实验</title>
    <url>/2023/12/08/USG5500%E9%98%B2%E7%81%AB%E5%A2%99%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p><img src="/2023/12/08/USG5500%E9%98%B2%E7%81%AB%E5%A2%99%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/usg5500tuopi11.png" alt="usg5500tuopi11"></p>
<p>1、本实验中的防火墙为USG5500系列防火墙； </p>
<p>2、 防火墙三个接口的IP地址按照上图所示进行配置；将这三个接口划入相应的安全域； </p>
<p>3、配置防火墙的域间包过滤策略，使得PC1能够主动访问PC2，但是PC2无法主动访问PC1；PC2能够主动访问WebServer的WEB服务。</p>
<p>防火墙配置：</p>
<p>[FW] interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p>[FW-GigabitEthernet0&#x2F;0&#x2F;1] ip address 192.168.1.254 24 </p>
<p>[FW] interface GigabitEthernet0&#x2F;0&#x2F;2 </p>
<p>[FW-GigabitEthernet0&#x2F;0&#x2F;2] ip address 172.16.1.254 24 </p>
<p>[FW] interface GigabitEthernet0&#x2F;0&#x2F;3 </p>
<p>[FW-GigabitEthernet0&#x2F;0&#x2F;3] ip address 10.1.1.254 24 </p>
<p>将接口添加到相应的安全区域：</p>
<p>[FW] firewall zone trust </p>
<p>[FW-zone-trust] add interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p>[FW] firewall zone dmz </p>
<p>[FW-zone-dmz] add interface GigabitEthernet0&#x2F;0&#x2F;2 </p>
<p>[FW] firewall zone untrust </p>
<p>[FW-zone-untrust] add interface GigabitEthernet0&#x2F;0&#x2F;3 </p>
<p>配置域间策略，使得trust域的192.168.1.0&#x2F;24网段用户能够访问untrust区域的10.1.1.0&#x2F;24网段</p>
<p>[FW] policy interzone trust untrust outbound </p>
<p>[FW-policy-interzone-trust-untrust-outbound] policy 10 </p>
<p>[FW-policy-interzone-trust-untrust-outbound-10] policy destination 10.1.1.0 </p>
<p>0.0.0.255 </p>
<p>[FW-policy-interzone-trust-untrust-outbound-10] policy source 192.168.1.0 </p>
<p>0.0.0.255 </p>
<p>[FW-policy-interzone-trust-untrust-outbound-10] action permit </p>
<p>配置域间策略，使得untrust可以访问server</p>
<p>[FW] policy interzone dmz untrust inbound </p>
<p>[FW-policy-interzone-dmz-untrust-inbound] policy 10 </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] policy source 10.1.1.0 0.0.0.255 </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] policy destination 172.16.1.1 0 </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] policy service service-set http </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] action permit </p>
<p>完成上述配置后，PC1即可主动发起访问PC2，而PC2无法主动访问PC1；另外，PC2能够访问WebServer的HTTP服务</p>
<p>（ping不同，需要再配置一条允许icmp协议通过）</p>
<p>通过命令display zone，可以查看防火墙的安全区域、安全等级，以及每个安全区域下的接口.</p>
<p>使用<strong>display firewall packet-filter default</strong> 命令，能查看防火墙的缺省安全策略。当数据包经过防火墙且从一个安全域试图访问另一个安全域时，防火墙会根据数据包的流向首先检查用户定义的policy interzone，如果没有自定义的policy interone，则会看根据防火墙的缺省安全策略进行处理。例如从上面的显示中，我们可以看到local-trust的inbound及outbound都是permit，因此即使我们没有显式的配置local及trust安全区域的区域间策略，但是由于默认的策略就是放行，所以 trust区域的用户可以直接ping通防火墙的接口。</p>
<p>如果要让防火墙默认放行所有域间的流量，可以使用：firewall packet-filter default permit all命令，值得注意的是，在网络正式投入现网使用之前，此命令必须关闭（firewall packet-filter default deny all），针对需要放行的流量，需通过policy interzone的配置来放行，而不能鲁莽地将所有流量统统放行。</p>
<p>使用display policy命令，能查看我们定义的区域间安全策略，例如： </p>
<p>[FW] display policy interzone trust untrust outbound </p>
<h1 id="USG5500-nat实验"><a href="#USG5500-nat实验" class="headerlink" title="USG5500 nat实验"></a>USG5500 nat实验</h1><p><img src="/2023/12/08/USG5500%E9%98%B2%E7%81%AB%E5%A2%99%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/usg5500naty.png" alt="usg5500naty"></p>
<p>防火墙FW的配置如下：</p>
<p>[FW] interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p>[FW-GigabitEthernet0&#x2F;0&#x2F;1] ip address 192.168.1.254 24 </p>
<p>[FW] interface GigabitEthernet0&#x2F;0&#x2F;2 </p>
<p>[FW-GigabitEthernet0&#x2F;0&#x2F;2] ip address 172.16.1.254 24 </p>
<p>[FW] interface GigabitEthernet0&#x2F;0&#x2F;3 </p>
<p>[FW-GigabitEthernet0&#x2F;0&#x2F;3] ip address 200.1.1.1 24 </p>
<p>向安全域中添加接口</p>
<p>[FW] firewall zone trust </p>
<p>[FW-zone-trust] add interface GigabitEthernet0&#x2F;0&#x2F;1 </p>
<p>[FW] firewall zone dmz </p>
<p>[FW-zone-dmz] add interface GigabitEthernet0&#x2F;0&#x2F;2 </p>
<p>[FW] firewall zone untrust </p>
<p>[FW-zone-untrust] add interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>配置域间包过滤策略，使得trust区域的192.168.1.0&#x2F;24网段用户能够访问Internet：</p>
<p>[FW] policy interzone trust untrust outbound </p>
<p>[FW-policy-interzone-trust-untrust-outbound] policy 10 </p>
<p>[FW-policy-interzone-trust-untrust-outbound-10] policy source 192.168.1.0 </p>
<p>0.0.0.255 </p>
<p>[FW-policy-interzone-trust-untrust-outbound-10] action permit </p>
<p>上述配置虽然放通了192.168.1.0&#x2F;24访问Internet的流量，但是由于192.168.1.0&#x2F;24是私有IP地址，不能直接进入公网，因此为了让这部分用户能够访问公网，还必须部署NAT源地址转换</p>
<p>[FW] nat address-group 1 200.1.1.10 200.1.1.20 </p>
<p>定义NAT地址池，该地址池使用的公网地址区间是200.1.1.10到200.1.1.20</p>
<p>[FW] nat-policy interzone trust untrust outbound </p>
<p>配置NAT策略</p>
<p>[FW-nat-policy-interzone-trust-untrust-outbound] policy 10 </p>
<p>[FW-nat-policy-interzone-trust-untrust-outbound-10] policy source 192.168.1.0  0.0.0.255 </p>
<p>[FW-nat-policy-interzone-trust-untrust-outbound-10] action source-nat &#x2F;&#x2F;对匹配的流量执行源地址转换</p>
<p>[FW-nat-policy-interzone-trust-untrust-outbound-10] address-group 1 &#x2F;&#x2F;关联nat地址池1</p>
<p>完成上述配置后，内网用户PC1即可访问公网用户PC2。接下来继续配置防火墙，使得公网用户PC2能够访问WebServer。 </p>
<p>配置域间包过滤策略，使得untrust区域的Internet用户能够访问DMZ区域的web服务</p>
<p>[FW] policy interzone dmz untrust inbound </p>
<p>[FW-policy-interzone-dmz-untrust-inbound] policy 10 </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] policy destination 172.16.1.1 0 </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] policy service service-set http </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] action permit </p>
<p>[FW-policy-interzone-dmz-untrust-inbound-10] quit </p>
<p>[FW-policy-interzone-dmz-untrust-inbound] quit </p>
<p>完成上述配置后，Internet用户是依然无法访问WebServer的，因为WebServer是私有IP地址，因此还需要配置NAT server，将DMZ域内的WebServer映射到公网。</p>
<p>下面的命令，将内部IP地址172.16.1.1的80端口映射到了公网地址200.1.1.21的80端口，这样一来，当公网用户访问200.1.1.21的80端口服务时，实际上访问的就是内部服务器172.16.1.1的80端口。</p>
<p>[FW] nat server zone untrust protocol tcp global 200.1.1.21 80 inside 172.16.1.1 </p>
<p>80 </p>
<p>完成上述配置后，PC2即可使用目的地址200.1.1.21来访问WebServer。 </p>
<p>当PC1 ping PC2时，能够在FW上能看到如下会话： </p>
<p><FW>display firewall session table </FW></p>
<p>Current Total Sessions : 5 </p>
<p>icmp VPN:public –&gt; public 192.168.1.1:40373[<strong>200.1.1.15:2048</strong>]–&gt;200.1.1.2:2048 </p>
<p>icmp VPN:public –&gt; public 192.168.1.1:40885[200.1.1.15:2049]–&gt;200.1.1.2:2048</p>
<p>留意到中括号内的IP地址，便是被NAT转换后的IP地址。 </p>
<p>当PC2访问Server的WEB服务时，在FW上能看到如下会话： </p>
<p>[FW]display firewall session table </p>
<p>Current Total Sessions : 1 </p>
<p>http VPN:public –&gt; public 200.1.1.2:2055–&gt;200.1.1.21:80[<strong>172.16.1.1:80</strong>] </p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>USG5500</tag>
        <tag>防火墙nat</tag>
      </tags>
  </entry>
  <entry>
    <title>VRF</title>
    <url>/2024/06/23/VRF/</url>
    <content><![CDATA[<p><img src="/2024/06/23/VRF/20190301110350669.png" alt="20190301110350669"></p>
<p><img src="/2024/06/23/VRF/20190301110855304.png" alt="20190301110855304"></p>
<p>假设PC1与R2这一侧的网络属于一个独立的业务；PC2与R3这一侧的网络属于另一个独立的业务，由于设备资源有限或者其他方面的原因，这两个独立的业务的相关节点连接在R1上，也就是同一台设备上。那么在完成相关配置后，R1的路由表如上图所示。<br>现在如果PC1要发一个数据包到2.2.2.2，那么这个数据包在到达R1后，R1就会去查看自己的路由表，发现有一条2.2.2.0&#x2F;24的路由匹配，因此将这个IP包从GE0&#x2F;0&#x2F;2口转发给192.168.100.2。这是没有问题的，然而如果PC1要访问3.3.3.0&#x2F;24网络呢？也是无压力的，因为数据包到达R1后，她照样查找路由表结果发现有匹配的路由，因此将数据包转给R3。但是实际上，从业务的角度考虑，我们禁止PC1访问3.3.3.0&#x2F;24网络。<br>那么怎么办？</p>
<p><img src="/2024/06/23/VRF/20190301110351539.png" alt="20190301110351539"></p>
<p><img src="/2024/06/23/VRF/2019030111115184.png" alt="2019030111115184"></p>
<p>现在，我们在R1上创建两个VRF：VRF1及VRF2，创建完成后，我们可以理解为，拥有了两台虚拟路由器。当然，现在这两台虚拟路由器上啥也没有。<br>接下去我们将GE0&#x2F;0&#x2F;1口及GE0&#x2F;0&#x2F;2口绑定到VRF1；将GE0&#x2F;0&#x2F;3及GE0&#x2F;0&#x2F;4口绑定到VRF2。如此一来这两台虚拟路由器就各自拥有了两个物理接口。值得注意的是，这两台虚拟路由器是虽然都在同一台物理设备上，但是却是隔离的，他们将有自己的接口，自己的路由表，自己的ARP表等等相关的内容。我们的环境就变成有点像这样：</p>
<p><img src="/2024/06/23/VRF/20190301111226761.png" alt="20190301111226761"></p>
<p>我们看到，VRF1及VRF2有了自己的接口，也有了自己的路由表。并且相互之间是隔离的。<br>现在PC1要发送一个数据包到2.2.2.2，R1从接口GE0&#x2F;0&#x2F;1收到了这个数据包，由于此时GE0&#x2F;0&#x2F;1已经绑定到了VRF1，因此在执行目的IP的路由查找的时候，查的是VRF1的路由表，查找到匹配的路由条目后，间个数据包从其指示的GE0&#x2F;0&#x2F;1口转发给下一跳192.168.100.2。</p>
<p>那么如果PC1要访问3.3.3.3呢？数据包发到了R1，R1从接口GE0&#x2F;0&#x2F;1收到了这个数据包，于是它在做路由查找的时候，查的仍然是VRF1的路由表。经过查表后，它发现并无匹配的条目，因此将数据包丢弃。</p>
<p><img src="/2024/06/23/VRF/20190301111315435.png" alt="20190301111315435"></p>
<p>实验</p>
<img src="/2024/06/23/VRF/QQ截图20240623181526.png" alt="QQ截图20240623181526" style="zoom:80%;">

<p>如图，R2属于VPN实例aa，R3属于VPN实例bb，要求pc1可以访问R2，不能访问R3。PC2可以访问R3，不能访问R2.</p>
<p>R1下做单臂路由，创建VPN实例aa和bb，子接口分别绑定相应的VPN实例。g0&#x2F;0&#x2F;0绑定vpn实例aa，g0&#x2F;0&#x2F;1绑定vpn实例bb。</p>
<p>S1创建vlan，划分接口：略</p>
<p>注意：接口绑定VPN实例后，ip地址的配置会被移除，需要重新配置</p>
<p>创建vpn实例：</p>
<p>ip vpn-instance aa</p>
<p> ipv4-family #使能ipv4地址簇</p>
<p>接口绑定：ip binding vpn-instance aa</p>
<p>查看vpn路由表：dis ip routing-table vpn-instance aa</p>
<p>静态路由：ip route-static vpn-instance aa 2.2.2.2 32 192.168.10.1 </p>
<p>ping命令：ping -vpn-instance aa 192.168.10.1</p>
<p>R2上添加回程路由：略</p>
<p>至此，PC1可以ping通R2</p>
<p>R1上创建ospf：ospf 1 router-id 1.1.1.1 vpn-instance bb</p>
<p>宣告网段：略</p>
<p>R3上ospf宣告3.3.3.3</p>
<p>pc2ping通3.3.3.3</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>VRF</tag>
      </tags>
  </entry>
  <entry>
    <title>VRRP</title>
    <url>/2024/05/25/VRRP/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>虚拟路由冗余协议VRRP（Virtual Router Redundancy Protocol）通过把几台路由设备联合组成一台虚拟的路由设备，将虚拟路由设备的IP地址作为用户的默认网关实现与外部网络通信。当网关设备发生故障时，VRRP机制能够选举新的网关设备承担数据流量，从而保障网络的可靠通信。</p>
<p>随着网络的快速普及和相关应用的日益深入，各种增值业务（如IPTV、视频会议等）已经开始广泛部署，基础网络的可靠性日益成为用户关注的焦点，能够保证网络传输不中断对于终端用户非常重要。</p>
<p>通常，同一网段内的所有主机上都设置一条相同的、以网关为下一跳的缺省路由。主机发往其他网段的报文将通过缺省路由发往网关，再由网关进行转发，从而实现主机与外部网络的通信。当网关发生故障时，本网段内所有以网关为缺省路由的主机将无法与外部网络通信。增加出口网关是提高系统可靠性的常见方法，此时如何在多个出口之间进行选路就成为需要解决的问题。</p>
<p>VRRP的出现很好的解决了这个问题。VRRP能够在不改变组网的情况下，采用将多台路由设备组成一个虚拟路由器，通过配置虚拟路由器的IP地址为默认网关，实现默认网关的备份。当网关设备发生故障时，VRRP机制能够选举新的网关设备承担数据流量，从而保障网络的可靠通信。</p>
<img src="/2024/05/25/VRRP/QQ截图20240525184700.png" alt="QQ截图20240525184700" style="zoom:67%;">

<ul>
<li>VRRP路由器（VRRP Router）：运行VRRP协议的设备，它可能属于一个或多个虚拟路由器，如RouterA和RouterB。</li>
<li>虚拟路由器（Virtual Router）：又称VRRP备份组，由一个Master设备和多个Backup设备组成，被当作一个共享局域网内主机的缺省网关。如RouterA和RouterB共同组成了一个虚拟路由器。</li>
<li>Master路由器（Virtual Router Master）：承担转发报文任务的VRRP设备，如RouterA。</li>
<li>Backup路由器（Virtual Router Backup）：一组没有承担转发任务的VRRP设备，当Master设备出现故障时，它们将通过竞选成为新的Master设备，如RouterB。</li>
<li>VRID：虚拟路由器的标识。如RouterA和RouterB组成的虚拟路由器的VRID为1。</li>
<li>虚拟IP地址(Virtual IP Address)：虚拟路由器的IP地址，一个虚拟路由器可以有一个或多个IP地址，由用户配置。如RouterA和RouterB组成的虚拟路由器的虚拟IP地址为10.1.1.10&#x2F;24。</li>
<li><strong>IP地址拥有者（</strong>IP Address Owner）：如果一个VRRP设备将虚拟路由器IP地址作为真实的接口地址，则该设备被称为IP地址拥有者。如果IP地址拥有者是可用的，通常它将成为Master。如RouterA，其接口的IP地址与虚拟路由器的IP地址相同，均为10.1.1.10&#x2F;24，因此它是这个VRRP备份组的IP地址拥有者。</li>
<li>虚拟MAC地址（Virtual MAC Address）：虚拟路由器根据虚拟路由器ID生成的MAC地址。一个虚拟路由器拥有一个虚拟MAC地址，格式为：<strong>00-00-5E-00-01</strong>-{VRID}(VRRP for IPv4)；00-00-5E-00-02-{VRID}(VRRP for IPv6)。当虚拟路由器回应ARP请求时，使用虚拟MAC地址，而不是接口的真实MAC地址。如RouterA和RouterB组成的虚拟路由器的VRID为1，因此这个VRRP备份组的MAC地址为00-00-5E-00-01-01。</li>
</ul>
<p>0000-5e00-01xx   其中xx是vrid</p>
<h1 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h1><p>vrrp只有一种报文，Advertisement报文，基于组播方式发送，目的组播地址为224.0.0.18，ip协议号：112</p>
<img src="/2024/05/25/VRRP/QQ截图20240525185133.png" alt="QQ截图20240525185133" style="zoom:67%;">

<table>
<thead>
<tr>
<th>报文字段</th>
<th>含义</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>VRRPv2</td>
<td>VRRPv3</td>
<td></td>
</tr>
<tr>
<td>Version</td>
<td>VRRP协议版本号，取值为2。</td>
<td>VRRP协议版本号，取值为3。</td>
</tr>
<tr>
<td>Type</td>
<td>VRRP通告报文的类型，取值为1，表示Advertisement。</td>
<td>VRRP通告报文的类型，取值为1，表示Advertisement。</td>
</tr>
<tr>
<td>Virtual Rtr ID（VRID）</td>
<td>虚拟路由器ID，取值范围是1～255。</td>
<td>虚拟路由器ID，取值范围是1～255。</td>
</tr>
<tr>
<td>Priority</td>
<td>Master设备在备份组中的优先级，取值范围是0～255。0表示设备停止参与VRRP备份组，用来使备份设备尽快成为Master设备，而不必等到计时器超时；255则保留给IP地址拥有者。缺省值是100。</td>
<td>Master设备在备份组中的优先级，取值范围是0～255。0表示设备停止参与VRRP备份组，用来使备份设备尽快成为Master设备，而不必等到计时器超时；255则保留给IP地址拥有者。缺省值是100。</td>
</tr>
<tr>
<td>Count IP Addrs&#x2F;Count IPvX Addr</td>
<td>备份组中虚拟IPv4地址的个数。</td>
<td>备份组中虚拟IPv4或虚拟IPv6地址的个数。</td>
</tr>
<tr>
<td>Auth Type</td>
<td>VRRP报文的认证类型。协议中指定了3种类型：0：Non Authentication，表示无认证。1：Simple Text Password，表示明文认证方式。2：IP Authentication Header，表示MD5认证方式。</td>
<td>-</td>
</tr>
<tr>
<td>Adver Int&#x2F;Max Adver Int</td>
<td>VRRP通告报文的发送时间间隔，单位是秒，缺省值为1秒。</td>
<td>VRRP通告报文的发送时间间隔，单位是厘秒，缺省值为100厘秒（1秒）。</td>
</tr>
<tr>
<td>Checksum</td>
<td>16位校验和，用于检测VRRP报文中的数据破坏情况。</td>
<td>16位校验和，用于检测VRRP报文中的数据破坏情况。</td>
</tr>
<tr>
<td>IP Address&#x2F;IPvX Address(es)</td>
<td>VRRP备份组的虚拟IPv4地址，所包含的地址数定义在Count IP Addrs字段。</td>
<td>VRRP备份组的虚拟IPv4地址或者虚拟IPv6地址，所包含的地址数定义在Count IPvX Addrs字段。</td>
</tr>
<tr>
<td>Authentication Data</td>
<td>VRRP报文的认证字。目前只有明文认证和MD5认证才用到该部分，对于其它认证方式，一律填0。</td>
<td>-</td>
</tr>
<tr>
<td>rsvd</td>
<td>-</td>
<td>VRRP报文的保留字段，必须设置为0。</td>
</tr>
</tbody></table>
<ul>
<li><p>支持的网络类型不同。VRRPv3适用于IPv4和IPv6两种网络，而VRRPv2仅适用于IPv4网络。</p>
</li>
<li><p>认证功能不同。VRRPv3不支持认证功能，而VRRPv2支持认证功能。</p>
</li>
<li><p>发送通告报文的时间间隔的单位不同。VRRPv3支持的是厘秒级，而VRRPv2支持的是秒级。</p>
</li>
</ul>
<h1 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h1><p><img src="/2024/05/25/VRRP/QQ%E6%88%AA%E5%9B%BE20240525185814.png" alt="QQ截图20240525185814"></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Initialize</td>
<td>该状态为VRRP不可用状态，在此状态时设备不会对VRRP报文做任何处理。通常刚配置VRRP时或设备检测到故障时会进入Initialize状态。收到接口Up的消息后，如果设备的优先级为255，则直接成为Master设备；如果设备的优先级小于255，则会先切换至Backup状态。</td>
</tr>
<tr>
<td>Master</td>
<td>当VRRP设备处于Master状态时，它将会做下列工作：定时（Advertisement Interval）发送VRRP通告报文。以虚拟MAC地址响应对虚拟IP地址的ARP请求。转发目的MAC地址为虚拟MAC地址的IP报文。如果它是这个虚拟IP地址的拥有者，则接收目的IP地址为这个虚拟IP地址的IP报文。否则，丢弃这个IP报文。如果收到比自己优先级大的报文，立即成为Backup。如果收到与自己优先级相等的VRRP报文且本地接口IP地址小于对端接口IP，立即成为Backup。</td>
</tr>
<tr>
<td>Backup</td>
<td>当VRRP设备处于Backup状态时，它将会做下列工作：接收Master设备发送的VRRP通告报文，判断Master设备的状态是否正常。对虚拟IP地址的ARP请求，不做响应。丢弃目的IP地址为虚拟IP地址的IP报文。如果收到优先级和自己相同或者比自己大的报文，则重置Master_Down_Interval定时器，不进一步比较IP地址。Master_Down_Interval定时器：Backup设备在该定时器超时后仍未收到通告报文，则会转换为Master状态。计算公式如下：<em><em>Master_Down_Interval&#x3D;(3</em> Advertisement_Interval) + Skew_time。其中，Skew_Time&#x3D;(256–Priority)&#x2F;256。</em>*如果收到比自己优先级小的报文且该报文优先级是0时，定时器时间设置为Skew_time（偏移时间），如果该报文优先级不是0，丢弃报文，立刻成为Master。</td>
</tr>
</tbody></table>
<h1 id="VRRP工作过程"><a href="#VRRP工作过程" class="headerlink" title="VRRP工作过程"></a>VRRP工作过程</h1><ol>
<li>VRRP备份组中的设备根据<strong>优先级</strong>选举出Master。Master设备通过发送免费ARP报文，将虚拟MAC地址通知给与它连接的设备或者主机，从而承担报文转发任务。</li>
<li>Master设备周期性向备份组内所有Backup设备发送VRRP通告报文，以公布其配置信息（优先级等）和工作状况。</li>
<li>如果Master设备出现故障，VRRP备份组中的Backup设备将根据优先级重新选举新的Master。</li>
<li>VRRP备份组状态切换时，Master设备由一台设备切换为另外一台设备，新的Master设备会立即发送携带虚拟路由器的虚拟MAC地址和虚拟IP地址信息的免费ARP报文，刷新与它连接的主机或设备中的MAC表项，从而把用户流量引到新的Master设备上来，整个过程对用户完全透明。</li>
<li>原Master设备故障恢复时，若该设备为IP地址拥有者（优先级为255），将直接切换至Master状态。若该设备优先级小于255，将首先切换至Backup状态，且其优先级恢复为故障前配置的优先级。</li>
<li>Backup设备的优先级高于Master设备时，由Backup设备的工作方式（抢占方式和非抢占方式）决定是否重新选举Master。<ul>
<li><strong>抢占模式</strong>（默认）：在抢占模式下，如果Backup设备的优先级比当前Master设备的优先级高，则主动将自己切换成Master。</li>
<li>非抢占模式：在非抢占模式下，只要Master设备没有出现故障，Backup设备即使随后被配置了更高的优先级也不会成为Master设备。</li>
</ul>
</li>
</ol>
<p>由此可见，为了保证Master设备和Backup设备能够协调工作，VRRP需要实现以下功能：</p>
<ul>
<li>Master设备的选举。</li>
<li>Master设备状态的通告。</li>
</ul>
<p>下面将从上述两个方面详细介绍VRRP的工作过程。</p>
<ul>
<li><p><strong>Master设备的选举</strong></p>
<p>VRRP根据优先级来确定虚拟路由器中每台设备的角色（Master设备或Backup设备）。优先级越高，则越有可能成为Master设备。</p>
<p>初始创建的VRRP设备工作在Initialize状态，收到接口Up的消息后，如果设备的优先级为255，则直接成为Master设备；如果设备的优先级小于255，则会先切换至Backup状态，待Master_Down_Interval定时器超时后再切换至Master状态。首先切换至Master状态的VRRP设备通过VRRP通告报文的交互获知虚拟设备中其他成员的优先级，进行Master的选举：</p>
<ul>
<li>如果VRRP报文中Master设备的优先级高于或等于自己的优先级，则Backup设备保持Backup状态。</li>
<li>如果VRRP报文中Master设备的优先级低于自己的优先级，采用抢占方式的Backup设备将切换至Master状态，采用非抢占方式的Backup设备仍保持Backup状态。</li>
<li>如果多个VRRP设备同时切换到Master状态，通过VRRP通告报文的交互进行协商后，优先级较低的VRRP设备将切换成Backup状态，优先级最高的VRRP设备成为最终的Master设备；优先级相同时，VRRP设备上VRRP备份组所在接口主IP地址较大的成为Master设备。</li>
<li>如果创建的VRRP设备为IP地址拥有者，收到接口Up的消息后，将会直接切换至Master状态。</li>
</ul>
</li>
<li><p><strong>Master设备状态的通告</strong></p>
<p>Master设备周期性地发送VRRP通告报文，在VRRP备份组中公布其配置信息（优先级等）和工作状况。Backup设备通过接收到VRRP报文的情况来判断Master设备是否工作正常。</p>
<ul>
<li>当Master设备主动放弃Master地位（如Master设备退出备份组）时，会发送优先级为0的通告报文，用来使Backup设备快速切换成Master设备，而不用等到Master_Down_Interval定时器超时。这个切换的时间称为Skew time，计算方式为：（256－Backup设备的优先级）&#x2F;256，单位为秒。</li>
<li>当Master设备发生网络故障而不能发送通告报文的时候，Backup设备并不能立即知道其工作状况。等到Master_Down_Interval定时器超时后，才会认为Master设备无法正常工作，从而将状态切换为Master。其中，Master_Down_Interval定时器取值为：3×Advertisement_Interval＋Skew_time，单位为秒。</li>
</ul>
</li>
</ul>
<h1 id="VRRP负载分担"><a href="#VRRP负载分担" class="headerlink" title="VRRP负载分担"></a>VRRP负载分担</h1><p>负载分担是指多个VRRP备份组同时承担业务，VRRP负载分担与VRRP主备备份的基本原理和报文协商过程都是相同的。同样对于每一个VRRP备份组，都包含一个Master设备和若干Backup设备。与主备备份方式不同点在于：负载分担方式需要建立多个VRRP备份组，各备份组的Master设备可以不同；同一台VRRP设备可以加入多个备份组，在不同的备份组中具有不同的优先级。</p>
<h4 id><a href="#" class="headerlink" title></a><img src="/2024/05/25/VRRP/QQ截图20240525190602.png" alt="QQ截图20240525190602" style="zoom:67%;"></h4><p>配置两个VRRP备份组。</p>
<ul>
<li>VRRP备份组1：RouterA为Master设备，RouterB为Backup设备。</li>
<li>VRRP备份组2：RouterB为Master设备，RouterA为Backup设备。</li>
</ul>
<p>一部分用户将VRRP备份组1作为网关，另一部分用户将VRRP备份组2作为网关。这样既可实现对业务流量的负载分担，同时，也起到了相互备份的作用。</p>
<h1 id="VRRP监视上行端口"><a href="#VRRP监视上行端口" class="headerlink" title="VRRP监视上行端口"></a>VRRP监视上行端口</h1><img src="/2024/05/25/VRRP/QQ截图20240525190751.png" alt="QQ截图20240525190751" style="zoom:67%;">

<p>命令：上行接口视图，vrrp vrid 1 track interface  g 0&#x2F;0&#x2F;1 increased(或者reduced) 30（增加或减少优先级）</p>
<p>VRRP备份组只能感知其所在接口状态的变化，当VRRP设备上行接口或直连链路发生故障时，VRRP无法感知，此时会引起业务流量中断。通过部署VRRP与接口状态联动监视上行接口可以有效地解决上述问题，当Master设备的上行接口或直连链路发生故障时，通过调整自身优先级，触发主备切换，确保流量正常转发。</p>
<p>VRRP可以通过Increased和Reduced方式来监视接口状态：</p>
<ul>
<li>如果VRRP设备上配置以Increased方式监视一个接口，当被监视的接口状态变成Down后，该VRRP设备的优先级增加指定值。</li>
<li>如果VRRP设备上配置以Reduced方式监视一个接口，当被监视的接口状态变为Down后，该VRRP设备的优先级降低指定值。</li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>VRRP</tag>
      </tags>
  </entry>
  <entry>
    <title>VRRP基础实验</title>
    <url>/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>设备连接方式如图所示，网络中存在VLAN10、20，每个VLAN中部署一组VRRP，使用与VLAN ID相同的数值作为VRID，将S1配置为VLAN10的VRRP Master，将S2配置为VLAN20的VRRP Master。</p>
<p>同时在S1、S2、S3上部署MSTP，创建Instance 1、2，将VLAN10映射到MSTI 1、VLAN20映射到MSTI 2，将S1配置为MSTI 1的主根桥、MSTI 2的备份根桥，而将S2配置为MSTI 1的备份根桥、MSTI 2的主根桥。</p>
<p>VLANIF接口地址使用10.0.x.y&#x2F;24，其中x为VRID组号，y为设备编号，VRIP使用10.0.x.254&#x2F;24。</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/vrrptuopu29210315.png" alt="vrrptuopu29210315"></p>
<p>#创建VLAN</p>
<p>[S1]vlan batch 10 20</p>
<p>[S2]vlan batch 10 20 </p>
<p>[S3]vlan batch 10 20 </p>
<p>[S4]vlan batch 10 20 </p>
<p>#将所有互联接口配置为Trunk接口，放通对应VLAN</p>
<p>略</p>
<p>#修改STP模式为MSTP</p>
<p>[S1]stp mode mstp</p>
<p>[S2]stp mode mstp</p>
<p>[S3]stp mode mstp</p>
<p>#配置MSTP</p>
<p>[S1]stp region-configuration</p>
<p>[S1-mst-region] region-name hcip</p>
<p>[S1-mst-region] revision-level 1</p>
<p>[S1-mst-region] instance 1 vlan 10 </p>
<p>[S1-mst-region] instance 2 vlan 20</p>
<p>[S1-mst-region] active region-configuration</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S1-mst-region] quit</p>
<p>[S2]stp region-configuration</p>
<p>[S2-mst-region] region-name hcip</p>
<p>[S2-mst-region] revision-level 1</p>
<p>[S2-mst-region] instance 1 vlan 10 </p>
<p>[S2-mst-region] instance 2 vlan 20 </p>
<p>[S2-mst-region] active region-configuration</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S2-mst-region] quit</p>
<p>[S3]stp region-configuration</p>
<p>[S3-mst-region] region-name hcip</p>
<p>[S3-mst-region] revision-level 1</p>
<p>[S3-mst-region] instance 1 vlan 10 </p>
<p>[S3-mst-region] instance 2 vlan 20 </p>
<p>[S3-mst-region] active region-configuration</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S3-mst-region] quit</p>
<p>#配置SW1为MSTI1的根桥、MSTI2的备份根桥</p>
<p>[S1]stp instance 1 root primary </p>
<p>[S1]stp instance 2 root secondary</p>
<p>#配置SW2为MSTI2的根桥、MSTI1的备份根桥</p>
<p>[S2]stp instance 1 root secondary </p>
<p>[S2]stp instance 2 root primary</p>
<p>#在S1上查看MSTI1的状态和统计信息摘要</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/shili1129211309.png" alt="shili1129211309"></p>
<p>S1上所有接口都是指定接口，S1为MSTI1的根桥。</p>
<p>#在S2上查看MSTI2的状态和统计信息摘要</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/shili229211338.png" alt="shili229211338"></p>
<p>S2上所有接口都是指定接口，S2为MSTI1的根桥。</p>
<h2 id="VRRP基础配置"><a href="#VRRP基础配置" class="headerlink" title="VRRP基础配置"></a>VRRP基础配置</h2><p>在S1、S2均创建VLANIF 10、20，分别加入VRRP组10、20，手动配置VRRP优先级，使得S1的VLAN10成为VRRP Master、S2的VLAN20成为VRRP Master。</p>
<p>#创建VLANIF</p>
<p>[S1]interface Vlanif10</p>
<p>[S1-Vlanif10] ip address 10.0.10.1 255.255.255.0</p>
<p>[S1-Vlanif10] quit</p>
<p>[S1]interface Vlanif20</p>
<p>[S1-Vlanif20] ip address 10.0.20.1 255.255.255.0</p>
<p>[S1-Vlanif20] quit</p>
<p>[S2]interface Vlanif10</p>
<p>[S2-Vlanif10] ip address 10.0.10.2 255.255.255.0</p>
<p>[S2-Vlanif10] quit</p>
<p>[S2]interface Vlanif20</p>
<p>[S2-Vlanif20] ip address 10.0.20.2 255.255.255.0</p>
<p>[S2-Vlanif20] quit</p>
<p>#S1上配置VRRP</p>
<p>[S1]interface Vlanif 10</p>
<p>[S1-Vlanif10] vrrp vrid 10 virtual-ip 10.0.10.254</p>
<p>[S1-Vlanif10] vrrp vrid 10 priority 120</p>
<p>[S1-Vlanif10] quit</p>
<p>[S1]interface Vlanif 20</p>
<p>[S1-Vlanif20] vrrp vrid 20 virtual-ip 10.0.20.254</p>
<p>[S1-Vlanif20] quit</p>
<p>配置VLAN10的VRRP优先级为120，VLAN20保持默认的100。</p>
<p>#S2上配置VRRP</p>
<p>[S2]interface Vlanif10</p>
<p>[S2-Vlanif10] vrrp vrid 10 virtual-ip 10.0.10.254</p>
<p>[S2-Vlanif10] quit</p>
<p>[S2]interface Vlanif20</p>
<p>[S2-Vlanif20] vrrp vrid 20 virtual-ip 10.0.20.254</p>
<p>[S2-Vlanif20] vrrp vrid 20 priority 120</p>
<p>[S2-Vlanif20] quit</p>
<p>配置VLAN20的VRRP优先级为120，VLAN10保持默认的100。</p>
<p>#查看VRRP组状态</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/chakanvrrp1914.png" alt="chakanvrrp1914"></p>
<h2 id="配置VRRP与BFD联动进行快速切换"><a href="#配置VRRP与BFD联动进行快速切换" class="headerlink" title="配置VRRP与BFD联动进行快速切换"></a>配置VRRP与BFD联动进行快速切换</h2><p>在S1、S2上配置BFD单跳检测，检测VLANIF接口之间的连通性，将VRRP与BFD联动，当BFD会话状态Down时，增加VRRP Backup设备的优先级。</p>
<p>#在S1上配置BFD会话</p>
<p>[S1]bfd</p>
<p>[S1-bfd] quit</p>
<p>[S1]bfd vlanif10 bind peer-ip 10.0.10.2 interface Vlanif10</p>
<p>[S1-bfd-session-vlanif10] discriminator local 1</p>
<p>[S1-bfd-session-vlanif10] discriminator remote 2</p>
<p>[S1-bfd-session-vlanif10] min-tx-interval 100</p>
<p>[S1-bfd-session-vlanif10] min-rx-interval 100</p>
<p>[S1-bfd-session-vlanif10] commit</p>
<p>[S1-bfd-session-vlanif10] quit</p>
<p>[S1]bfd vlanif20 bind peer-ip 10.0.20.2 interface Vlanif20</p>
<p>[S1-bfd-session-vlanif20] discriminator local 11</p>
<p>[S1-bfd-session-vlanif20] discriminator remote 22</p>
<p>[S1-bfd-session-vlanif20] min-tx-interval 100</p>
<p>[S1-bfd-session-vlanif20] min-rx-interval 100</p>
<p>[S1-bfd-session-vlanif20] commit</p>
<p>[S1-bfd-session-vlanif20] quit</p>
<p>#在S2上配置BFD会话</p>
<p>[S2]bfd</p>
<p>[S2-bfd] quit</p>
<p>[S2]bfd vlanif10 bind peer-ip 10.0.10.1 interface Vlanif10</p>
<p>[S2-bfd-session-vlanif10] discriminator local 2</p>
<p>[S2-bfd-session-vlanif10] discriminator remote 1</p>
<p>[S2-bfd-session-vlanif10] min-tx-interval 100</p>
<p>[S2-bfd-session-vlanif10] min-rx-interval 100</p>
<p>[S2-bfd-session-vlanif10] commit</p>
<p>[S2-bfd-session-vlanif10] quit</p>
<p>[S2]bfd vlanif20 bind peer-ip 10.0.20.1 interface Vlanif20</p>
<p>[S2-bfd-session-vlanif20] discriminator local 22</p>
<p>[S2-bfd-session-vlanif20] discriminator remote 11</p>
<p>[S2-bfd-session-vlanif20] min-tx-interval 100</p>
<p>[S2-bfd-session-vlanif20] min-rx-interval 100</p>
<p>[S2-bfd-session-vlanif20] commit</p>
<p>[S2-bfd-session-vlanif20] quit</p>
<p>#检查BFD会话状态</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/bfdahakan737.png" alt="bfdahakan737"></p>
<p>此时S1、S2上BFD会话状态都为Up。</p>
<p>#配置VRRP与BFD联动</p>
<p>[S1]interface Vlanif20</p>
<p>[S1-Vlanif20] vrrp vrid 20 track bfd-session 11 increased 30</p>
<p>[S1-Vlanif20] quit</p>
<p>[S2]interface Vlanif10</p>
<p>[S2-Vlanif10] vrrp vrid 10 track bfd-session 2 increased 30</p>
<p>[S2-Vlanif10] quit</p>
<p>注意，此处的bfd-session号为本地的BFD discriminator，只需要在Backup状态的接口上配置联动，BFD会话Down时增加本地的VRRP优先级。</p>
<p>#关闭S1上所有接口，模拟链路故障</p>
<p>[S1]interface GigabitEthernet0&#x2F;0&#x2F;10</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;10] shutdown</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;10] quit</p>
<p>[S1]interface GigabitEthernet0&#x2F;0&#x2F;11</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11] shutdown</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11] quit</p>
<p>[S1]interface GigabitEthernet0&#x2F;0&#x2F;12</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12] shutdown</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12] quit</p>
<p>#在S2上查看BFD会话状态</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/yichang13038.png" alt="yichang13038"></p>
<p>此时两个BFD会话状态立马变为Down。</p>
<p>#在S2上查看VRRP组状态</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/shuangzhu129213128.png" alt="shuangzhu129213128"></p>
<p>VRRP组10、20的Master此时都是S2。</p>
<p>#在S2上查看VRRP组的状态和配置参数信息</p>
<p><img src="/2023/11/29/VRRP%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/canshufiejo9213200.png" alt="canshufiejo9213200"></p>
]]></content>
      <tags>
        <tag>VRRP</tag>
        <tag>BFD</tag>
      </tags>
  </entry>
  <entry>
    <title>WLAN基础配置（ap上线）</title>
    <url>/2023/12/20/WLAN%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%EF%BC%88ap%E4%B8%8A%E7%BA%BF%EF%BC%89/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="CAPWAP协议"><a href="#CAPWAP协议" class="headerlink" title="CAPWAP协议"></a>CAPWAP协议</h2><p>CAPWAP是基于UDP进行传输的应用层协议，CAPWAP协议在传输层运输两种类型的消息：</p>
<ul>
<li>业务数据流量，封装转发无线数据帧 。——通过CAPWAP数据隧道。</li>
<li>管理流量，管理AP和AC之间交换的管理消息 。——通过CAPWAP控制隧道。</li>
</ul>
<p>CAPWAP数据和控制报文基于不同的UDP端口发送：</p>
<ul>
<li>管理流量端口为UDP端口5246。</li>
<li>业务数据流量端口为UDP端口5247。</li>
</ul>
<h2 id="AC连接方式"><a href="#AC连接方式" class="headerlink" title="AC连接方式"></a>AC连接方式</h2><p>直连模式下AC部署在用户的转发路径上，采用这种组网方式，对AC的吞吐量以及处理数据能力要求比较高，否则AC会是整个无线网络带宽的瓶颈。但用此种组网，组网架构清晰，组网实施起来简单</p>
<p>在旁挂式组网中，AC只承载对AP的管理功能，管理流封装在CAPWAP隧道中传输。数据业务流可以通过CAPWAP数据隧道经AC转发，也可以不经过AC转发直接转发，后者无线用户业务流经汇聚交换机由汇聚交换机传输至上层网络。</p>
<h2 id="WLAN的基本概念"><a href="#WLAN的基本概念" class="headerlink" title="WLAN的基本概念"></a>WLAN的基本概念</h2><ol>
<li><p>BSS：一个AP所覆盖的范围，在一个BSS的服务区域内，STA可以相互通信。</p>
</li>
<li><p>BSSID：是无线网络的一个身份标识，用AP的MAC地址表示。</p>
</li>
<li><p>SSID：表示无线网络的标识，用来区分不同的无线网络。例如，当我们在笔记本电脑上搜索可接入无线网络时，显示出来的网络名称就是SSID。</p>
</li>
<li><p>VAP<br>早期的AP只支持1个BSS，如果要在同一空间内部署多个BSS，则需要安放多个AP，这不但增加了成本，还占用了信道资源。为了改善这种状况，现在的AP通常支持创建出多个虚拟AP (Virtual Access Point, VAP)。如图16-13所示，它相当于交换机中的VLAN</p>
</li>
<li><p>ESS</p>
</li>
</ol>
<p>为了满足实际业务的需求，需要对BSS的覆盖范围进行扩展。同时用户从一个BSS移动到另一个BSS时，不能感知到SSID的变化，则可以通过扩展服务集ESS (Extend Service Set)实现。如图6-14所示，这是由多个使用相同SSID的BSS组成，是采用相同的SSID的多个BSS组成的更大规模的虚拟BSS。</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p><img src="/2023/12/20/WLAN%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%EF%BC%88ap%E4%B8%8A%E7%BA%BF%EF%BC%89/tuopoa182409.png" alt="tuopoa182409"></p>
<ol>
<li>实验步骤</li>
<li>步骤1：基本配置<br>LSW2的配置<br><Huawei>system-view<br>[Huawei]undo info-center enable<br>[Huawei]sysname LSW2<br>[LSW2]vlan 100<br>[LSW2-vlan100]quit<br>[LSW2]interface e0&#x2F;0&#x2F;1<br>[LSW2-Ethernet0&#x2F;0&#x2F;1]port link-type trunk<br>[LSW2-Ethernet0&#x2F;0&#x2F;1]port trunk allow-pass vlan 100<br>[LSW2-Ethernet0&#x2F;0&#x2F;1]port trunk pvid vlan 100<br>[LSW2-Ethernet0&#x2F;0&#x2F;1]quit<br>[LSW2]interface e0&#x2F;0&#x2F;2<br>[LSW2-Ethernet0&#x2F;0&#x2F;2]port link-type trunk<br>[LSW2-Ethernet0&#x2F;0&#x2F;2]port trunk allow-pass vlan 100<br>[LSW2-Ethernet0&#x2F;0&#x2F;2]port trunk pvid vlan 100<br>[LSW2-Ethernet0&#x2F;0&#x2F;2]quit<br>[LSW2]interface e0&#x2F;0&#x2F;3<br>[LSW2-Ethernet0&#x2F;0&#x2F;3]port link-type trunk<br>[LSW2-Ethernet0&#x2F;0&#x2F;3]port trunk allow-pass vlan 100<br>[LSW2-Ethernet0&#x2F;0&#x2F;3]quit<br>【思考1】：为什么LSW2只创建VLAN100，不用创建VLAN101？<br>解析：因为我们用的是隧道转发，数据到达AC1后，才会打上101标记然后发给LSW1<br>【思考2】：为什么连接AP的接口要打port trunk pvid vlan 100?<br>解析：交换机收到AP的数据帧打上100的tag发送<br>把带上100tag的数据帧去掉然后发给AP<br>LSW1的配置<br><Huawei>system-view<br>[Huawei]undo info-center enable<br>[Huawei]sysname LSW1<br>[LSW1]vlan batch 100 101<br>[LSW1]interface g0&#x2F;0&#x2F;1<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;1]port link-type trunk<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;1]port trunk allow-pass vlan 100<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;1]quit<br>[LSW1]interface g0&#x2F;0&#x2F;3<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;3]port link-type trunk<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;3]port trunk allow-pass vlan 100 101<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;3]quit<br>[LSW1]interface g0&#x2F;0&#x2F;2<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;2]port link-type access<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;2]port default vlan 101<br>[LSW1-GigabitEthernet0&#x2F;0&#x2F;2]quit<br>[LSW1]interface Vlanif 101<br>[LSW1-Vlanif101]ip address 192.168.101.1 24<br>[LSW1-Vlanif101]undo shutdown<br>[LSW1-Vlanif101]quit<br>AC1的配置<br><AC6005>system-view<br>[AC6005]undo info-center enable<br>[AC6005]sysname AC1<br>[AC1]vlan batch 100 101<br>[AC1]interface g0&#x2F;0&#x2F;1<br>[AC1-GigabitEthernet0&#x2F;0&#x2F;1]port link-type trunk<br>[AC1-GigabitEthernet0&#x2F;0&#x2F;1]port trunk allow-pass vlan 100 101<br>[AC1-GigabitEthernet0&#x2F;0&#x2F;1]quit<br>[AC1]interface Vlanif 100<br>[AC1-Vlanif100]ip address 192.168.100.1 24<br>[AC1-Vlanif100]undo shutdown<br>[AC1-Vlanif100]quit<br>R1的配置<br><Huawei>system-view<br>[Huawei]undo info-center enable<br>[Huawei]sysname R1<br>[R1]interface g0&#x2F;0&#x2F;0<br>[R1-GigabitEthernet0&#x2F;0&#x2F;0]ip address 192.168.101.2 24<br>[R1-GigabitEthernet0&#x2F;0&#x2F;0]undo shutdown<br>[R1-GigabitEthernet0&#x2F;0&#x2F;0]quit</Huawei></AC6005></Huawei></Huawei></li>
<li>步骤2：设置DHCP<br>创建VLAN设置TRUNK<br>业务DHCP-让STA获得IP地址<br>[LSW1]dhcp enable<br>[LSW1]interface Vlanif 101<br>[LSW1-Vlanif101]dhcp select interface<br>[LSW1-Vlanif101]quit<br>管理DHCP-让AP获得IP地址<br><AC1>system-view<br>[AC1]dhcp enable<br>[AC1]interface Vlanif 100<br>[AC1-Vlanif100]dhcp select interface<br>[AC1-Vlanif100]quit</AC1></li>
<li>步骤3：AC的配置</li>
<li>AP上线<br>第一步：创建AP组<br><AC1>system-view<br>[AC1]wlan<br>[AC1-wlan-view]ap-group name x &#x2F;&#x2F;创建AP组名字叫x<br>[AC1-wlan-ap-group-x]quit<br>第二步：创建域管理模板并关联到AP组<br>[AC1]wlan<br>[AC1-wlan-view]regulatory-domain-profile name x1 &#x2F;&#x2F;创建域管理模板，名字叫x1<br>[AC1-wlan-regulate-domain-x1]country-code cn &#x2F;&#x2F;国家代码选择中国<br>[AC1-wlan-regulate-domain-x1]quit<br>[AC1-wlan-view]ap-group name x<br>[AC1-wlan-ap-group-x]regulatory-domain-profile x1 &#x2F;&#x2F;AP组的域管理模板是x1<br>Warning: Modifying the country code will clear channel, power and antenna gain c<br>onfigurations of the radio and reset the AP. Continue?[Y&#x2F;N]:y<br>[AC1-wlan-ap-group-x]quit<br>第三步：配置AC的接口源地址<br>[AC1]capwap source interface Vlanif 100 &#x2F;&#x2F;AC的接口源地址为VLAN100<br>第四步：离线导入AP<br>[AC1]wlan<br>[AC1-wlan-view]ap auth-mode mac-auth &#x2F;&#x2F;AP的认证模式为MAC认证<br>[AC1-wlan-view]ap-id 1 ap-mac 00e0-fcd5-1c70 &#x2F;&#x2F;AP的编号和MAC地址<br>[AC1-wlan-ap-1]ap-name ds &#x2F;&#x2F;AP的名字为ds<br>[AC1-wlan-ap-1]ap-group x &#x2F;&#x2F;AP属于AP组x<br>[AC1-wlan-view]ap-id 2 ap-mac 00e0-fc1e-3670 &#x2F;&#x2F;AP的编号和MAC地址<br>[AC1-wlan-ap-2]ap-name xs &#x2F;&#x2F;Ap的名字<br>[AC1-wlan-ap-2]ap-group x &#x2F;&#x2F;AP属于AP组x<br>Warning: This operation may cause AP reset. If the country code changes, it will<br>clear channel, power and antenna gain configurations of the radio, Whether to c<br>ontinue? [Y&#x2F;N]:y<br>思考：AP的MAC地址是怎么知道的？<br>读者可以通过在ap上使用命令“display interface Vlanif 1”查看当前ap的mac地址，然后再将mac地址进行绑定。<br>查看命令：<br>[AC1]display ap all<br>Info: This operation may take a few seconds. Please wait for a moment.done.<br>Total AP information:<br>nor : normal [2]<br>-—————————————————————————————–<br>ID MAC Name Group IP Type State STA Uptime<br>-—————————————————————————————–<br>1 00e0-fcd5-1c70 ds x 192.168.100.137 AP2050DN nor 0 11M:2S<br>2 00e0-fc1e-3670 xs x 192.168.100.42 AP2050DN nor 0 54S<br>-—————————————————————————————–<br>可以看到两个AP都获取了IP地址，<br>思考：以上过程一共几包？<br>AP获取IP地址4个包：discovery、offer、request、ack<br>CAPWAP的建立2个包：discovery request(udp 目的端口5246广播找AC) discovery response(单播回应AP)<br>AP接入控制2个包：join request(udp 5246端口 单播) join response<br>隧道维持2个包：数据隧道：keepalive(udp 5247) 控制隧道：echo(udp 5246)</AC1></li>
<li>配置VLAN业务参数<br>第一步：创建安全模板<br>[AC1]wlan<br>[AC1-wlan-view]security-profile name y1 &#x2F;&#x2F;安全模板的名字叫y1<br>[AC1-wlan-sec-prof-y1]security wpa-wpa2 psk pass-phrase huawei@123 aes &#x2F;&#x2F;密码是huawei@123，用AES加密。<br>[AC1-wlan-sec-prof-y1]quit<br>第二步：创建SSID模板<br>[AC1]wlan<br>[AC1-wlan-view]ssid-profile name y2 &#x2F;&#x2F;ssid的模板名字叫y2<br>[AC1-wlan-ssid-prof-y2]ssid hcia &#x2F;&#x2F;ssid的名称叫hcia<br>[AC1-wlan-ssid-prof-y2]quit<br>[AC1-wlan-view]quit<br>第三步：创建VAP模板<br>[AC1]wlan<br>[AC1-wlan-view]vap-profile name y &#x2F;&#x2F;vap模板的名字叫y<br>[AC1-wlan-vap-prof-y]forward-mode tunnel &#x2F;&#x2F;转发模式为隧道<br>[AC1-wlan-vap-prof-y]service-vlan vlan-id 101 &#x2F;&#x2F;服务的VLAN为101<br>[AC1-wlan-vap-prof-y]security-profile y1 &#x2F;&#x2F;调用安全模板y1<br>[AC1-wlan-vap-prof-y]ssid-profile y2 &#x2F;&#x2F;调用SSID模板y2<br>[AC1-wlan-vap-prof-y]quit<br>第四步：在AP组里面调用VAP模板<br>[AC1-wlan-view]ap-group name x<br>[AC1-wlan-ap-group-x]vap-profile y wlan 1 radio 0 &#x2F;&#x2F;调用VAP模板y<br>[AC1-wlan-ap-group-x]vap-profile y wlan 1 radio 1 &#x2F;&#x2F;<br>思考：radio0 1 2 是什么意思？<br>思考：这相过程要几个包？<br>WLAN业务配置下发2个包：Configuration Update Request Configuration Update Response</li>
<li>STA接入，可以看到有两个ssid为hcia的无线网络，在之前的配置中配置了radio 0 、1就是为了释放两个不同的射频信号，选择其中一个，输入之前创建的密码huawei@123</li>
</ol>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>ap上线</tag>
        <tag>wlan</tag>
      </tags>
  </entry>
  <entry>
    <title>ip综合实验</title>
    <url>/2024/06/29/ip%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p><img src="/2024/06/29/ip%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/QQ%E6%88%AA%E5%9B%BE20240629212923.png" alt="QQ截图20240629212923"></p>
<p><img src="/2024/06/29/ip%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/QQ%E6%88%AA%E5%9B%BE20240629213005.png" alt="QQ截图20240629213005"></p>
<p>细节步骤没有完全记录，只记录了大概</p>
<p><strong>1.配置vlan，接口放行vlan</strong></p>
<p>（交换机放行vlan10，20，30，66，88，100）</p>
<p>汇聚1汇聚2之间做链路聚合，eth 1放通vlan</p>
<p>注意：汇聚1的g0&#x2F;0&#x2F;7只走WLAN的数据，vlan10 20 30不会走，只需放通vlan 66 88 100即可</p>
<p><strong>2.配置MSTP</strong></p>
<p>wlan的主根桥是汇聚1（66 88 100）</p>
<p>有线的主根桥是汇聚2（10 20 30）</p>
<p>stp mode mstp</p>
<p>stp region-configuration<br> region-name aa<br> instance 1 vlan 66 88 100<br> instance 2 vlan 10 20 30<br> active region-configuration</p>
<p>汇聚1：</p>
<p>stp instance 1 root primary<br>stp instance 2 root secondary</p>
<p>汇聚2：</p>
<p>stp instance 1 root secondary<br>stp instance 2 root primary</p>
<p><strong>3.AC-AP</strong></p>
<p>管理vlan100，业务vlan88和66</p>
<p>AC：</p>
<p>vlan 100</p>
<p>int g 0&#x2F;0&#x2F;1</p>
<p>p l  t</p>
<p>p t a v 100 66 88</p>
<p>int  vlanif 100</p>
<p>ip ad 192.168.100.254 24</p>
<p>capwap source interface vlanif 100</p>
<p>wlan配置：</p>
<p>wlan</p>
<p>ap-group name ap（创建ap组）</p>
<p>regulatory-domain-profile default</p>
<p>security-profile name yuangong（两个安全模板）</p>
<p>security wpa-wpa2 psk pass-phrase yuangong666 aes</p>
<p>security-profile name fangke</p>
<p>security wpa-wpa2 psk pass-phrase fangke888 aes</p>
<p>ssid-profile name yuangong（两个ssid模板）</p>
<p>ssid yuangong</p>
<p>ssid-profile name fangke</p>
<p>ssid fangke</p>
<p>vap-profile name yuangong（两个vap模板分别绑定yuangong和fangke）</p>
<p>security-profile yuangong</p>
<p>ssid-profile yuangong</p>
<p>service-vlan vlan-id 66</p>
<p>vap-profile name fangke</p>
<p>security-profile fangke</p>
<p>ssid-profile fangke</p>
<p>service-vlan vlan-id 88</p>
<p>ap-id 0 ap-mac 00e0-fca6-10f0（三个ap上线）</p>
<p>ap-name ap1</p>
<p>ap-group ap</p>
<p>ap-id 1 ap-mac 00e0-fc64-6810</p>
<p>ap-name ap2</p>
<p>ap-group ap</p>
<p>ap-id 2 ap-mac 00e0-fcbb-3530</p>
<p>ap-name ap3</p>
<p>ap-group ap</p>
<p>ap-group name ap（下发信号）</p>
<p>vap-profile yuangong wlan 1 radio all</p>
<p>vap-profile  fangke wlan 2 radio all</p>
<p>dhcp enable（配置dhcp）</p>
<p>int vlanif100</p>
<p>dhcp se int</p>
<p><strong>4.配置VRRP</strong></p>
<p>汇聚1：</p>
<p>interface Vlanif10<br> ip address 192.168.10.1 255.255.255.0<br> vrrp vrid 1 virtual-ip 192.168.10.254</p>
<p>汇聚2：</p>
<p>interface Vlanif10<br> ip address 192.168.10.2 255.255.255.0<br> vrrp vrid 1 virtual-ip 192.168.10.254<br> vrrp vrid 1 priority 120（因为汇聚2是vlan10 20 30的主根桥，所以优先级改大）</p>
<p>只举例vrrp 1的</p>
<p>后边vlan 20 vlan 30同理创建</p>
<p>valn 66 88 的汇聚1优先级改大</p>
<p><strong>5.配置DHCP</strong></p>
<p>因为配置了VRRP，所以汇聚1和汇聚2都要配置dhcp</p>
<p>ip pool 10<br> gateway-list 192.168.10.254<br> network 192.168.10.0 mask 255.255.255.0<br> excluded-ip-address 192.168.10.1 192.168.10.2</p>
<p>ip pool 20<br> gateway-list 192.168.20.254<br> network 192.168.20.0 mask 255.255.255.0<br> excluded-ip-address 192.168.20.1 192.168.20.2<br>ip pool 30<br> gateway-list 192.168.30.254<br> network 192.168.30.0 mask 255.255.255.0<br> excluded-ip-address 192.168.30.1 192.168.30.2<br>ip pool 66<br> gateway-list 192.168.66.254<br> network 192.168.66.0 mask 255.255.255.0<br> excluded-ip-address 192.168.66.1 192.168.66.2<br>ip pool 88<br> gateway-list 192.168.88.254<br> network 192.168.88.0 mask 255.255.255.0<br> excluded-ip-address 192.168.88.1 192.168.88.2</p>
<p>int vlanif 10<br>dhcp se g<br>int vlanif 20<br>dhcp se g<br>int vlanif 30<br>dhcp se g<br>int vlanif 66<br>dhcp se g<br>int vlanif 88<br>dhcp se g</p>
<p><strong>6.配置OSPF</strong></p>
<p>首先配置ip地址，汇聚交换机vlanif接口配置：过程略</p>
<p>汇聚1：</p>
<p>ospf 1<br> area 0.0.0.0<br> network 192.168.10.0 0.0.0.255<br>network 192.168.20.0 0.0.0.255<br>network 192.168.30.0 0.0.0.255<br>network 192.168.66.0 0.0.0.255<br>network 192.168.88.0 0.0.0.255<br>network 10.0.1.0 0.0.0.3<br>network 10.0.3.0 0.0.0.3</p>
<p>汇聚2：</p>
<p>ospf 1<br> area 0.0.0.0<br> network 192.168.10.0 0.0.0.255<br>network 192.168.20.0 0.0.0.255<br>network 192.168.30.0 0.0.0.255<br>network 192.168.66.0 0.0.0.255<br>network 192.168.88.0 0.0.0.255<br>network 10.0.2.0 0.0.0.3<br>network 10.0.3.0 0.0.0.3</p>
<p>出口路由器：</p>
<p>IP地址：略</p>
<p>ospf 1<br> area 0.0.0.0<br>  network 10.0.1.0 0.0.0.3<br>  network 10.0.2.0 0.0.0.3<br>  network 192.168.60.0 0.0.0.255</p>
<p><strong>7.配置IS-IS</strong></p>
<p>汇聚2和员工宿舍路由器之间用vlanif 43相连：192.168.43.0&#x2F;30网段</p>
<p>汇聚2：</p>
<p>isis 1<br> is-level level-2<br> network-entity 49.0001.0000.0000.0001.00</p>
<p>int vlan 43</p>
<p>isis enable</p>
<p>员工宿舍路由器：</p>
<p>isis 1<br> is-level level-2<br> network-entity 49.0001.0000.0000.0002.00</p>
<p>int g0&#x2F;0&#x2F;0</p>
<p>isis enable</p>
<p><strong>8.员工宿舍区单臂路由</strong></p>
<p>二层交换机：</p>
<p>vlan b 40 50</p>
<p>int e 0&#x2F;0&#x2F;3</p>
<p>p l a</p>
<p>p de v 50</p>
<p>int e 0&#x2F;0&#x2F;1</p>
<p>p l a</p>
<p>p de v 40</p>
<p>int g 0&#x2F;0&#x2F;1</p>
<p>p l t</p>
<p>p t a v 40 50</p>
<p>路由器：</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1.10<br> dot1q termination vid 50<br> ip address 192.168.50.254 255.255.255.0<br> arp broadcast enable</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1.20<br> dot1q termination vid 40<br> ip address 192.168.40.254 255.255.255.0<br> arp broadcast enable</p>
<p><strong>9.汇聚2配置DHCP为员工宿舍区pc分配ip地址</strong></p>
<p>不在同一网段，用dhcp 中继</p>
<p>汇聚2：</p>
<p>ip pool 40<br> gateway-list 192.168.40.254<br> network 192.168.40.0 mask 255.255.255.0</p>
<p>ip pool 50<br> gateway-list 192.168.50.254<br> network 192.168.50.0 mask 255.255.255.0</p>
<p>interface Vlanif43</p>
<p> dhcp select global</p>
<p>员工宿舍区路由器：</p>
<p>开启relay</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1.10</p>
<p> dhcp select relay</p>
<p>dhcp relay server-ip 192.168.43.1</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1.20</p>
<p> dhcp select relay</p>
<p>dhcp relay server-ip 192.168.43.1</p>
<p>子接口宣告进isis 1</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1.10</p>
<p>isis enable 1</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1.20</p>
<p>isis enable 1</p>
<p>此时宿舍区可以获取ip</p>
<p><strong>10.汇聚2 ospf和isis互相引入</strong></p>
<p>使得宿舍区不能访问业务大楼（20）和财政大楼（30）</p>
<p>ospf 1<br> import-route isis 1</p>
<p>isis 1</p>
<p> import-route ospf 1</p>
<p>此时内网全部互通</p>
<p>过滤</p>
<p>汇聚2：</p>
<p>ip ip-prefix aa index 10 permit 192.168.20.0 24 less-equal 32</p>
<p>ip ip-prefix aa index 20 permit 192.168.30.0 24 less-equal 32</p>
<p>route-policy aa deny node 10</p>
<p>if-match ip-prefix aa</p>
<p>route-policy aa permit node 20</p>
<p>isis 1</p>
<p>import-route ospf 1 route-policy aa</p>
<p><strong>11.NAPT</strong></p>
<p>nat address-group 1 200.10.10.5 200.10.10.10</p>
<p>acl 2000<br> rule 5 permit any（都可以访问外网）</p>
<p>interface GigabitEthernet4&#x2F;0&#x2F;0<br> ip address 200.10.10.3 255.255.255.0<br> nat outbound 2000 address-group 1 </p>
<p><strong>12.NAT Server</strong></p>
<p>要求内网正常访问ftp和http服务器</p>
<p>外网只能访问http服务器</p>
<p>nat server protocol tcp global 200.10.10.1 any inside 192.168.60.1<br> nat server protocol tcp global 200.10.10.2 any inside 192.168.60.2 </p>
<p><strong>13.下发缺省路由</strong></p>
<p>出口路由器：</p>
<p>ospf 1<br> default-route-advertise always</p>
<p>汇聚2：</p>
<p>isis 1<br> default-route-advertise always</p>
<p>此时发现pc4ping30网段可以通，但是做了过滤（原因：下发了缺省路由）</p>
<p>PC&gt;ping 192.168.30.253</p>
<p>Ping 192.168.30.253: 32 data bytes, Press Ctrl_C to break<br>From 192.168.30.253: bytes&#x3D;32 seq&#x3D;1 ttl&#x3D;126 time&#x3D;79 ms<br>From 192.168.30.253: bytes&#x3D;32 seq&#x3D;2 ttl&#x3D;126 time&#x3D;93 ms</p>
<p>解决：策略路由做过滤</p>
<p>员工宿舍路由器：</p>
<p>acl 3000</p>
<p>rule deny ip source 192.168.40.0 0.0.0.255 destination 192.168.30.0 0.0.0.255</p>
<p>rule deny ip source 192.168.40.0 0.0.0.255 destination 192.168.20.0 0.0.0.255</p>
<p>rule deny ip source 192.168.50.0 0.0.0.255 destination 192.168.30.0 0.0.0.255</p>
<p>rule deny ip source 192.168.50.0 0.0.0.255 destination 192.168.20.0 0.0.0.255</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;0<br> traffic-filter outbound acl 3000</p>
<p>此时过滤成功</p>
<p><strong>14.ISP区域配置isis</strong></p>
<p>配置ip地址，配置isis：基操，略</p>
<p><strong>15.ISP区域配置IBGP</strong></p>
<p>R5：</p>
<p>bgp 100<br> peer 1.1.1.1 as-number 100<br> peer 1.1.1.1 connect-interface LoopBack0</p>
<p>peer 1.1.1.1 reflect-client（路由反射器配置客户端）</p>
<p>bgp 100<br> peer 2.2.2.2 as-number 100<br> peer 2.2.2.2 connect-interface LoopBack0<br>peer 2.2.2.2 reflect-client</p>
<p>bgp 100<br> peer 3.3.3.3 as-number 100<br> peer 3.3.3.3 connect-interface LoopBack0<br>peer 3.3.3.3 reflect-client</p>
<p>bgp 100<br> peer 4.4.4.4 as-number 100<br> peer 4.4.4.4 connect-interface LoopBack0<br>peer 4.4.4.4 reflect-client</p>
<p>R1R2R3R4：</p>
<p>bgp 100<br> peer 5.5.5.5 as-number 100<br> peer 5.5.5.5 connect-interface LoopBack0</p>
<p>建立EBGP：略</p>
<p><strong>16.公司B做NAT</strong></p>
<p>AR9：</p>
<p>acl 2000</p>
<p>rule permit source any</p>
<p>int g 0&#x2F;0&#x2F;2</p>
<p>nat outbound 2000</p>
<p>nat server global 200.10.20.3 inside 192.168.10.3（nat server）</p>
<p><strong>17.BGP通告路由</strong></p>
<p>公司B访问A园区的服务器，没有路由</p>
<p>需要将200.10.10.0网段路由通告进BGP</p>
<p>AR1：</p>
<p>bgp 100</p>
<p>network 200.10.10.0 24</p>
<p>此时发现路由在R3不是最优的</p>
<p>原因：没有改下一跳</p>
<p>R5：</p>
<p>bgp 100</p>
<p>peer 1.1.1.1 next-hop -local</p>
<p>peer 3.3.3.3 next-hop -local</p>
<p>仍然不是最优</p>
<p>原因：R3在level-1区域，不能学习到level-2区域的路由</p>
<p>解决：isis路由渗透</p>
<p>R5：</p>
<p>isis 1</p>
<p>import-route isis level-2 into level-1</p>
<p>此时是最优</p>
<p>R3也要通告200.10.20.0网段的路由到bgp</p>
<p>R3：</p>
<p>network 200.10.20.0 24</p>
<p>发现R1上可以学习到，并且是最优的</p>
<p>AR9：</p>
<p>（缺省路由）</p>
<p>ip route-static 0.0.0.0 0 200.10.20.1</p>
<p>A园区出口路由器添加缺省路由：</p>
<p>ip route-static 0.0.0.0 0 200.10.10.4</p>
<p>此时公司B应该可以访问A园区的服务器</p>
<p>但是测试ping不通，FTP服务器可以通</p>
<p>原因：做nat server时候没有放通icmp协议，只放通了tcp协议</p>
]]></content>
      <categories>
        <category>综合实验</category>
      </categories>
  </entry>
  <entry>
    <title>SSH</title>
    <url>/2024/05/22/SSH/</url>
    <content><![CDATA[<p><img src="/2024/05/22/SSH/QQ%E6%88%AA%E5%9B%BE20240522163645.png" alt="QQ截图20240522163645"></p>
<p><img src="/2024/05/22/SSH/QQ%E6%88%AA%E5%9B%BE20240522163801.png" alt="QQ截图20240522163801"></p>
<p><img src="/2024/05/22/SSH/QQ%E6%88%AA%E5%9B%BE20240522170905.png" alt="QQ截图20240522170905"></p>
<p>1.server配置rsa<br>[server]rsa local-key-pair create<br>[server]dis rsa local-key-pair public（查看）<br>2.全局开启stelnet<br>[server]stelnet server enable<br>3.vty接口配置<br>[server]user-interface vty 0 4	<br>[server-ui-vty0-4]authentication-mode aaa	<br>[server-ui-vty0-4]protocol inbound ssh<br>4.创建用户名和密码<br>[server]aaa<br>[server-aaa]local-user client01 password cipher huawei123<br>[server-aaa]local-user client01 service-type ssh	<br>[server-aaa]local-user client01 privilege level 3<br>（同理创建client02）<br>5.设置服务端口号<br>[server]ssh server port 1025<br>6.客户端上创建rsa本地密钥<br>[client01]rsa local-key-pair create<br>7.将客户端密钥复制到服务器<br>[server]rsa peer-public-key client01<br>[server-rsa-public-key]public-key-code begin<br>Enter “RSA key code” view, return last view with “public-key-code end”.<br>[server-rsa-key-code]<br>[server-rsa-key-code]3047<br>[server-rsa-key-code]  0240<br>[server-rsa-key-code]    BB44D49F 0A455501 33FC2A58 9EA52FF3 7C3A29A5<br>[server-rsa-key-code]    43A29D63 1D74F975 FAF91466 EF0D2222 A8AE038B<br>[server-rsa-key-code]    2DAA1CE0 5F22B5D9 F6D0F2F0 EB0747B9 4D916AE1<br>[server-rsa-key-code]    5B83DE2D<br>[server-rsa-key-code]  0203<br>[server-rsa-key-code]    010001	<br>[server-rsa-key-code]public-key-code end<br>[server-rsa-public-key]peer-public-key end		<br>[server]ssh user client01 assign rsa-key client01<br>8.客户端上开启SSH首次登录验证<br>[client01]ssh client first-time enable </p>
<p>[client01]stelnet 2.2.2.2 1025（登录）</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>ipv6路由</title>
    <url>/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h1><p>IPv6静态路由与IPv4静态路由类似，也需要管理员手工配置，适合于一些结构比较简单的IPv6网络。</p>
<p>在创建IPv6静态路由时，可以同时指定出接口和下一跳，或者只指定出接口或只指定下一跳。</p>
<p>对于点到点接口：指定出接口。</p>
<p>对于广播类型接口：指定下一跳。</p>
<p>IPv6静态路由负载分担和备份：在创建相同目的地址的多条IPv6静态路由时，如果指定相同优先级，则可实现负载分担，如果指定不同优先级，则可实现路由备份。</p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822213816.png" alt="QQ截图20240822213816"></p>
<h1 id="OSPFv3"><a href="#OSPFv3" class="headerlink" title="OSPFv3"></a>OSPFv3</h1><p>OSPFv3基于链路运行以及拓扑计算，而不再是网段。</p>
<p>OSPFv3支持一个链路上多个实例。</p>
<p>OSPFv3报文和LSA中去掉了IP地址的意义，且重构了报文格式和LSA格式。</p>
<p>OSPFv3报文和Router LSA&#x2F;Network LSA中不包含IP地址。</p>
<p>OSPFv3的LSA中定义了LSA的泛洪范围。OSPFv3中创建了新的LSA承载IPv6地址和前缀。</p>
<p>OSPFv3邻居不再由IP地址标识，只由Router ID标识。</p>
<p>Router id：Router ID长度32 bit，本地标识符，与IPv6地址无关，用点分十进制表示法来表示。</p>
<p>OSPFv3是基于链路运行的，设备只要在同一链路，就可以建立邻居关系。</p>
<p>接口地址不在同一网段，但是R1与R2仍然可以建立OSPFv3邻居关系。OSPFv3运行时，仅需邻居双方处于相同直连链路即可</p>
<p>多实例：一个OSPFv3物理接口可以和多个实例绑定，并用不同的实例标识（Instance ID）区分，即OSPFv3的单个链路支持运行多个OSPFv3实例。这些运行在同一条物理链路上的多个OSPFv3实例，分别与链路对端设备建立邻居及发送报文，且互不干扰，这样可以充分共享同一链路资源。</p>
<p>OSPFv3使用链路本地（FE80::&#x2F;10）地址作为发送报文的源地址和路由的下一跳地址。</p>
<p>使用链路本地地址来维持邻居关系，同步LSA数据库。</p>
<p>优势：不需要配置IPv6全球单播地址，就可以得到OSPFv3拓扑，实现拓扑与地址分离。OSPFv3报文不会被转发到始发链路范围之外，减少了报文不必要的泛洪，节省了带宽。</p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214109.png" alt="QQ截图20240822214109"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214116.png" alt="QQ截图20240822214116"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214125.png" alt="QQ截图20240822214125"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214136.png" alt="QQ截图20240822214136"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214206.png" alt="QQ截图20240822214206"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214210.png" alt="QQ截图20240822214210"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214215.png" alt="QQ截图20240822214215"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214220.png" alt="QQ截图20240822214220"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214226.png" alt="QQ截图20240822214226"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214232.png" alt="QQ截图20240822214232"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214236.png" alt="QQ截图20240822214236"></p>
<h1 id="ISIS"><a href="#ISIS" class="headerlink" title="ISIS"></a>ISIS</h1><p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214345.png" alt="QQ截图20240822214345"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214351.png" alt="QQ截图20240822214351"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214359.png" alt="QQ截图20240822214359"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214413.png" alt="QQ截图20240822214413"></p>
<h1 id="BGP4"><a href="#BGP4" class="headerlink" title="BGP4+"></a>BGP4+</h1><p>MP-BGP支持的地址族有：IPv4单播地址族IPv4组播地址族IPv6单播地址族VPNv4地址族VPNv6地址族</p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214511.png" alt="QQ截图20240822214511"></p>
<p><img src="/2024/08/22/ipv6%E8%B7%AF%E7%94%B1/QQ%E6%88%AA%E5%9B%BE20240822214516.png" alt="QQ截图20240822214516"></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>ospfv3</tag>
        <tag>isis（ipv6）</tag>
        <tag>bgp（ipv6）</tag>
      </tags>
  </entry>
  <entry>
    <title>nat实验</title>
    <url>/2023/11/25/nat%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="静态nat"><a href="#静态nat" class="headerlink" title="静态nat"></a>静态nat</h1><p>静态NAT实现了私有地址和公有地址的一对一映射。如果希望一台主机优先使用某个关联地址，或者想要外部网络使用一个指定的公网地址访问内部服务器时，可以使用静态NAT。但是在大型网络中，这种一对一的IP地址映射无法缓解公用地址短缺的问题。</p>
<span id="more"></span>

<p>静态NAT实现了私有地址和共有地址一对一的映射（一个私有地址对应一个共有地址），并没有做到缓解地址短缺的问题，只是做到了地址转换。</p>
<p>一个公网地址只会分配给唯一且固定的内网地址</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/jingttuopu4509.png" alt="jingttuopu4509"></p>
<p>如图配置ip地址和网关</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/jingta15204327.png" alt="jingta15204327"></p>
<p>r1上配置静态nat（注意是在公网的接口上，出接口）</p>
<p>注意配置一条静态路由，不然没有路由的下一跳会被丢弃</p>
<p>在r1上查看nat映射关系：dis nat static</p>
<p>验证一下：<img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/jingtainatjg25204222.png" alt="jingtainatjg25204222"></p>
<p>发现去往2.2.2.2的源地址变为2.2.2.3，说明nat完成转换。</p>
<p>静态nat两种配置方式：</p>
<p>1.接口下（上述实验采用这种方式）：进入到连接外网路由器的出接口下，然后在接口视图下配置nat映射关系</p>
<p>2.全局：在全局视图下，配置好nat映射关系，再进入到出接口，执行：nat static enable</p>
<h1 id="动态nat"><a href="#动态nat" class="headerlink" title="动态nat"></a>动态nat</h1><p>动态NAT通过使用地址池来实现。</p>
<p>如上图，当内部主机A和主机B需要与公网中的目的主机通信时，网关RTA会从配置的公网地址池中选择一个未使用的公网地址与之做映射。每台主机都会分配到地址池中的一个唯一地址。当不需要此连接时，对应的地址映射将会被删除，公网地址也会被恢复到地址池中待用。当网关收到回复报文后，会根据之前的映射再次进行转换之后转发给对应主机。</p>
<p>注意：</p>
<p>动态NAT实际上实现的还是私有地址和公有地址一对一的关系，但是共有地址不再绑定给特定的内网地址。实现了一定程度的缓解地址短缺问题。<br>动态NAT地址池中的地址用尽以后，只能等待被占用的公用IP被释放后，其他主机才能使用它来访问公网。<img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/dongtaitu00800.png" alt="dongtaitu00800"></p>
<h2 id="动态NAT转换流程："><a href="#动态NAT转换流程：" class="headerlink" title="动态NAT转换流程："></a>动态NAT转换流程：</h2><p>1）路由器上配置一个内部地址池（公司内部所有主机用到的私有IP）动态映射一个外部地址池（所购买的公有IP）。<br>2）当有一个内网主机访问外网时，路由器首先查看NAT地址转换表；<br>3）若无，则再查看是否配置了动态NAT映射，若配置，则将IP包头中的源IP与内部地址池进行匹配，若有匹配项，则将该内网IP从内部地址池中取出，同时取出外部地址池中的一个IP地址，动态形成NAT地址转换表。注意，外部地址池的公网IP地址取出后，外部地址池中将没有该公网IP了。<br>4）默认当该主机24小时没有联系外网时，该动态NAT条目会自动消失，所被取出的公私有地址重新回到地址池中。</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/tuopudawda12714.png" alt="tuopudawda12714"></p>
<p>ip如图，pc的网关192.168.1.254</p>
<p>r1上配置默认路由，ip route-static 0.0.0.0 0 172.16.1.2</p>
<p>r1上配置动态地址池：</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/acldongtai2005212357.png" alt="acldongtai2005212357"></p>
<p>地址池验证：</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/dizhichi1201.png" alt="dizhichi1201"></p>
<p>配置acl策略：</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/acl55da612432.png" alt="acl55da612432"></p>
<p>在r1的外网出接口上调用：</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/natout25212448.png" alt="natout25212448"></p>
<p>验证：</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/dongtaijiegy12547.png" alt="dongtaijiegy12547"></p>
<p>其中源IP为3、4、5不定，说明是在动态分配外网地址。动态NAT配置完成。</p>
<p>在动态NAT实验中，最后利用PC1测试连通性时，间歇性会丢包</p>
<p>可能的原因：ping的时候默认按地址池中可用地址顺序从1~254进行地址转换，放大nat地址池可解决。</p>
<h1 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h1><p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/NApttu39.png" alt="NApttu39"></p>
<p>如上图，RTA收到一个私网主机发送的报文，源IP地址是192.168.1.1，源端口号是1025，目的IP地址是100.1.1.1，目的端口是80。RTA会从配置的公网地址池中选择一个空闲的公网IP地址和端口号，并建立相应的NAPT表项。这些NAPT表项指定了报文的私网IP地址和端口号与公网IP地址和端口号的映射关系。之后，RTA将报文的源IP地址和端口号转换成公网地址200.10.10.1和端口号2843，并转发报文到公网。当网关RTA收到回复报文后，会根据之前的映射表再次进行转换之后转发给主机A。主机B同理。</p>
<p>注意：</p>
<p>NAPT技术允许多个内部地址映射到同一个公有地址的不同端口。<br>NAPT实现了私有地址对共有地址多对一</p>
<p>相当于一种特殊的动态nat</p>
<p>1、端口NAT和动态NAT的配置过程基本一致，只是在应用到接口时，配置命令少no-pat<br>2、端口NAT一个地址可以给多个源地址转换，不是单对单的转换，所以节省了nat地址！<br>3、端口NAT实际应用较多，静态NAT和动态NAT因为地址不能节约，所以实际应用少</p>
<h1 id="Easy-IP"><a href="#Easy-IP" class="headerlink" title="Easy IP"></a>Easy IP</h1><p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/easydahwka5.png" alt="easydahwka5"></p>
<p>Easy IP本质上是NAPT（所以原理与NAPT大致相似）<br>由于网关设备出接口IP地址为公网地址，所以可以利用该<strong>出接口地址</strong>来作为地址转换的公有地址。<br>Easy IP适用于小规模局域网中的主机访问Internet的场景。小规模局域网通常部署在小型的网吧或者办公室中，这些地方内部主机不多，出接口可以通过拨号方式获取一个临时公网IP地址。Easy IP可以实现内部主机使用这个临时公网IP地址访问Internet。</p>
<p>Easy IP适用于小规模局域网中的主机访问Internet的场景。小规模局域网通常部署在小型的网吧或者办公室中，这些地方内部主机不多，出接口可以通过拨号方式获取一个临时公网IP地址。Easy IP可以实现内部主机使用这个临时公网IP地址访问Internet。</p>
<h2 id="Easy-IP的配置："><a href="#Easy-IP的配置：" class="headerlink" title="Easy IP的配置："></a>Easy IP的配置：</h2><p>1.创建ACL：acl 2000</p>
<p>2.允许1.0的数据进行转换：rule 5 permit source 192.168.1.0 0 .0.0.255</p>
<p>3.进入公网出接口</p>
<p>4.应用acl：nat outbound 2000</p>
<p>（相较于napt少了地址池）</p>
<p>验证：</p>
<p><img src="/2023/11/25/nat%E5%AE%9E%E9%AA%8C/easadwaawh215116.png" alt="easadwaawh215116"></p>
<p>源地址为出接口地址172.16.1.1，只是端口不同</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>nat</tag>
      </tags>
  </entry>
  <entry>
    <title>opsf总结</title>
    <url>/2024/04/18/opsf%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="ospf协议工作原理"><a href="#ospf协议工作原理" class="headerlink" title="ospf协议工作原理"></a>ospf协议工作原理</h1><p>工作过程：①建立邻居关系（hello   2-way状态）每台路由器都会产生lsa，路由器将接收到的lsa放入自己的lsdb中；②同步LSDB（DD、LSR、LSU、LSACK    full状态）；③计算路由（本路由器通过自己的LSDB，以自己为根节点，计算最短路径树，最终得到路由）SPF算法；</p>
<p>ospf支持的网络类型：广播、NBMA、点到点、点到多点</p>
<p>ospf计算；计算路由+计算拓扑</p>
<p>ospf报文采用IP封装，协议号89，</p>
<p>ospfv2（ipv4），ospfv3（ipv6）</p>
<p>ospf组播更新</p>
<p>224.0.0.5（所有运行ospf协议的路由器侦听）</p>
<p>224.0.0.6（DR和BDR侦听）</p>
<h1 id="Router-id"><a href="#Router-id" class="headerlink" title="Router id"></a>Router id</h1><p>在自治系统中唯一标识一台运行ospf的路由器，32位无符号整数</p>
<p>选举规则：手动配置（建议），如果没有手动配置，则路由器使用Loopback接口中最大的IP地址作为Router id，如果没有配置Loopback接口，则使用物理接口中最大的IP地址</p>
<h1 id="Cost值"><a href="#Cost值" class="headerlink" title="Cost值"></a>Cost值</h1><p>缺省接口cost&#x3D;（100mib&#x2F;s）&#x2F; 接口带宽，修改100mid&#x2F;s改变cost</p>
<p>也可以直接修改</p>
<p>累计cost作为开销值，流量从源网络到目的网络所经过所有路由器的出接口的cost总和</p>
<h1 id="Hello报文"><a href="#Hello报文" class="headerlink" title="Hello报文"></a>Hello报文</h1><p><img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%871.png" alt="图片1"></p>
<p>发送间隔10s，失效40s，修改发送，失效也变，失效始终为发送的4倍</p>
<p>命令：接口视图下，ospf timer hello 10</p>
<p>ospf邻居建立失败 ，可能原因：①物理链路故障；②ospf版本不一致；③区域ID不一致；④认证类型不一致；⑤认证数据不一致；⑥掩码不一致；（只出现在广播型网络中，点到点网络不检查掩码信息）⑦hello报文间隔不一致；⑧router id一致；（华为设备遇到router id一致，会重新配置router id）</p>
<h1 id="DD报文"><a href="#DD报文" class="headerlink" title="DD报文"></a>DD报文</h1><p>DD报文部分字段解释<br>I：当发送连续多个DD报文时，如果这是第一个DD报文，则置为1，否则置为0。<br>M (More)：当发送连续多个DD报文时，如果这是最后一个DD报文，则置为0。否则置为1，表示后面还有其他的DD报文。<br>MS (Master&#x2F;Slave)：当两台OSPF路由器交换DD报文时，首先需要确定双方的主从关系，Router ID大的一方会成为Master。当值为1时表示发送方为Master。<br>DD sequence number：DD报文序列号。主从双方利用序列号来保证DD报文传输的可靠性和完整性。</p>
<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/图片2.png" alt="图片2" style="zoom:50%;">

<p>链路状态类型、链路状态ID、通告路由器三元组唯一地标识了一个LSA。<br>链路状态老化时间 、链路状态序列号 、校验和用于判断LSA的新旧</p>
<h1 id="ospf状态机"><a href="#ospf状态机" class="headerlink" title="ospf状态机"></a>ospf状态机</h1><p>之前的手写笔记😍</p>
<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ图片20240418204859.jpg" alt="QQ图片20240418204859" style="zoom:50%;">

<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ图片20240418204932.jpg" alt="QQ图片20240418204932" style="zoom:50%;">

<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ图片20240418204926.jpg" alt="QQ图片20240418204926" style="zoom:50%;">

<h1 id="DR和BDR"><a href="#DR和BDR" class="headerlink" title="DR和BDR"></a>DR和BDR</h1><p>既侦听224.0.0.5也侦听224.0.0.6</p>
<p>每个网段选举一个</p>
<p>DR：指定路由器，负责在MA网络中建立和维护邻接关系，并负责lsa同步</p>
<p>DR和其他所有路由器形成邻接关系，其他路由器之间不直接交换链路状态信息</p>
<p>在DR失效时候，BDR接替</p>
<p>DR默认优先级1（0-255）越大越优，非抢占，优先级为0的不参与选举</p>
<h1 id="路由类型"><a href="#路由类型" class="headerlink" title="路由类型"></a>路由类型</h1><p>下表中按优先级从高到低顺序列出了路由类型</p>
<table>
<thead>
<tr>
<th>路由类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Intra Area</td>
<td>区域内路由。</td>
</tr>
<tr>
<td>Inter Area</td>
<td>区域间路由。</td>
</tr>
<tr>
<td>第一类外部路由（Type1 External）</td>
<td>这类路由的可信程度高一些，所以计算出的外部路由的开销与自治系统内部的路由开销是相当的，并且和OSPF自身路由的开销具有可比性。到第一类外部路由的开销&#x3D;本设备到相应的ASBR的开销+ASBR到该路由目的地址的开销。</td>
</tr>
<tr>
<td>第二类外部路由（Type2 External）</td>
<td>这类路由的可信度比较低，所以OSPF协议认为从ASBR到自治系统之外的开销远远大于在自治系统之内到达ASBR的开销。所以，OSPF计算路由开销时只考虑ASBR到自治系统之外的开销，即到第二类外部路由的开销&#x3D;ASBR到该路由目的地址的开销。</td>
</tr>
</tbody></table>
<h1 id="LSA"><a href="#LSA" class="headerlink" title="LSA"></a>LSA</h1><table>
<thead>
<tr>
<th>LSA类型</th>
<th>LSA作用</th>
</tr>
</thead>
<tbody><tr>
<td>Router-LSA（Type1）</td>
<td>每个设备都会产生，描述了设备的链路状态和开销，在所属的区域内传播。</td>
</tr>
<tr>
<td>Network-LSA（Type2）</td>
<td>由DR（Designated Router）产生，描述本网段的链路状态，在所属的区域内传播。</td>
</tr>
<tr>
<td>Network-summary-LSA（Type3）</td>
<td>由ABR产生，描述区域内某个网段的路由，并通告给发布或接收此LSA的非Totally STUB或NSSA区域。例如：ABR同时属于Area0和Area1，Area0内存在网段10.1.1.0，Area1内存在网段11.1.1.0，ABR为Area0生成到网段11.1.1.0的Type3 LSA；ABR为Area1生成到网段10.1.1.0的Type3 LSA，并通告给发布或接收此LSA的非Totally Stub或NSSA区域。</td>
</tr>
<tr>
<td>ASBR-summary-LSA（Type4）</td>
<td>由ABR产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。</td>
</tr>
<tr>
<td>AS-external-LSA（Type5）</td>
<td>由ASBR产生，描述到AS外部的路由，通告到所有的区域（除了STUB区域和NSSA区域）。</td>
</tr>
<tr>
<td>NSSA LSA（Type7）</td>
<td>由ASBR产生，描述到AS外部的路由，仅在NSSA区域内传播。</td>
</tr>
<tr>
<td>Opaque LSA（Type9&#x2F;Type10&#x2F;Type11）</td>
<td>Opaque LSA提供用于OSPF的扩展的通用机制。其中：Type9 LSA仅在接口所在网段范围内传播。用于支持GR的Grace LSA就是Type9 LSA的一种。Type10 LSA在区域内传播。用于支持TE的LSA就是Type10 LSA的一种。Type11 LSA在自治域内传播，目前还没有实际应用的例子。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>区域类型</th>
<th>Router-LSA（Type1）</th>
<th>Network-LSA（Type2）</th>
<th>Network-summary-LSA（Type3）</th>
<th>ASBR-summary-LSA（Type4）</th>
<th>AS-external-LSA（Type5）</th>
<th>NSSA LSA（Type7）</th>
</tr>
</thead>
<tbody><tr>
<td>普通区域（包括标准区域和骨干区域）</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>Stub区域</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>Totally Stub区域</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>NSSA区域</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>Totally NSSA区域</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="路由器类型"><a href="#路由器类型" class="headerlink" title="路由器类型"></a>路由器类型</h4><h1 id="Router-LSA（1类）"><a href="#Router-LSA（1类）" class="headerlink" title="Router LSA（1类）"></a>Router LSA（1类）</h1><p>单区域中会用到1类、2类LSA</p>
<p>Router LSA—1类LSA  <strong>所有的路由器都会产生</strong>，描述本路由器的信息  泛洪区域：本区域</p>
<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ截图20240717173559.png" alt="QQ截图20240717173559" style="zoom: 50%;">



<p>Router LSA使用Link来承载路由器直连接口的信息。<br>每条Link均包含“链路类型”、“链路ID”、“链路数据”以及“度量值”这几个关键信息。<br>路由器可能会采用一个或者多个Link来描述某个接口。<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/图片3.png" alt="图片3" style="zoom: 67%;"></p>
<p><strong>1.link type：p2p</strong> </p>
<p>link-id：对端的route-id</p>
<p>data：连接对端接口的ip</p>
<p><strong>2.link type：transnet</strong></p>
<p>link-id：DR的接口ip地址</p>
<p>data：连接DR的接口ip</p>
<p><strong>3.link type：stubnet</strong> </p>
<p>link-id：网络地址</p>
<p>data：掩码</p>
<p><strong>4，link type：vlink</strong>（和p2p一样）</p>
<p>link-id：对端的route-id</p>
<p>data：连接对端接口的ip地址</p>
<p>广播型网络中链路类型：TransNet</p>
<p>点到点网络中链路类型：point-to-point  （拓扑信息）、stubnet（网络信息）</p>
<p>Router LSA中链路状态类型、链路状态ID、通告路由器用谁表示：</p>
<p>链路状态类型：router</p>
<p>链路状态ID：本路由器的router id</p>
<p>通告路由器：本路由</p>
<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ截图20240717173856.png" alt="QQ截图20240717173856" style="zoom:50%;">

<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ截图20240717173958.png" alt="QQ截图20240717173958" style="zoom:50%;">



<h1 id="Network-LSA（2类）"><a href="#Network-LSA（2类）" class="headerlink" title="Network LSA（2类）"></a>Network LSA（2类）</h1><p>Network  LSA–2类LSA  DR路由器   泛洪区域：本区域</p>
<p>Network LSA中链路状态类型、链路状态ID、通告路由器用谁表示：</p>
<p>链路状态类型：network</p>
<p>链路状态ID：DR路由器的接口IP地址</p>
<p>通告路由器：DR路由器的router id</p>
<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ截图20240717173423.png" alt="QQ截图20240717173423" style="zoom: 50%;">

<p>Link State ID ：DR的接口IP地址。</p>
<p>Network Mask：MA网络的子网掩码。</p>
<p>Attached Router：连接到该MA网络的路由器的Router-ID（与该DR建立了邻接关系的邻居的Router-ID，以及DR自己的Router-ID），如果有多台路由器接入该MA网络，则使用多个字段描述。</p>
<h1 id="Network-LSA（3类）"><a href="#Network-LSA（3类）" class="headerlink" title="Network LSA（3类）"></a>Network LSA（3类）</h1><p>3类LSA   ABR产生，泛洪范围本区域  作用：用于向一个区域通告到达另一个区域的路由</p>
<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/图片4.png" alt="图片4" style="zoom: 50%;">

<p>三类lsa传递的cost计算</p>
<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ截图20240717174351.png" alt="QQ截图20240717174351" style="zoom:50%;">



<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ截图20240717174431.png" alt="QQ截图20240717174431" style="zoom:50%;">



<p><strong>区域间防环</strong>：</p>
<p>1）非骨干区必须和骨干区area0相连，非骨干区不能直接进行通信</p>
<p>2）三类LSA传递是 单向的</p>
<p>3）从非骨干区域收到的3类LSA不能用于区域间路由的计算。</p>
<h1 id="虚连接"><a href="#虚连接" class="headerlink" title="虚连接"></a>虚连接</h1><p>OSPF要求骨干区域必须是连续的，但是并不要求物理上连续，可以使用虚连接使骨干区域在逻辑上连续。</p>
<p>虚连接可以在任意两个<strong>ABR</strong>上建立，但是要求这两个ABR都有端口<strong>连接到一个相同的非骨干区域</strong>。</p>
<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ截图20240717174832.png" alt="QQ截图20240717174832" style="zoom:50%;">

<p>建立之后</p>
<p>R3会有area 0 ，area 2， area 1 的lsdb</p>
<p>R2有area 0，area 1的lsdb（注意没有area 2，因为R2建立虚连接的接口属于area 1，R3建立虚连接的接口属于area 1）</p>
<h1 id="AS-External-LSA（5类）"><a href="#AS-External-LSA（5类）" class="headerlink" title="AS External LSA（5类）"></a>AS External LSA（5类）</h1><p>AS-external LSA（5类LSA）：由ASBR产生，描述到达AS外部的路由，该LSA会被通告到所有的区域</p>
<p>LS Type：取值5，代表AS-external-LSA。<br>Link State ID：外部路由的目的网络地址。<br>Advertising Router：生成该LSA的Router ID。<br>Network Mask：网络掩码。</p>
<h1 id="ASBR-Summary-LSA（4类）"><a href="#ASBR-Summary-LSA（4类）" class="headerlink" title="ASBR-Summary LSA（4类）"></a>ASBR-Summary LSA（4类）</h1><p>ASBR-Summary LSA（4类LSA）：由ABR产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。</p>
<p>LS Type：取值4，代表ASBR-Summary LSA。<br>Link State ID ：ASBR的Router ID。<br>Advertising Router:生成LSA的Router ID。 </p>
<p>ospf外部路由在引入时，开销值类型有两种：默认情况是type-2</p>
<p><img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/wps1.jpg" alt="img"> </p>
<p>配置：[R7-ospf-1]import-route direct type 1</p>
<p>OSPF路由遵循以下优先级顺序，区域内路由&gt;区域间路由&gt;Metric-Type-1外部路由&gt;Metric-Type-2外部路由。</p>
<h1 id="ospf路由汇总"><a href="#ospf路由汇总" class="headerlink" title="ospf路由汇总"></a>ospf路由汇总</h1><p>OSPF路由汇总的类型：<br>在ABR执行路由汇总：对区域间的路由执行路由汇总。<br>在ASBR执行路由汇总：对引入的外部路由执行路由汇总。</p>
<p>区域间路由汇总在ABR设备上配置：</p>
<p>[R6-ospf-1-area-0.0.0.3]abr-summary 172.16.0.0 255.255.252.0</p>
<p>外部路由汇总在ASBR上配置：</p>
<p>[R8-ospf-1]asbr-summary 10.1.0.0 255.255.240.0</p>
<h1 id="ospf认证"><a href="#ospf认证" class="headerlink" title="ospf认证"></a>ospf认证</h1><p>OSPF支持报文认证功能，只有通过认证的OSPF报文才能被接收。<br>路由器支持两种OSPF报文认证方式，当两种认证方式都存在时，<strong>优先使用接口认证方式</strong>：<br>区域认证方式：一个OSPF区域中所有的路由器在该区域下的认证模式和口令必须一致。</p>
<p>根据报文的认证方式，可以分为：</p>
<ul>
<li><p>空认证</p>
<p>不进行认证。</p>
</li>
<li><p>明文认证</p>
<p>这是一种简单的加密方式，将配置的密码直接加入报文中，这种加密方式安全性不高。</p>
</li>
<li><p>MD5认证</p>
<p>通过将配置的密码进行MD5等加密算法之后再加入报文中，这样提高了密码的安全性。目前支持MD5&#x2F;HMAC-MD5。</p>
</li>
<li><p>Keychain认证</p>
<p>Keychain由多个认证密钥组成，每个密钥包含一个ID和密码。密钥存在生命期，通过密钥的生命期可以在Keychain中滚动选择不同的认证密钥。Keychain可以滚动选择认证密钥来增强防攻击性。</p>
<p>Keychain为OSPF提供了认证保护，Keychain通过动态的更改认证算法和密钥，提高了OSPF的安全性。应用Keychain认证，除了可以对OSPF协议报文进行认证之外，还可以对TCP建立连接的过程进行认证。</p>
</li>
<li><p>HMAC-SHA256认证</p>
<p>通过将配置的密码进行HMAC-SHA256算法加密之后再加入报文中，提高密码的安全性。</p>
</li>
</ul>
<p>[R6-ospf-1-area-0.0.0.3]authentication-mode md5 1 cipher huawei</p>
<p>该区域中所有路由器都要配置</p>
<p>接口认证方式：相邻路由器直连接口下的认证模式和口令必须一致。<br>[R2-GigabitEthernet0&#x2F;0&#x2F;0]ospf authentication-mode md5 1 cipher huawei</p>
<p>在一条链路上的所有接口下配置</p>
<h1 id="特殊区域"><a href="#特殊区域" class="headerlink" title="特殊区域"></a>特殊区域</h1><table>
<thead>
<tr>
<th>区域类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>普通区域</td>
<td>缺省情况下，OSPF区域被定义为普通区域。普通区域包括标准区域和骨干区域。标准区域是最通用的区域，它传输区域内路由，区域间路由和外部路由。骨干区域是连接所有其他OSPF区域的中央区域。骨干区域通常用Area 0表示。</td>
</tr>
<tr>
<td>STUB区域</td>
<td>不允许发布自治系统外部路由，只允许发布区域内路由和区域间的路由。在STUB区域中，路由器的路由表规模和路由信息传递的数量都会大大减少。为了保证到自治系统外的路由可达，由该区域的ABR发布Type3缺省路由传播到区域内，所有到自治系统外部的路由都必须通过ABR才能发布。</td>
</tr>
<tr>
<td>Totally STUB区域</td>
<td>不允许发布自治系统外部路由和区域间的路由，只允许发布区域内路由。在Totally STUB区域中，路由器的路由表规模和路由信息传递的数量都会大大减少。为了保证到自治系统外和其他区域的路由可达，由该区域的ABR发布Type3缺省路由传播到区域内，所有到自治系统外部和其他区域的路由都必须通过ABR才能发布。</td>
</tr>
<tr>
<td>NSSA区域</td>
<td>NSSA区域允许引入自治系统外部路由，由ASBR发布Type7 LSA通告给本区域，这些Type7 LSA在ABR上转换成Type5 LSA，并且泛洪到整个OSPF域中。NSSA区域同时保留自治系统内的STUB区域的特征。该区域的ABR发布Type7缺省路由传播到区域内，所有域间路由都必须通过ABR才能发布。</td>
</tr>
<tr>
<td>Totally NSSA区域</td>
<td>Totally NSSA区域允许引入自治系统外部路由，由ASBR发布Type7 LSA通告给本区域，这些Type7 LSA在ABR上转换成Type5 LSA，并且泛洪到整个OSPF域中。Totally NSSA区域同时保留自治系统内的Totally STUB Area区域的特征。该区域的ABR发布Type3和Type7缺省路由传播到区域内，所有域间路由都必须通过ABR才能发布。</td>
</tr>
</tbody></table>
<h1 id="stub区域"><a href="#stub区域" class="headerlink" title="stub区域"></a>stub区域</h1><p>1、2、3、3类缺省LSA（ABR产生的）</p>
<p>Stub区域的ABR不向Stub区域内传播它接收到的AS外部路由（也就是4类、5类LSA），Stub区域中路由器的LSDB、路由表规模都会大大减小。<br>为保证Stub区域能够到达AS外部，Stub区域的ABR将生成一条<strong>缺省路由（使用3类LSA描述）</strong>。</p>
<p>配置Stub区域时需要注意下列几点：<br>骨干区域不能被配置为Stub区域。<br>Stub区域中的所有路由器都必须将该区域配置为Stub。<br>Stub区域内不能引入也不接收AS外部路由。<br>虚连接不能穿越Stub区域。</p>
<h1 id="Totally-Stub区域"><a href="#Totally-Stub区域" class="headerlink" title="Totally Stub区域"></a>Totally Stub区域</h1><p>1、2、3类缺省LSA（ABR产生的）</p>
<p><strong>Totally Stub区域既不允许AS外部路由在本区域内传播，也不允许区域间路由在本区域内传播。</strong><br>Totally Stub区域内的路由器通过本区域ABR下发的缺省路由（使用3类LSA描述）到达其他区域，以及AS外部<br>配置Totally Stub区域时需要注意：<br>与Stub区域配置的区别在于，<strong>在ABR上</strong>需要追加no-summary关键字。</p>
<h1 id="NSSA"><a href="#NSSA" class="headerlink" title="NSSA"></a>NSSA</h1><p>产生背景：</p>
<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/beijing62657.png" alt="beijing62657" style="zoom:50%;">

<p>1、2、3、7类、7类缺省LSA（ABR产生的）</p>
<p><strong>NSSA区域能够引入外部路由，同时又不会学习来自OSPF网络其它区域引入的外部路由</strong>。Totally NSSA与NSSA区域的配置区别在于前者在<strong>ABR</strong>上需要追加no-summary关键字。</p>
<p>NSSA区域 相对于stub区别在于，可以引入外部路由，外部路由引入后，会以<strong>7类LSA</strong>在NSSA区域中泛洪，然后 在ABR设备上将7类LSA转化成5类LSA在其他区域 泛洪。为了让NSSA区域内的路由器能够通过骨干区域到达AS外部，NSSA区域的ABR会自动向该区域注入一条缺省路由，该路由采用7类LSA描述。</p>
<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ截图20240718163034.png" alt="QQ截图20240718163034" style="zoom:50%;">

<p><strong>说明：</strong>上图中，R3上执行7转5的操作，把5类的lsa泛洪到其他区域，别的区域会认为R3是ASBR（实际是R5），R2作为ABR会发布4类lsa，来描述R3的位置</p>
<p>Totally  NSSA：1、2、3缺省（ABR产生）、7类、7类缺省LSA（ABR产生的）</p>
<h1 id="Silent-Interface"><a href="#Silent-Interface" class="headerlink" title="Silent-Interface"></a>Silent-Interface</h1><p>Silent-Interface有以下特性：<br>Silent-Interface不会接收和发送OSPF报文。<br>Silent-Interface的直连路由仍可以发布出去。</p>
<p>通常我们会 将连接终端或者服务器的接口设置成Silent-Interface</p>
<p>[R1]ospf<br>[R1-ospf-1]area 0<br>[R1-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255<br>[R1-ospf-1]silent-interface GigabitEthernet 0&#x2F;0&#x2F;1</p>
<p>例</p>
<img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/sli20.png" alt="sli20" style="zoom:67%;">

<p>R1的GE0&#x2F;0&#x2F;1接口在OSPF network命令的网段范围内。</p>
<p>到达该接口的路由将被通告到OSPF，使得其他设备能够访问Server。</p>
<p>由于该接口上未连接任何其他OSPF路由器，因此管理员将该接口配置为Silent-Interface，该接口将不再收发Hello报文，从而避免了对Server的性能降低。</p>
<h1 id="路由器对lsa处理流程"><a href="#路由器对lsa处理流程" class="headerlink" title="路由器对lsa处理流程"></a>路由器对lsa处理流程</h1><p><img src="/2024/04/18/opsf%E6%80%BB%E7%BB%93/QQ%E5%9B%BE%E7%89%8720240418211229.jpg" alt="QQ图片20240418211229"></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>ospf</tag>
      </tags>
  </entry>
  <entry>
    <title>rstp和mstp</title>
    <url>/2023/12/07/rstp%E5%92%8Cmstp/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>STP三个版本：</strong><br>STP（802.1d）<br>RSTP（802.1w）<br>MSTP （802.1s）<br>作用：打破二层环路，实现设备或者链路的冗余<br><strong>STP的计算过程</strong><br>①选举根桥<br>BID&#x3D;优先级+MAC，优先级值越小越优，如果优先级相等，MAC小的成为根桥<br>②选举根端口<br>RPC（小的越优）+上行交换机的BID+上行交换机的PID（优先级和接口ID，越小越优）+本地的PID<br>③选举指定接口<br>RPC（小的越优）+本端的BID+本端的PID（小的越优）<br>④非指定接口</p>
<p><strong>端口优先级</strong></p>
<p>端口ID（pid）&#x3D; 端口优先级（Port Priority）4 bit+ 端口编号12 bit 构成； 缺省情况下，端口优先级是128；端口优先级取值范围是0到240，取值必须为16的整数倍。</p>
<p><strong>优先级</strong></p>
<p>默认32768</p>
<p>越小越优</p>
<p>必须是4096倍数</p>
<p>0-65535</p>
<p><strong>接口根路径开销：</strong></p>
<p>1、dot1t<br>G：20000<br>E：200000</p>
<p>PRC&#x3D;根桥到非根桥经过所有的入方向接口的cost累加</p>
<p><strong>STP的收敛时间：</strong></p>
<p>①根桥故障<br>50s<br>②直连链路发生故障<br>30s<br>③非直连链路故障<br>50s</p>
<p>转发延迟计时器：15s<br>BPDU发送时间：2s<br>老化时间：20s</p>
<p><strong>端口状态：</strong><br>disable:未启用<br>blocking：阻塞<br>listening:侦听<br>learning:学习<br>forwarding：转发</p>
<p><strong>RSTP:</strong><br><strong>一、端口角色：</strong><br>根端口<br>指定端口<br>A:根端口的备份端口，提供了指定桥到达根的另一条路径<br>Backup:<br>作为指定接口的备份，提供了另一条从根桥到相应网段的备份链路</p>
<p><strong>二、端口状态</strong><br>Discarding状态：不转发用户流量也不学习MAC地址；<br>Learning状态：不转发用户流量但是学习MAC地址；<br>Forwarding状：既转发用户流量又学习MAC地址<br><strong>三、配置BPDU</strong><br>BPDU类型和flag字段<br><strong>四、配置BPDU的处理</strong><br>拓扑稳定后，运行RSTP协议的非根桥设备会定期的发送配置BPDU<br>RSTP的任何端口角色都会处理次优BPDU，从而加快拓扑收敛<br><strong>五、P&#x2F;A</strong><br>作用：保证一个指定接口从discarding—&gt;forwarding<br>触发：只有指定discarding状态下才可以触发P&#x2F;A机制，必须是根端口在forwarding状态下回复一个A&#x3D;1的一个BPDU</p>
<p>① 选举根桥、根接口、指定接口，然后根接口、指定接口处于discarding<br>②根桥的指定接口处于discarsing，触发到P&#x2F;A，根桥会从指定接口发送P&#x3D;1BPDU；<br>③非根桥的根接口收到P&#x3D;1的BPDU，会启动一个同步过程，将非边缘接口全部阻塞，同步完成之后，根接口切换到转发状态，并且从根接口发送A&#x3D;1 BPDU<br>④根桥收到A&#x3D;1 BPDU，立即切换为转发状态，实现指定接口的快速收敛</p>
<p><strong>保护功能：</strong><br><strong>1、BPDU保护</strong><br>存在问题：边缘端口收到BPDU之后，接口会变成普通接口，那么会引起网络中生成树重新计算，对网络造成影响。<br>解决：开启BPDU保护功能，只要边缘端口收到BPDU，交换机立即把接口置位Error-down，同时会产生告警。（接口恢复两种方式：手工恢复、自动恢复）</p>
<p><strong>2、根保护</strong></p>
<p>存在问题：加入在一个稳定的STP网络，此时根桥连接一台交换机，该交换机支持生成树，发送BPDU，STP网络重新计算；如果新加入的交换机比根桥优先级更优，会抢占根桥的位置，从而引起网络震荡<br>解决：根桥的指定接口下激活跟保护功能，如何接口收到了更优的BPDU，会忽略并且切换到discarding。<br>注意：跟保护只能在指定接口下激活。<br>状态恢复：如果接口不再收到更优的BPDU，在一段时间后（2*转发延迟时间）自动恢复转发状态。</p>
<p><strong>3、环路保护</strong><br>存在问题：<br>AP单向故障：假如交换机之间通过光纤（一收一发），链路发生单向故障，AP接口老化时间后没有收到BPDU,接口会成为DP并切换到转发状态，并转发流量，环路产生<br>RP单向故障：假如交换机之间通过光纤（一收一发），链路发生单向故障，导致DP到RP的单向故障，RP在一段时间没有收到BPDU，AP会切换到RP角色，RP切换到DP，收敛完成，DP开始转发业务流量，环路产生。<br>解决：在AP接口下开启环路保护功能，如何接口长时间没有BPDU	,那么AP接口切换成DP，端口状态保持discarding状态，避免环路。</p>
<p>在RP接口下开启环路保护功能，如何接口长时间没有BPDU，那么会重新计算选举根端口，并将原端口调整为DP，接口状态保持discarding状态，避免环路。</p>
<p><strong>4、拓扑变更保护（TC protection）</strong><br>存在问题：假如网络中存在攻击者，会仿冒TC置位为1的BPDU报文发送大量的TC BPDU，交换机收到BPDU之后，会删除mac地址表项，会消耗大量的设备资源。<br>解决：默认情况交换机开启了拓扑变更保护，缺省2s只会处理异常TC BPDU，超出的部分等待一段时间处理</p>
<p><strong>如何生成STP树？</strong><br>主要通过比较4个参数：根桥ID、根路径开销、网桥ID和端口ID，值越小，越优先。而这些参数，都是报文BPDU中的字段。<br>根桥选举：比较根桥ID，最小胜出。<br>根端口选举：依次比较RPC、对端BID、对端PID和本端PID，最小胜出。<br>指定端口选举：依次比较RPC、本端BID和本端PID，最小胜出。</p>
<p><strong>在确定了根端口和指定端口之后，交换机上所有剩余的非根端口和非指定端口被阻塞。</strong></p>
<p><strong>MSTP：</strong><br><strong>一、概念</strong><br>MST Region：Multiple Spanning Tree Region，多生成树域），也可简称MST域<br>MSTI（Multiple Spanning Tree Instance，多生成树实例）：MSTI使用Instance ID标识，为0~4094。<br>Instance0是缺省存在的，而且缺省时，华为交换机上所有的VLAN都映射到了Instance0。<br>通过设置VLAN映射表（即VLAN和MSTI的对应关系表），把VLAN和MSTI联系起来。<br>每个VLAN只能对应一个MSTI，即同一VLAN的数据只能在一个MSTI中传输，而一个MSTI可能对应多个VLAN。<br>CST公共生成树：是连接交换网络内所有MST域的一棵生成树<br>IST（内部生成树）是各MST域内的一棵生成树。<br>CIST（公共和内部生成树）<br>通过生成树协议计算生成的，连接一个交换网络内所有交换设备的单生成树<br>SST（Single Spanning Tree，单生成树）有两种情况：<br>运行生成树协议的交换设备只能属于一个生成树。<br>MST域中只有一个交换设备，这个交换设备构成单生成树。</p>
<p>总根（CIST Root）是CIST的根桥</p>
<p>域根（Regional Root）<br>分为IST域根和MSTI域根。<br>IST域根，在MST域中IST生成树中距离总根最近的交换设备是IST域根，<br>MSTI域根是每个多生成树实例的树根</p>
<p>主桥（Master Bridge）是IST Master，它是域内距离总根最近的交换设备，如果总根在MST域中，则总根为该域的主桥</p>
<p><strong>新增的端口角色：</strong><br>①Master端口</p>
<p>Master端口是MST域和总根相连的所有路径中最短路径上的端口，它是交换设备上连接MST域到总根的端口。<br>Master端口是域中的报文去往总根的必经之路。<br>Master端口是特殊域边缘端口，Master端口在CIST上的角色是Root Port，在其它各实例上的角色都是Master端口。</p>
<p>②域边缘端口<br>域边缘端口是指位于MST域的边缘并连接其它MST域或SST的端口</p>
<p>MSTP计算<br>优先级向量说明：<br>根交换设备ID：根交换设备ID用于选择CIST中的根交换设备。<br>根交换设备ID &#x3D; Priority(16 bit) + MAC(48 bit)。<br>其中Priority为MSTI0的优先级。<br>外部路径开销（External Root Path Cost，ERPC）：从CIST的域根到达总根的路径开销。<br>MST域内所有交换设备上保存的外部路径开销相同。<br>若CIST根交换设备在域中，则域内所有交换设备上保存的外部路径开销为0。<br>域根ID：域根ID用于选择MSTI中的域根。<br>域根ID &#x3D; Priority(16 bit) + MAC(48 bit)。<br>其中Priority为MSTI0的优先级。<br>内部路径开销（Internal Root Path Cost，IRPC）：本桥到达域根的路径开销。<br>域边缘端口保存的内部路径开销大于非域边缘端口保存的内部路径开销。<br>指定交换设备ID：CIST或MSTI实例的指定交换设备是本桥通往域根的最邻近的上游桥。<br>如果本桥就是总根或域根，则指定交换设备为自己。<br>指定端口ID：指定交换设备上同本设备上根端口相连的端口。<br>Port ID &#x3D; Priority(4 bit) + 端口号（12 bit）。<br>端口优先级必须是16的整数倍。<br>接收端口ID：接收到BPDU报文的端口。<br>Port ID &#x3D; Priority(4 bit) + 端口号（12 bit）。</p>
<p><strong>端口优先级必须是16的整数倍。</strong></p>
<p>优先级向量比较原则：<br>同一向量比较，值最小的向量具有最高优先级。<br>优先级向量比较原则如下<br>首先，比较根交换设备ID。<br>如果根交换设备ID相同，再比较外部路径开销。<br>如果外部路径开销相同，再比较域根ID。<br>如果域根ID仍然相同，再比较内部路径开销。<br>如果内部路径仍然相同，再比较指定交换设备ID。<br>如果指定交换设备ID仍然相同，再比较指定端口ID。<br>如果指定端口ID还相同，再比较接收端口ID。<br>如果端口接收到的BPDU内包含的配置消息优于端口上保存的配置消息，则端口上原来保存的配置消息被新收到的配置消息替代。端口同时更新交换设备保存的全局配置消息。反之，新收到的BPDU被丢弃。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><img src="/2023/12/07/rstp%E5%92%8Cmstp/rstptuopu7180923.png" alt="rstptuopu7180923"></p>
<ol>
<li>开启STP，修改STP模式为RSTP。</li>
<li>手动指定S1为RSTP根桥、S2为RSTP备份根桥。</li>
<li>通过修改接口开销值，使得S4的GE0&#x2F;0&#x2F;1接口成为根端口。</li>
<li>通过修改S1的GE0&#x2F;0&#x2F;11接口优先级，使得S2的GE0&#x2F;0&#x2F;11接口成为根端口。</li>
<li>修改STP模式为MSTP，创建Instance1、2，指定SW1为MSTI1的根桥、MSTI2的备份根桥，指定SW2为MSTI2的根桥、MSTI1的备份根桥。</li>
</ol>
<h2 id="RSTP基础配置"><a href="#RSTP基础配置" class="headerlink" title="RSTP基础配置"></a>RSTP基础配置</h2><p>#S1-s4 上都配置</p>
<p>stp enable</p>
<p>stp mode rstp</p>
<p>#查看STP的状态和统计信息摘要</p>
<p>dis stp brief</p>
<p>接口都为指定端口的是根桥，本实验中s4是根桥</p>
<p> 根桥选举控制</p>
<p>#手动调整STP优先级，指定S1为主根桥、S2为备份根桥</p>
<p>[S1]stp priority 4096</p>
<p>[S2]stp priority 8192</p>
<p>在另外两台交换机保持默认桥优先级（32768）的情况下，S1拥有最小的桥优先级，S2次之。</p>
<p>此时s1变为根桥，s2备份根桥</p>
<p>dis stp可以看到优先级已经改变</p>
<p>#取消S1、S2上手动调整桥优先级的配置，使用<strong>stp root</strong>命令指定根桥、备份根桥</p>
<p>[S1]undo stp priority</p>
<p>[S1]stp root primary</p>
<p>[S2]undo stp priority</p>
<p>[S2]stp root secondary</p>
<p>#S1、S2上查看STP的状态和统计信息，可以看到如下内容</p>
<p>s1：</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/s1dis182725.png" alt="s1dis182725"></p>
<p>s2:</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/s2disgg182834.png" alt="s2disgg182834"></p>
<p>S1的桥优先级为0，而S2的桥优先级为4096，此时S1为根桥，S2为备份根桥。</p>
<p>修改接口开销值控制根端口选举</p>
<p>#在S4上查看STP的状态和统计信息摘要</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/s4disg83008.png" alt="s4disg83008"></p>
<p>S4上GE0&#x2F;0&#x2F;2拥有更小的RPC（根路径开销），从而成为根端口。</p>
<p>#在S4上查看GE0&#x2F;0&#x2F;2接口的STP的状态和统计信息</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/s4disint232.png" alt="s4disint232"></p>
<p>此时路径开销计算方法为Dot1t，接口的STP cost值为20000。</p>
<p>#修改S4的GE0&#x2F;0&#x2F;2接口的STP cost值为40001</p>
<p>[S4]interface GigabitEthernet 0&#x2F;0&#x2F;2</p>
<p>[S4-GigabitEthernet0&#x2F;0&#x2F;2] stp cost 40001</p>
<p>#再次在S4上查看STP的状态和统计信息摘要</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/s4gen333559.png" alt="s4gen333559"></p>
<p>此时GE0&#x2F;0&#x2F;1接口的RPC为20000，小于GE0&#x2F;0&#x2F;2接口的RPC 40001，S4的GE0&#x2F;0&#x2F;1接口成为根端口。</p>
<p>修改接口优先级控制根端口选举</p>
<p>#在S2上查看STP的状态和统计信息摘要</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/s2disf83853.png" alt="s2disf83853"></p>
<p>S2上GE0&#x2F;0&#x2F;10、GE0&#x2F;0&#x2F;11接口收到的BPDU拥有相同的RPC、上行交换机BID，此时比较上行交换机PID（优先级+接口id），接口优先级一样，接口id小的优，所以g0&#x2F;0&#x2F;10小，所以是根端口</p>
<p>#在S1上修改GE0&#x2F;0&#x2F;11的STP接口优先级，使其发送的BPDU优于 GE0&#x2F;0&#x2F;10发送的BPDU</p>
<p>（修改上行交换机的PID）</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;11</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11] stp port priority 64</p>
<p>端口ID&#x3D; 端口优先级（Port Priority）4 bit+ 端口编号12 bit 构成； 缺省情况下，端口优先级是128；端口优先级取值范围是<strong>0到240</strong>，取值必须为<strong>16</strong>的整数倍。</p>
<p>#再次查看S2上的STP状态和统计信息摘要</p>
<p><img src="/2023/12/07/rstp%E5%92%8Cmstp/g0011gen759.png" alt="g0011gen759"></p>
<p>此时S2的GE0&#x2F;0&#x2F;1接口成为根端口。</p>
<h2 id="MSTP基础配置"><a href="#MSTP基础配置" class="headerlink" title="MSTP基础配置"></a>MSTP基础配置</h2><p>在所有交换机上创建VLAN10、20、30、40、50、60、70、80，配置MSTP域hcip，并创建两个新的实例：Instance 1、Instance 2，将VLAN10、30、50、70映射到Instance 1，将VLAN20、40、60、80映射到Instance 2，同时将SW1规划为MSTI1的主根桥、MSTI2的备份根桥，将SW2规划为MSTI2的主根桥、MSTI1的备份根桥。</p>
<p>#创建VLAN</p>
<p>[S1]vlan batch 10 20 30 40 50 60 70 80</p>
<p>[S2]vlan batch 10 20 30 40 50 60 70 80</p>
<p>[S3]vlan batch 10 20 30 40 50 60 70 80</p>
<p>[S4]vlan batch 10 20 30 40 50 60 70 80</p>
<p>#将所有互联接口配置为Trunk接口，放通所有VLAN</p>
<p>略</p>
<p>#修改STP模式为MSTP</p>
<p>[S1]stp mode mstp</p>
<p>[S2]stp mode mstp</p>
<p>[S3]stp mode mstp</p>
<p>[S4]stp mode mstp</p>
<p>#配置MSTP</p>
<p>[S1]stp region-configuration</p>
<p>[S1-mst-region] region-name hcip &#x2F;&#x2F;域名为hcip</p>
<p>[S1-mst-region] revision-level 1 &#x2F;&#x2F;版本1</p>
<p>[S1-mst-region] instance 1 vlan 10 30 50 70 实例1映射vlan 10 30 50 70</p>
<p>[S1-mst-region] instance 2 vlan 20 40 60 80</p>
<p>[S1-mst-region] active region-configuration &#x2F;&#x2F;生效</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S1-mst-region] quit</p>
<p>（s2，s3，s4同理配置）</p>
<p>#在S1检查MSTP实例和VLAN的映射关系</p>
<p>[S1]display stp region-configuration </p>
<p>#配置SW1为MSTI1的根桥、MSTI2的备份根桥</p>
<p>[S1]stp instance 1 root primary </p>
<p>[S1]stp instance 2 root secondary</p>
<p>#配置SW2为MSTI2的根桥、MSTI1的备份根桥</p>
<p>[S2]stp instance 1 root secondary </p>
<p>[S2]stp instance 2 root primary</p>
<p>#在S1上查看MSTI1的状态和统计信息摘要</p>
<p>[S1]display stp instance 1 brief</p>
<p> MSTID  Port           Role  STP State      Protection</p>
<p>  1   GigabitEthernet0&#x2F;0&#x2F;10    DESI  FORWARDING    NONE</p>
<p>  1   GigabitEthernet0&#x2F;0&#x2F;11    DESI  FORWARDING    NONE</p>
<p>  1   GigabitEthernet0&#x2F;0&#x2F;12    DESI  FORWARDING    NONE</p>
<p>  1   GigabitEthernet0&#x2F;0&#x2F;13    DESI  FORWARDING    NONE</p>
<p>S1上所有接口都是指定接口，S1为MSTI1的根桥。</p>
<p>#在S2上查看MSTI2的状态和统计信息摘要</p>
<p>[S2]display stp instance 2 brief </p>
<p> MSTID  Port           Role  STP State    	 Protection</p>
<p>  2   GigabitEthernet0&#x2F;0&#x2F;10    DESI  FORWARDING    NONE</p>
<p>  2   GigabitEthernet0&#x2F;0&#x2F;11    DESI  FORWARDING    NONE</p>
<p>  2   GigabitEthernet0&#x2F;0&#x2F;12    DESI  FORWARDING    NONE</p>
<p>  2   GigabitEthernet0&#x2F;0&#x2F;13    DESI  FORWARDING    NONE</p>
<p>S2上所有接口都是指定接口，S2为MSTI2的根桥。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>rstp</tag>
        <tag>mstp</tag>
      </tags>
  </entry>
  <entry>
    <title>telnet</title>
    <url>/2023/12/02/telnet/</url>
    <content><![CDATA[<h1 id="两种配置方法"><a href="#两种配置方法" class="headerlink" title="两种配置方法"></a>两种配置方法</h1><h2 id="1-仅密码登录验证"><a href="#1-仅密码登录验证" class="headerlink" title="1.仅密码登录验证"></a>1.仅密码登录验证</h2><p>代码如下（示例）：<br><Quidway>system-view —–进入配置模式<br>[Quidway]interface vlan 1 —–进入管理vlan<br>[Quidway-Vlanif1]ip address 192.168.28.49 255.255.255.0 —–配置管理ip地址<br>[Quidway-Vlanif1]quit —–退出<br>[Quidway]telnet server enable —–打开telnet服务 （一般默认开启）<br>[Quidway]user-interface vty 0 4 —–用户指定虚拟用户终端接口<br>[Quidway-ui-vty0-4]authentication-mode password —–配置用户终端接口认证方式 密码验证<br>[Quidway-ui-vty0-4]set authentication password cipher huawei123 —–设置接口验证密码,密码为huawei123<br>[Quidway-ui-vty0-4]user privilege level 15 —–设置用户优先级 （可选）<br>[Quidway-ui-vty0-4]idle-timeout 1 —–设置登陆超时为一分钟 （可选）<br>[Quidway-ui-vty0-4]return —–返回用户视图<br><Quidway>save —–保存</Quidway></Quidway></p>
<h2 id="2-配置AAA登录"><a href="#2-配置AAA登录" class="headerlink" title="2.配置AAA登录"></a>2.配置AAA登录</h2><p>代码如下（示例）：<br><Quidway>system-view —–进入配置模式<br>[Quidway]interface vlan 1 —–进入管理vlan<br>[Quidway-Vlanif1]ip address 192.168.28.49 255.255.255.0 —–配置管理ip地址<br>[Quidway-Vlanif1]quit —–退出<br>[Quidway]telnet server enable —–打开telnet服务 （一般默认开启）<br>[Quidway]user-interface vty 0 4 —–用户指定虚拟用户终端接口<br>[Quidway-ui-vty0-4]authentication-mode aaa —–配置用户终端接口认证方式 aaa验证<br>[Quidway-ui-vty0-4]user privilege level 15 —–设置用户优先级<br>[Quidway-ui-vty0-4]idle-timeout 1 —–设置登陆超时为一分钟<br>[Quidway-ui-vty0-4]quit —–退出<br>[Quidway]aaa —–进入aaa<br>[Quidway-aaa]local-user huawei password cipher huawei123 —–创建用户名huawei 密码huawei123<br>[Quidway-aaa]local-user huawei privilege level 15 —–设置用户优先级<br>[Quidway-aaa]local-user huawei service-type telnet —–授权用户使用telnet<br>[Quidway-ui-vty0-4]return —–返回用户视图<br><Quidway>save —–保存</Quidway></Quidway></p>
<h2 id="user-interface-vty-0-4-详解"><a href="#user-interface-vty-0-4-详解" class="headerlink" title="user-interface vty 0 4 详解"></a>user-interface vty 0 4 详解</h2><p>Quidway]user-interface vty 0 4                    ；进入虚拟终端<br>[S3026-ui-vty0-4]authentication-mode password           ；设置口令模式<br>[S3026-ui-vty0-4]set authentication-mode password simple 222 ；设置口令<br>[S3026-ui-vty0-4]user privilege level 3 </p>
<p>一、第一句的意思是：进入到vty 终端，在华为的交换机里，vty就是人家用telnet远程进入到你交换机的界面，最多有五个，所以说你可以vty 0  vty 1 vty… vty 4交换机最多可以允许五个人同时在线进到交换机里去配置命令的。vty0 4 就是说把这五个界面一起配置了，这五个界面进去的话，都是使用以下的配置。<br>二、用的认证模式是密码认证，可以使用scheme模式来，也可以用password来，用password的话，是要密码的，就是说你telnet的话，要输入密码才能登陆到包交换机里去的。<br>二、设置密码为明文密码，密码是123 ，如果是密文的话，就是cipher<br>四、用户等级为3，也就是最高的，华为的命令级别很多，分为四级，0 1 2 3 ，0是参观级，只能看，1比0要高，可以使用一些命令，2 是可以配置了，3可以备份与删除IOS啦，呵呵，这个命令就是说用这个123密码，进来就是最高级别的，不用换级别。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>telnet</tag>
        <tag>aaa</tag>
      </tags>
  </entry>
  <entry>
    <title>堆叠</title>
    <url>/2024/07/29/%E5%A0%86%E5%8F%A0/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>堆叠（iStack），将多台支持堆叠特性的交换机通过堆叠线缆连接在一起，从逻辑上虚拟成一台交换设备，作为一个整体参与数据转发。</p>
<p>集群（Cluster Switch System，CSS），将两台支持集群特性的交换机设备组合在一起，从逻辑上虚拟成一台交换设备。</p>
<p>集群只支持两台设备，一般高端框式交换机支持CSS、盒式设备支持iStack。通过使用堆叠、集群技术结合链路聚合技术可以简单构建高可靠、无环的园区网络。</p>
<img src="/2024/07/29/%E5%A0%86%E5%8F%A0/QQ截图20240729221559.png" alt="QQ截图20240729221559" style="zoom:67%;">

<p>一般接入、汇聚层盒式交换机采用堆叠技术，汇聚、核心层交换机采用集群技术。</p>
<p>在逻辑交换机之间使用链路聚合技术，无需部署STP、VRRP实现高可靠性。</p>
<p>实现高可靠性的同时设备之间的链路可以同时传输流量，链路利用率得以提升。</p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li><p>主交换机（Master）</p>
<p>主交换机负责管理整个堆叠。堆叠系统中只有一台主交换机。</p>
</li>
<li><p>备交换机（Standby）</p>
<p>备交换机是主交换机的备份交换机。堆叠系统中只有一台备交换机。当主交换机故障时，备交换机会接替原主交换机的所有业务。</p>
</li>
<li><p>从交换机（Slave）</p>
<p>从交换机用于业务转发，堆叠系统中可以有多台从交换机。从交换机数量越多，堆叠系统的转发带宽越大。</p>
<p>除主交换机和备交换机外，堆叠中其他所有的成员交换机都是从交换机。当备交换机不可用时，从交换机承担备交换机的角色。</p>
</li>
</ul>
<h2 id="堆叠ID"><a href="#堆叠ID" class="headerlink" title="堆叠ID"></a>堆叠ID</h2><p>堆叠ID用来标识堆叠成员交换机，是成员交换机的槽位号，取值范围是<strong>0～8</strong>，默认是0。每个堆叠成员交换机在堆叠系统中具有唯一的堆叠ID。</p>
<p>当堆叠系统有新成员加入时，如果新成员与已有成员堆叠ID冲突，则堆叠主交换机从0～最大的堆叠ID进行遍历，找到第一个空闲的ID分配给该新成员。</p>
<p>在建立堆叠时，建议提前规划好设备的堆叠ID。</p>
<img src="/2024/07/29/%E5%A0%86%E5%8F%A0/QQ截图20240729222232.png" alt="QQ截图20240729222232" style="zoom:67%;">

<p>当堆叠成员从堆叠系统中移除时，会继续使用堆叠系统使用的堆叠ID，可以执行命令<strong>stack slot</strong> <em>slot-id</em> <strong>renumber</strong> <strong>0</strong>手动恢复堆叠ID为缺省值0。如果不手动恢复堆叠ID，该交换机再次加入其它堆叠系统，和新堆叠系统的堆叠ID冲突时，才会被重新分配新的堆叠ID。</p>
<h2 id="堆叠建立"><a href="#堆叠建立" class="headerlink" title="堆叠建立"></a>堆叠建立</h2><p><strong>堆叠优先级</strong>：</p>
<p>主要用于角色选举过程中确定成员交换机的角色，<strong>优先级值越大表示优先级越高</strong>，优先级越高当选为主交换机的可能性越大。</p>
<p>堆叠主交换机的选举过程是：先比较交换机启动时间，再比较堆叠优先级。当两台交换机启动时间相差20秒以内时，则认为交换机启动时间相同，此时堆叠优先级大的交换机将被选举为主交换机。所以建议将优先级最大值分配给希望成为主交换机的设备。</p>
<p><strong>堆叠优先级取值范围为1～255，缺省优先级值为100</strong>，可以通过<strong>display stack</strong>查看，通过命令<strong>stack slot</strong> <em>slot-id</em> <strong>priority</strong> <em>priority</em>修改。修改后的堆叠优先级不影响当前主交换机。只有堆叠系统复位重新选举时，修改后的堆叠优先级才生效。</p>
<p>堆叠优先级相同时，<strong>MAC地址小的交</strong>换机优先竞争为主交换机</p>
<ol>
<li>物理连接：根据网络需求，选择适当的连接方式和连接拓扑，组建堆叠网络。</li>
<li>主交换机选举：成员交换机之间相互发送堆叠竞争报文，并根据选举原则，选出堆叠系统主交换机。</li>
<li>堆叠ID分配和备交换机选举：主交换机收集所有成员交换机的拓扑信息，向所有成员交换机分配堆叠ID，之后选出堆叠系统备交换机。</li>
<li>软件版本和配置文件同步：主交换机将整个堆叠系统的拓扑信息同步给所有成员交换机，成员交换机同步主交换机的系统软件和配置文件，之后进入稳定运行状态。</li>
</ol>
<p>堆叠主交换机选举超时时间为20s，堆叠成员交换机上电或重启时，由于不同成员交换机所需的启动时间可能差异比较大，因此不是所有成员交换机都有机会参与主交换机的第一次选举。20s后启动的交换机加入堆叠系统时，会重新进行主交换机的竞争。原主交换机竞争失败时会重启然后再以非主交换机加入堆叠，</p>
<p><img src="/2024/07/29/%E5%A0%86%E5%8F%A0/QQ%E6%88%AA%E5%9B%BE20240729224300.png" alt="QQ截图20240729224300"></p>
<h2 id="堆叠加入"><a href="#堆叠加入" class="headerlink" title="堆叠加入"></a>堆叠加入</h2><p>（不带电）</p>
<p>新加入的交换机会选举为从交换机，堆叠系统中原有主备从角色不变。新加入的是从</p>
<h2 id="堆叠合并"><a href="#堆叠合并" class="headerlink" title="堆叠合并"></a>堆叠合并</h2><p>堆叠合并是指稳定运行的两个堆叠系统合并成一个新的堆叠系统。</p>
<p>两个堆叠系统的主交换机通过竞争，选举出一个更优的作为新堆叠系统的主交换机。</p>
<p>竞争成功的主交换机所在的堆叠系统将<strong>保持原有主备从角色</strong>和配置不变，业务也不会受到影响；而另外一个堆叠系统的所有成员交换机将重新启动，<strong>以从交换机的角色加入到新堆叠系统</strong>，其堆叠ID将由新主交换机重新分配，并将同步新主交换机的配置文件和系统软件，该堆叠系统的原有业务也将中断。</p>
<p>堆叠系统合并流程与堆叠成员加入流程类似，堆叠合并时主交换机的选举规则为：比较运行时间，运行时间较早的堆叠系统竞争为主；如果两个堆叠系统的运行时间一样，其主交换机的选举规则与堆叠建立时一样。</p>
<h2 id="堆叠分裂与多主检测"><a href="#堆叠分裂与多主检测" class="headerlink" title="堆叠分裂与多主检测"></a>堆叠分裂与多主检测</h2><p>堆叠分裂后，原主备交换机被分裂到同一个堆叠系统中：原主交换机会重新计算堆叠拓扑，将移出的成员交换机的拓扑信息删除，并将新的拓扑信息同步给其他成员交换机；而移出的成员交换机检测到堆叠协议报文超时，将自行复位，重新进行选举。</p>
<p>堆叠分裂后，原主备交换机被分裂到不同的堆叠系统中：原主交换机所在堆叠系统重新指定备交换机，重新计算拓扑信息并同步给其他成员交换机；原备交换机所在堆叠系统将发生备升主，原备交换机升级为主交换机，重新计算堆叠拓扑并同步到其他成员交换机，并指定新的备交换机。</p>
<p><strong>多主检测MAD</strong>（Multi-Active Detection），是一种检测和处理堆叠分裂的协议。链路故障导致堆叠系统分裂后，MAD可以实现堆叠分裂的检测、冲突处理和故障恢复，降低堆叠分裂对业务的影响。</p>
<p><strong>直连检测方式</strong></p>
<p>直连检测方式是指堆叠成员交换机间通过普通线缆直连的专用链路进行多主检测。在直连检测方式中，堆叠系统正常运行时，不发送MAD报文；堆叠系统分裂后，分裂后的两台交换机以<strong>1s为</strong>周期通过检测链路发送MAD报文进行多主冲突处理。</p>
<ul>
<li>通过中间设备直连：堆叠系统的所有成员交换机之间至少有一条检测链路与中间设备相连。</li>
<li>Full-mesh方式直连：堆叠系统的各成员交换机之间通过检测链路建立Full-mesh全连接，即每两台成员交换机之间至少有一条检测链路。</li>
</ul>
<img src="/2024/07/29/%E5%A0%86%E5%8F%A0/QQ截图20240729225105.png" alt="QQ截图20240729225105" style="zoom:67%;">

<img src="/2024/07/29/%E5%A0%86%E5%8F%A0/QQ截图20240729225113.png" alt="QQ截图20240729225113" style="zoom:67%;">

<p><strong>代理检测方式</strong></p>
<p>代理检测方式是在堆叠系统Eth-Trunk上启用代理检测，在代理设备上启用MAD检测功能。此种检测方式要求堆叠系统中的所有成员交换机都与代理设备连接，并将这些链路加入同一个Eth-Trunk内。与直连检测方式相比，代理检测方式无需占用额外的接口，Eth-Trunk接口可同时运行MAD代理检测和其他业务。</p>
<p>在代理检测方式中，堆叠系统正常运行时，堆叠成员交换机以30s为周期通过检测链路发送MAD报文。堆叠成员交换机对在正常工作状态下收到的MAD报文不做任何处理；堆叠分裂后，分裂后的两台交换机以1s为周期通过检测链路发送MAD报文进行多主冲突处理。</p>
<img src="/2024/07/29/%E5%A0%86%E5%8F%A0/QQ截图20240729225336.png" alt="QQ截图20240729225336" style="zoom:67%;">

<img src="/2024/07/29/%E5%A0%86%E5%8F%A0/QQ截图20240729225342.png" alt="QQ截图20240729225342" style="zoom:67%;">

<p>堆叠分裂后，MAD冲突处理机制会使分裂后的堆叠系统处于Detect状态或Recovery状态。Detect状态表示堆叠正常工作状态，Recovery状态表示堆叠禁用状态。</p>
<p>MAD冲突处理机制如下：MAD分裂检测机制会检测到网络中存在多个处于Detect状态的堆叠系统，这些堆叠系统之间相互竞争，竞争成功的堆叠系统保持Detect状态，竞争失败的堆叠系统会转入Recovery状态；并且在Recovery状态堆叠系统的所有成员交换机上，关闭除保留端口以外的其它所有物理端口包括管理口，以保证该堆叠系统不再转发业务报文。</p>
<ol>
<li>先比较启动时间，启动完成时间早的堆叠系统成为Detect状态。启动完成时间差在20秒内则认为堆叠的启动完成时间相同。</li>
<li>启动完成时间相同时，比较堆叠中主交换机的优先级，优先级高的堆叠系统成为Detect状态。</li>
<li>优先级相同时，比较堆叠系统的MAC，MAC小的堆叠系统成为Detect状态。</li>
</ol>
<h2 id="主备倒换"><a href="#主备倒换" class="headerlink" title="主备倒换"></a>主备倒换</h2><ol>
<li>原来的备交换机升为主交换机。</li>
<li>新主交换机重新指定备交换机。</li>
<li>原来的主交换机重启后重新加入堆叠系统，并被选举为从交换机。</li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><img src="/2024/07/29/%E5%A0%86%E5%8F%A0/QQ%E6%88%AA%E5%9B%BE20240729225604.png" alt="QQ截图20240729225604"></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>堆叠</tag>
      </tags>
  </entry>
  <entry>
    <title>大型WLAN技术(1)</title>
    <url>/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/</url>
    <content><![CDATA[<h1 id="VLAN-Pool"><a href="#VLAN-Pool" class="headerlink" title="VLAN Pool"></a>VLAN Pool</h1><p>通过vlan pool把接入的用户分配到不同的vlan，减少广播域，减少网络中的广播报文，提升网络性能。</p>
<p>由于无线终端的移动性，在无线网络中经常有大量用户从某个区域接入后，随着用的移动，再漫游到其他区域，导致该区域的用户接入多，对IP地址数目要求大。比如：场馆入口、酒店的大堂等。目前一个SSID只能对应一个VLAN，一个VLAN对应一个子网，如果大量用户</p>
<p>从某一区域接入，只能扩大VLAN的子网，保证用户能够获取到IP地址。这样带来的问题就是广播域扩大，导致大量的广播报文（如ARP、DHCP等）带来严重的网络拥塞。基于此问题考虑，一个SSID需要能够对应多个VLAN，把大量用户分散到不同的VLAN减少广播域。VLAN Pool提供多个VLAN的管理和分配算法，实现SSID对应多个VLAN的方案。</p>
<h2 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h2><p>• 顺序分配算法：把用户按上线顺序依次划分到不同的VLAN中，用户上下线用户VLAN容易</p>
<p>变化，IP地址变更。</p>
<p>• HASH分配算法：根据用户MAC地址HASH值分配VLAN，用户分配的VLAN固定，可能导致</p>
<p>VLAN间用户划分不均匀，有的VLAN用户较多，有的较少。</p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240526151755.png" alt="QQ截图20240526151755"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240526151911.png" alt="QQ截图20240526151911"></p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526152035.png" alt="QQ截图20240526152035" style="zoom:50%;">

<p>如图，管理vlan10，业务vlan 20 30 40，网络可达，dhcp配置，capwap隧道，wlan基础配置（vap模板里业务vlan选择绑定vlan pool）</p>
<p>创建vlan pool，把业务vlan 20 30 40 加入进来，分配算法这里选择顺序分配</p>
<p>终端连接后，查看ip，发现分别接入vlan20 30 40</p>
<h1 id="AC的DHCP技术"><a href="#AC的DHCP技术" class="headerlink" title="AC的DHCP技术"></a>AC的DHCP技术</h1><p>随着网络规模的不断扩大，网络设备不断增多，企业内不同的用户可能分布在不同的网段，一台DHCP服务器在正常情况下无法满足多个网段的地址分配需求。企业内网各个网段通常都没有与DHCP Server在同一个二层广播域内，如果还需要通过DHCP服务器分配IP地址，则需要跨网段发送DHCP协议报文。</p>
<p>案例1</p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240526162219.png" alt="QQ截图20240526162219"></p>
<p>AC和AP在二层，DHCP服务器和AC不在同一网段，DHCP服务器给STA和AP分配ip地址，由于跨网段，所以在AC上配置中继</p>
<p>配置端口：略</p>
<p><strong>AR1：</strong></p>
<p>int g 0&#x2F;0&#x2F;1 </p>
<p>ip ad 172.168.12.1</p>
<p>dhcp enable</p>
<p>[Huawei-GigabitEthernet0&#x2F;0&#x2F;1]dhcp select global </p>
<p>配置地址组</p>
<p>ip pool 10<br> gateway-list 10.0.10.254<br> network 10.0.10.0 mask 255.255.255.0</p>
<p>ip pool 11<br> gateway-list 10.0.11.254<br> network 10.0.11.0 mask 255.255.255.0</p>
<p>配置静态路由</p>
<p>[Huawei]ip route-static 10.0.10.0 24 172.168.12.2<br>[Huawei]ip route-static 10.0.11.0 24 172.168.12.2</p>
<p><strong>AC：</strong></p>
<p>vlan b 10 11</p>
<p>int vlanif 10</p>
<p>ip ad 10.0.10.254 24</p>
<p>int vlanif 11</p>
<p>ip ad 10.0.11.254 24</p>
<p>int vlanif 1</p>
<p>ip ad 172.168.12.2 24 (与路由器相连接口ip)</p>
<p>配置中继：</p>
<p>interface Vlanif10<br> ip address 10.0.10.254 255.255.255.0<br> dhcp select relay<br> dhcp relay server-ip 172.168.12.1</p>
<p>interface Vlanif11<br> ip address 10.0.11.254 255.255.255.0<br> dhcp select relay<br> dhcp relay server-ip 172.168.12.1</p>
<p>capwap source interface vlanif 10（隧道）</p>
<p>此时ap可以获取ip地址</p>
<p>WLAN配置：略</p>
<p>sta查看ip</p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240526163258.png" alt="QQ截图20240526163258"></p>
<p>可以获取ip地址</p>
<p>案例2</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526171030.png" alt="QQ截图20240526171030" style="zoom:67%;">

<p>• 在AC和AP间是二层组网的情况下，也可以配置Option43，AP会根据Option43的内容先向</p>
<p>指定IP地址的AC发送单播请求报文，如果发送十次报文，AP都没有收到回应，则AP会继续</p>
<p>以广播的方式来发现同一网段的AC。所以在二层组网的情况下Option 43不是必配的参数，</p>
<p>但在三层组网的情况下则是必配的。</p>
<p>• Option 43即为Type值为43（0x2B）的Option字段，又称为厂商特定信息选项，DHCP服务</p>
<p>器和DHCP客户端通过Option43交换厂商特定的信息。当DHCP服务器接收到请求Option43</p>
<p>信息的DHCP请求报文后，将在回复报文中携带Option43，为DHCP客户端分配厂商指定的</p>
<p>信息（本文中特指AC的IP地址）。</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526171112.png" alt="QQ截图20240526171112" style="zoom:50%;">

<p>拓扑</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526171137.png" alt="QQ截图20240526171137" style="zoom:67%;">

<p>如图</p>
<p>AC和AP不在同一网段，S3作为relay给STA分配ip，AC2作为DHCP服务器给AP分配ip地址</p>
<p>配置：</p>
<p>配置端口：略</p>
<p><strong>S3：</strong></p>
<p>vlan b 20 21 100</p>
<p>int g 0&#x2F;0&#x2F;2</p>
<p>p l t</p>
<p>p t a v 100</p>
<p>int vlanif 100</p>
<p>ip add 192.168.100.3 (S3和AC之间通过vlanif100连接)</p>
<p>dhcp配置：</p>
<p>dhcp enable</p>
<p>interface Vlanif20<br> ip address 10.0.20.254 255.255.255.0<br> dhcp select relay<br> dhcp relay server-ip 192.168.100.2</p>
<p>interface Vlanif21<br> ip address 10.0.21.254 255.255.255.0<br> dhcp select interface</p>
<p>（给sta分配选择接口地址池）</p>
<p><strong>AC：</strong></p>
<p>vlan 100</p>
<p>配置dhcp：</p>
<p>dhcp enable</p>
<p>ip pool 20<br> gateway-list 10.0.20.254<br> network 192.168.100.0 mask 255.255.255.0<br> option 43 sub-option 3 ascii 192.168.100.2 （设置option43字段，ac的地址）</p>
<p>interface Vlanif100<br> ip address 192.168.100.2 255.255.255.0<br> dhcp select global</p>
<p>int g 0&#x2F;0&#x2F;1</p>
<p>p l t</p>
<p>p t a v 100</p>
<p>配置静态路由：</p>
<p> ip route-static 10.0.20.0 24 192.168.100.3</p>
<p>capwap隧道：</p>
<p>capwap source interface vlanif 100</p>
<p>此时ap可以获取ip</p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240526172328.png" alt="QQ截图20240526172328"></p>
<p>wlan配置：略</p>
<p>此时sta可以获取地址</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526172359.png" alt="QQ截图20240526172359" style="zoom:67%;">



<h1 id="漫游"><a href="#漫游" class="headerlink" title="漫游"></a>漫游</h1><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526202411.png" alt="QQ截图20240526202411" style="zoom:67%;">

<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526202604.png" alt="QQ截图20240526202604" style="zoom:67%;">

<p>• 二层漫游：1个无线客户端在2个AP（或多个AP）之间来回切换连接无线，前提是这些AP都</p>
<p>绑定的是同1个SSID并且业务VLAN都在同1个VLAN内（在同一个IP地址段），漫游切换的</p>
<p>过程中，无线客户端的接入属性（比如无线客户端所属的业务VLAN、获取的IP地址等属性）</p>
<p>不会有任何变化，直接平滑过渡，在漫游的过程中不会有丢包和断线重连的现象。</p>
<p>• 三层漫游：漫游前后SSID的业务VLAN不同，AP所提供的业务网络为不同的三层网络，对</p>
<p>应不同的网关。此时，为保持漫游用户IP地址不变的特性，需要将用户流量迂回到初始接入</p>
<p>网段的AP，实现跨VLAN漫游。</p>
<p>• 网络中有时候会出现以下情况：两个业务VLAN的VLAN ID相同，但是这两个子网又属于不</p>
<p>同的子网。此时为了避免系统仅仅依据VLAN ID将用户在两个子网间的漫游误判为二层漫</p>
<p>游，需要通过漫游域来确定设备是否在同一个子网内，只有当VLAN相同且漫游域也相同的</p>
<p>时候才是二层漫游，否则是三层漫游。</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526202744.png" alt="QQ截图20240526202744" style="zoom: 67%;">

<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526202850.png" alt="QQ截图20240526202850" style="zoom:67%;">

<p>• 配置漫游组。</p>
<p>▫ 如果指定了漫游组服务器，则需要在漫游组服务器上配置漫游组。</p>
<p>▫ 如果没有指定漫游组服务器，则各成员AC均需配置漫游组。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240526203311.png" alt="QQ截图20240526203311" style="zoom:50%;">

<p>设备连接方式如图所示，AP1被AC1纳管，AP2被AC2纳管，所有AP都采用直接转发模式。</p>
<p>S4交换机二层透传AP2的管理、业务报文，S3作为AP管理流量、业务流量的网关。</p>
<p>S3开启DHCP服务为AP1、AP2分配管理地址、为无线终端分配业务地址，AP通过DHCP报文中的Option 43获取AC地址。</p>
<h4 id="1-1-1-1-数据规划"><a href="#1-1-1-1-数据规划" class="headerlink" title="1.1.1.1 数据规划"></a>1.1.1.1 数据规划</h4><table>
<thead>
<tr>
<th>配置项</th>
<th>配置参数</th>
</tr>
</thead>
<tbody><tr>
<td>AP管理VLAN</td>
<td>VLAN10、20</td>
</tr>
<tr>
<td>STA业务VLAN</td>
<td>VLAN11、21</td>
</tr>
<tr>
<td>DHCP服务器</td>
<td>S3作为DHCP服务器为AP分配IP地址</td>
</tr>
<tr>
<td>S3作为DHCP服务器为STA分配IP地址</td>
<td></td>
</tr>
<tr>
<td>AP的IP地址池</td>
<td>10.0.10.0&#x2F;24、10.0.20.0&#x2F;24</td>
</tr>
<tr>
<td>STA的IP地址池</td>
<td>10.0.11.0&#x2F;24、10.0.21.0&#x2F;24</td>
</tr>
<tr>
<td>AC的源接口IP地址</td>
<td>VLANIF100（10.0.100.254）、VLANIF200（10.0.200.254）</td>
</tr>
<tr>
<td>AP组</td>
<td>名称：ap-group1、ap-group2</td>
</tr>
<tr>
<td>引用模板：VAP模板departX</td>
<td></td>
</tr>
<tr>
<td>域管理模板</td>
<td>名称：default</td>
</tr>
<tr>
<td>国家码：中国（CN）</td>
<td></td>
</tr>
<tr>
<td>SSID模板</td>
<td>名称：departX</td>
</tr>
<tr>
<td>SSID名称：roam</td>
<td></td>
</tr>
<tr>
<td>安全模板</td>
<td>名称：departX</td>
</tr>
<tr>
<td>安全策略：WPA-WPA2+PSK+AES</td>
<td></td>
</tr>
<tr>
<td>密码：huawei123</td>
<td></td>
</tr>
<tr>
<td>VAP模板</td>
<td>名称：departX</td>
</tr>
<tr>
<td>转发模式：直接转发</td>
<td></td>
</tr>
<tr>
<td>业务VLAN：VLAN11、21</td>
<td></td>
</tr>
<tr>
<td>引用模板：SSID模板departX、安全模板departX</td>
<td></td>
</tr>
</tbody></table>
<p>DepartX中的X代表AC编号，即AC1上为depart1、AC2上为depart2。</p>
<p>S3设备配置</p>
<p>#</p>
<p>sysname S3</p>
<p>#</p>
<p>vlan batch 10 to 11 20 to 21 100 200</p>
<p>#</p>
<p>dhcp enable</p>
<p>#</p>
<p>ip pool ap1</p>
<p> gateway-list 10.0.10.1</p>
<p> network 10.0.10.0 mask 255.255.255.0</p>
<p> option 43 sub-option 3 ascii 10.0.100.254</p>
<p>#</p>
<p>ip pool ap2</p>
<p> gateway-list 10.0.20.1</p>
<p> network 10.0.20.0 mask 255.255.255.0</p>
<p> option 43 sub-option 3 ascii 10.0.200.254</p>
<p>#</p>
<p>ip pool service_a</p>
<p> gateway-list 10.0.11.1</p>
<p> network 10.0.11.0 mask 255.255.255.0</p>
<p> dns-list 10.0.11.1</p>
<p>#</p>
<p>ip pool service_b</p>
<p> gateway-list 10.0.21.1</p>
<p> network 10.0.21.0 mask 255.255.255.0</p>
<p> dns-list 10.0.21.1</p>
<p>#</p>
<p>interface Vlanif10</p>
<p> description ap1_mgnt</p>
<p> ip address 10.0.10.1 255.255.255.0</p>
<p> dhcp select global</p>
<p>#</p>
<p>interface Vlanif11</p>
<p> description ap1_service</p>
<p> ip address 10.0.11.1 255.255.255.0</p>
<p> dhcp select global</p>
<p>#</p>
<p>interface Vlanif20</p>
<p> description ap2_mgnt</p>
<p> ip address 10.0.20.1 255.255.255.0</p>
<p> dhcp select global</p>
<p>#</p>
<p>interface Vlanif21</p>
<p> description ap2_service</p>
<p> ip address 10.0.21.1 255.255.255.0</p>
<p> dhcp select global</p>
<p>#</p>
<p>interface Vlanif100</p>
<p> description to_AC1</p>
<p> ip address 10.0.100.1 255.255.255.0</p>
<p>#</p>
<p>interface Vlanif200</p>
<p> description to_AC2</p>
<p> ip address 10.0.200.1 255.255.255.0</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;1</p>
<p> port link-type trunk</p>
<p> port trunk allow-pass vlan 100</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;2</p>
<p> port link-type trunk</p>
<p> port trunk allow-pass vlan 200</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p> port link-type trunk</p>
<p> port trunk allow-pass vlan 20 to 21</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;4</p>
<p> port link-type trunk</p>
<p> port trunk pvid vlan 10</p>
<p> port trunk allow-pass vlan 10 to 11</p>
<p>#</p>
<p>return</p>
<p>S4设备配置</p>
<p>#</p>
<p>sysname S4</p>
<p>#</p>
<p>vlan batch 20 to 21 </p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p> port link-type trunk</p>
<p> port trunk allow-pass vlan 20 to 21</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;4</p>
<p> port link-type trunk</p>
<p> port trunk pvid vlan 20</p>
<p> port trunk allow-pass vlan 20 to 21</p>
<p>#</p>
<p>return</p>
<p>AC1设备配置</p>
<p>#</p>
<p> sysname AC1</p>
<p>#</p>
<p>vlan batch 100</p>
<p>#</p>
<p>interface Vlanif100</p>
<p> description to_S3_CAPWAP</p>
<p> ip address 10.0.100.254 255.255.255.0</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;12</p>
<p> port link-type trunk</p>
<p> port trunk allow-pass vlan 100</p>
<p>#</p>
<p>ip route-static 10.0.10.0 255.255.255.0 10.0.100.1</p>
<p>ip route-static 10.0.200.0 255.255.255.0 10.0.100.1</p>
<p>#</p>
<p>capwap source interface vlanif100</p>
<p>#</p>
<p>wlan</p>
<p> security-profile name depart1</p>
<p> security wpa2 psk pass-phrase huawei123 aes</p>
<p> aes</p>
<p> ssid-profile name depart1</p>
<p> ssid roam</p>
<p> vap-profile name depart1</p>
<p> service-vlan vlan-id 11</p>
<p> ssid-profile depart1</p>
<p> security-profile depart1</p>
<p> regulatory-domain-profile name default</p>
<p> mobility-group name mobility（<strong>漫游组名称必须一致</strong>）</p>
<p> member ip-address 10.0.100.254</p>
<p> member ip-address 10.0.200.254</p>
<p> ap-group name depart1</p>
<p> radio 0</p>
<p>  vap-profile depart1 wlan 1</p>
<p> radio 1</p>
<p>  vap-profile depart1 wlan 1</p>
<p> radio 2</p>
<p>  vap-profile depart1 wlan 1</p>
<p>ap-id 0 type-id 56 ap-mac 00e0-fc6e-2890 ap-sn 210235448310F30CF56D</p>
<p> ap-name ap1</p>
<p> ap-group depart1</p>
<p> provision-ap</p>
<p>#</p>
<p>return</p>
<p>AC2设备配置</p>
<p>#</p>
<p> sysname AC2</p>
<p>#</p>
<p>vlan batch 200</p>
<p>#</p>
<p>interface Vlanif200</p>
<p> description to_S3_CAPWAP</p>
<p> ip address 10.0.200.254 255.255.255.0</p>
<p>#</p>
<p>interface GigabitEthernet0&#x2F;0&#x2F;13</p>
<p> port link-type trunk</p>
<p> port trunk allow-pass vlan 200</p>
<p>#</p>
<p>ip route-static 10.0.20.0 255.255.255.0 10.0.200.1</p>
<p>ip route-static 10.0.100.0 255.255.255.0 10.0.200.1</p>
<p>#</p>
<p>capwap source interface vlanif200</p>
<p>#</p>
<p>wlan</p>
<p> security-profile name depart2</p>
<p> security wpa-wpa2 psk pass-phrase huawei123 aes</p>
<p> ssid-profile name default</p>
<p> ssid-profile name depart2</p>
<p> ssid roam</p>
<p> vap-profile name depart2</p>
<p> service-vlan vlan-id 21</p>
<p> ssid-profile depart2</p>
<p> security-profile depart2</p>
<p> regulatory-domain-profile name default</p>
<p> mobility-group name mobility</p>
<p> member ip-address 10.0.100.254</p>
<p> member ip-address 10.0.200.254</p>
<p> ap-group name depart2</p>
<p> radio 0</p>
<p>  vap-profile depart2 wlan 1</p>
<p> radio 1</p>
<p>  vap-profile depart2 wlan 1</p>
<p> radio 2</p>
<p>  vap-profile depart2 wlan 1</p>
<p> ap-id 0 type-id 56 ap-mac 00e0-fcde-1990 ap-sn 210235448310FA145341</p>
<p> ap-name ap2</p>
<p> ap-group depart2</p>
<p> provision-ap</p>
<p>#</p>
<p>Return</p>
<h2 id="漫游注意事项"><a href="#漫游注意事项" class="headerlink" title="漫游注意事项"></a>漫游注意事项</h2><ul>
<li><p>实现WLAN漫游的两个AP必须使用<strong>相同的SSID和安全模板</strong>（安全模板名称可以不同，但是安全模板下的配置必须相同），认证模板的认证方式和认证参数也要配置相同。</p>
</li>
<li><p>漫游组内最多<strong>可以添加16个AC成员</strong>，AC一次只能加入到一个漫游组中，不可以同时加入多个漫游组。在高密等可能频繁发生AC间漫游的场景中，如果漫游组成员数过多，可能导致频繁出现漫游失败。对于此类场景，建议调整组网规划，使漫游组中存在4个以内成员AC。</p>
</li>
<li><p>同一漫游组内的AC必须使用相同的<strong>软件C版本</strong>，否则可能会导致AC间漫游失败。</p>
</li>
<li><p>AC间漫游建议采用规格相近的AC。不同型号AC的用户接入能力相差较大，当大规格AC的接入用户大量向小规格AC漫游时，超出小规格AC接入能力的部分用户会漫游失败。</p>
</li>
<li><p>配置漫游组时，需确保AC已配置CAPWAP源地址，否则漫游组不生效。</p>
</li>
<li><p><strong>AC间漫游与双链路热备功能互斥</strong>。</p>
</li>
<li><p>AGV漫游功能与空口扫描功能互斥。开启AGV功能后，AP上的对应射频将不支持空口扫描功能，依赖于扫描的业务如智能漫游、频谱导航、负载均衡等均不可用。</p>
</li>
<li><p>AC间<strong>漫游组名称必须一致</strong>。</p>
</li>
<li><p>WLAN AC和交换机之间不支持AC间漫游。</p>
</li>
<li><p>802.11r功能支持的安全策略包括开放式系统认证、WPA2+PSK+AES、WPA2+PPSK+AES和WPA2+802.1X+AES。</p>
</li>
<li><p>802.11r功能与PMF功能互斥，即如果已配置了802.11r功能，不能再配置PMF功能。</p>
</li>
<li><p>802.11r使用802.1X认证时，如果开启了802.1X重认证功能，部分终端可能因兼容性问题，在重认证阶段掉线后重新上线。</p>
</li>
<li><p>部分终端可能与802.11r漫游功能存在兼容性问题，导致漫游失败。不建议开启802.11r漫游功能。</p>
</li>
<li><p>如果两个AC上的PPSK配置保持一致，则PPSK用户支持AC间802.11r快速漫游；如果两个AC上的PPSK配置不一致，则PPSK用户不支持AC间802.11r快速漫游。</p>
</li>
<li><p>相同或不同漫游组成员（含漫游组服务器）的IP版本必须保持一致。如果配置了Navi AC，则漫游组成员与Navi AC成员（Navi AC和Local AC）的IP版本也必须保持一致。</p>
</li>
</ul>
<p>相同的SSID。</p>
<p>相同的VAP模板，且VAP ID必须相同。</p>
<p>相同的安全策略。</p>
<h1 id="高可靠性技术"><a href="#高可靠性技术" class="headerlink" title="高可靠性技术"></a>高可靠性技术</h1><p>• 热备份是指，当两台设备在确定主用（Master）设备和备用（Backup）设备后，由主用设</p>
<p>备进行业务的转发，而备用设备处于监控状态，同时主用设备实时向备用设备发送状态信</p>
<p>息和需要备份的信息，当主用设备出现故障后，备用设备及时接替主用设备的业务运行。</p>
<p><strong>• VRRP双机热备份</strong></p>
<p>▫ 主备AC两个独立的IP地址，通过VRRP对外虚拟为同一个IP地址，单个AP和虚拟IP建</p>
<p>立一条CAPWAP链路。</p>
<p>▫ 主AC备份AP信息、STA信息和CAPWAP链路信息，并通过HSB主备服务将信息同步给</p>
<p>备AC。主AC故障后，备AC直接接替工作。</p>
<p><strong>• 双链路热备份</strong></p>
<p>▫ 单个AP分别和主备AC建立CAPWAP链路，一条主链路，一条备链路。</p>
<p>▫ 主AC仅备份STA信息，并通过HSB主备服务将信息同步给备AC。主AC故障后，AP切</p>
<p>换到备链路上，备AC接替工作。</p>
<p><strong>• 双链路冷备份</strong></p>
<p>▫ 单个AP分别和主备AC建立CAPWAP链路，一条主链路，一条备链路。</p>
<p>▫ AC不备份同步信息。主AC故障后，AP切换到备链路上，备AC接替工作。</p>
<p><strong>• N+1备份</strong></p>
<p>▫ 单个AP只和一个AC建立CAPWAP链路。</p>
<p>▫ AC不备份同步信息。主AC故障后，AP重新与备AC建链CAPWAP链路，备AC接替工</p>
<p>作。</p>
<h2 id="VRRP双机热备"><a href="#VRRP双机热备" class="headerlink" title="VRRP双机热备"></a>VRRP双机热备</h2><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528173423.png" alt="QQ截图20240528173423" style="zoom:50%;">

<p><strong>AC目前支持VRRP单实例整机热备，不支持负载均衡。</strong></p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528173624.png" alt="QQ截图20240528173624" style="zoom:50%;">

<p>基于VRRP 的双机热备，热备相关的业务都注册到同一个HSB备份组，HSB备份组内部绑定</p>
<p>HSB服务，同时HSB备份组与一个VRRP实例绑定，从而业务通过HSB备份组获知当前用户</p>
<p>的主备状态、以及主备切换等事件，并通过HSB组的接口进行备份数据的接收和发送。</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528173733.png" alt="QQ截图20240528173733" style="zoom:67%;">

<p>HSB业务实时备份：</p>
<p>▫ 用户数据信息备份</p>
<p>▫ CAPWAP隧道信息备份</p>
<p>▫ AP表项备份</p>
<p>▫ DHCP地址信息备份</p>
<p>配置：</p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240528173854.png" alt="QQ截图20240528173854"></p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240528173925.png" alt="QQ截图20240528173925"></p>
<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240528173944.png" alt="QQ截图20240528173944"></p>
<p>配置案例</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174047.png" alt="QQ截图20240528174047" style="zoom:67%;">

<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174108.png" alt="QQ截图20240528174108" style="zoom:67%;">

<p>AC2配置与AC1相同，此处不再赘述。</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174137.png" alt="QQ截图20240528174137" style="zoom:67%;">

<p>capwap隧道使用virtual-ip，capwap source ip-address 10.0.10.X</p>
<h2 id="双链路双机热备"><a href="#双链路双机热备" class="headerlink" title="双链路双机热备"></a>双链路双机热备</h2><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174326.png" alt="QQ截图20240528174326" style="zoom:67%;">

<p>该方案除了支持主备备份之外，还支持负载分担模式。负载分担模式下可以指定一部分AP</p>
<p>的主AC为AC1，与其建立CAPWAP主链路，一部分AP的主AC为AC2，与其建立CAPWAP主</p>
<p>链路。</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174415.png" alt="QQ截图20240528174415" style="zoom:67%;">

<p>• 建立主链路时，除了Discovery阶段要优选出主AC，其他过程跟正常情况下的CAPWAP隧道</p>
<p>建立过程一致。</p>
<p>• 在Discovery阶段，使能双链路备份功能后，AP开始发送Discovery Request报文，分为单播</p>
<p>方式和广播方式：</p>
<p>▫ 如果预先通过静态方式、DHCP服务器方式或DNS方式指定了主备AC的IP地址，AP向</p>
<p>AC发送单播Discovery Request报文请求与主备AC关联。</p>
<p>▫ 如果没有配置AC的静态IP地址或者单播没有回应时，AP将发送广播Discovery </p>
<p>Request报文请求同网段内可关联的AC。</p>
<p>• 不管是单播发现还是广播发现，如果主备AC都正常，都会回应Discovery Response报文，</p>
<p>并在该报文中携带双链路特性开关、优先级、负载情况以及IP地址。</p>
<p>• AP收集到主备AC回应的Discovery Response报文后，根据AC的优先级、设备的负载情况以</p>
<p>及AC IP地址来选择主AC并开始与其建立CAPWAP主链路，优选顺序如下：</p>
<p>▫ 比较AC的优先级，优先级值小的为主AC，默认优先级为0，最大值为7，优先级取值</p>
<p>越小，优先级越高。；</p>
<p>▫ 优先级相同情况下，比较AC设备的负载情况，即AP个数和STA个数，负载轻的为主</p>
<p>AC。优先选择当前可接入AP数大的AC为主AC，如果当前可接入AP数相同，则选择当</p>
<p>前可接入STA数大的AC为主AC；</p>
<p>▫ 负载相同情况下，比较IP地址，IP地址小的为主AC。</p>
<p>• 说明：当前可接入AP数&#x3D;可接入的最大AP数-当前已接入的AP数，当前可接入STA数&#x3D;可接</p>
<p>入的最大STA数-当前已接入的STA数</p>
<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174704.png" alt="QQ截图20240528174704" style="zoom:50%;">

<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174712.png" alt="QQ截图20240528174712" style="zoom:50%;">

<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174540.png" alt="QQ截图20240528174540" style="zoom: 67%;">

<img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174548.png" alt="QQ截图20240528174548" style="zoom:67%;">

<h2 id="N-1备份"><a href="#N-1备份" class="headerlink" title="N+1备份"></a>N+1备份</h2><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ截图20240528174837.png" alt="QQ截图20240528174837" style="zoom:67%;">

<p><img src="/2024/05/26/%E5%A4%A7%E5%9E%8BWLAN%E6%8A%80%E6%9C%AF(1)/QQ%E6%88%AA%E5%9B%BE20240528174910.png" alt="QQ截图20240528174910"></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>vlan pool</tag>
        <tag>option 43</tag>
        <tag>漫游</tag>
      </tags>
  </entry>
  <entry>
    <title>子网划分</title>
    <url>/2024/03/24/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h1 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h1><p>首先为什么要子网划分？</p>
<p>有类IP地址规划的缺陷：使用默认掩码的问题：地址范围过大或过小，导致IP地址的浪费！</p>
<p>在一个网络地址中，主机数：2的n次方，可用的主机数：2*n-2（这里n是主机数）</p>
<p>如果这个网段只用于一个小型局域网，例如一个实验室，只有几十台主机，那么大大浪费了ip地址</p>
<p>所以，子网划分给这个网络地址分成若干个，减少浪费</p>
<p>相当于把主机数均匀的分配给若干个（网络号借位，主机号减少）</p>
<p>例如网络地址：192.168.1.0&#x2F;24，网络号24位，主机号8位，如果划成两个子网，网络号借1位</p>
<p>借的1位是1或者是0</p>
<p>192.168.1.<strong>0</strong>0000000（前25位变成网络号）子网1：192.168.1.0&#x2F;25</p>
<p>192.168.1.<strong>1</strong>0000000                                       子网2：192.168.128.0&#x2F;25</p>
<p>例：192.168.1.0  分配三个部门，每个部门30台主机</p>
<p>要借2位</p>
<p>00</p>
<p>01</p>
<p>10</p>
<p>11</p>
<p>这四种排列组合，分为四个子网</p>
<p>192.168.1.<strong>00</strong>  000000  –192.168.1.0&#x2F;26</p>
<p>192.168.1.<strong>01</strong>  000000   –192.168.1.64&#x2F;26</p>
<p>192.168.1.<strong>10</strong>  000000   –192.168.1.128&#x2F;26</p>
<p>192.168.1.<strong>11</strong>  000000   –192.168.1.192&#x2F;26</p>
<p><strong>子网划分的原理</strong></p>
<p>IP地址由网络位+主机位组成，子网划分就是借用现有网段的主机位的最左边某几位作为子网位，划分出多个子网。</p>
<p>①把原来有类网络IPv4地址中的“网络号”部分向“主机号”部分借位</p>
<p>②把一部分原来属于“主机号”部分的位变成“网络号”的一部分（通常称之为“子网号”）。</p>
<p>因此IP地址进行转变：网络号+主机号 变成 网络号+子网号（m）+主机号（n）</p>
<p>划分后子网数量：2*m</p>
<p>划分后每个子网可用主机数：2*n-2（主机号全为0和全为1（指二进制）的ip地址分别为网络地址与广播地址，是不能分配给某个特定的主机使用的）</p>
<p><strong>子网划分的步骤</strong></p>
<p>①　确定所需子网数2*m，</p>
<p>②　确定每个子网可用主机数2*n-2</p>
<p>③　确定需像主机号部分借多少位（m），才能满足需要求</p>
<p>④　根据主机数可得知子网地址空间大小2*n</p>
<p>⑤　进行地址划分</p>
<p>子网划分示例</p>
<p>某公司有四个部门，每个部门拥有50台主机，分配一个C类地址200.161.30.0&#x2F;24,请问如何进行网络地址规划？</p>
<p>a.确定子网数：四个部门，2*m&gt;&#x3D;4</p>
<p>b.确定主机数：30台主机，2*n-2&gt;&#x3D;30</p>
<p>c.C类地址网络号位24位，主机位8位，向第四段主机位借位，由上可知子网位m&#x3D;2，主机位n&#x3D;6</p>
<p>d.子网空间为64，子网数为4，根据原主机位八位则原网络空间为0-255，共256个，此时我们算出子网空间为64，可得出四个子网范围0-63、64-127、127-192、192-255</p>
<p>e. 第一个子网200.161.30.0&#x2F;26-200.161.30.63&#x2F;26</p>
<p>第二个子网200.161.30.64&#x2F;26-200.161.30.127&#x2F;26</p>
<p>第三个子网200.161.30.128&#x2F;26-200.161.30.191&#x2F;26</p>
<p>第四个子网200.161.39.192&#x2F;26-200.161.30.255&#x2F;26</p>
<p>f.主机位全为0和1的地址分别为网络地址与广播地址，不能分配给主机使用，则</p>
<p>部门1地址范围：200.161.30.1-62&#x2F;26</p>
<p>部门2地址范围：200.161.30.65-12&#x2F;26</p>
<p>部门3地址范围：200.161.30.129-190&#x2F;26</p>
<p>部门4地址范围：200.161.30.193-254&#x2F;26</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>子网划分</tag>
      </tags>
  </entry>
  <entry>
    <title>数据通信基础</title>
    <url>/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h1><p>冲突域    </p>
<p>软件：CSMA&#x2F;CD   载波侦听多路访问&#x2F;冲突检测  工作机制：①先听后发；②边发边听；③随机延迟</p>
<p>硬件：交换机</p>
<p>广播域</p>
<p>软件：vlan</p>
<p>硬件：路由器</p>
<p>OSI模型</p>
<table>
<thead>
<tr>
<th>7. 应用层</th>
<th>对应用程序提供接口。</th>
</tr>
</thead>
<tbody><tr>
<td>6. 表示层</td>
<td>进行数据格式的转换，以确保一个系统生成的应用层数据能够被另外一个系统的应用层所识别和理解。</td>
</tr>
<tr>
<td>5. 会话层</td>
<td>在通信双方之间建立、管理和终止会话。</td>
</tr>
<tr>
<td>4. 传输层</td>
<td>建立、维护和取消一次端到端的数据传输过程。控制传输节奏的快慢，调整数据的排序等等。</td>
</tr>
<tr>
<td>3. 网络层</td>
<td>定义逻辑地址；实现数据从源到目的地的转发。</td>
</tr>
<tr>
<td>2. 数据链路层</td>
<td>将分组数据封装成帧；在数据链路上实现数据的点到点、或点到多点方式的直接通信；差错检测。</td>
</tr>
<tr>
<td>1. 物理层</td>
<td>在媒介上传输比特流；提供机械的和电气的规约。</td>
</tr>
</tbody></table>
<img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ截图20240708190201.png" alt="QQ截图20240708190201" style="zoom:67%;">

<img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ截图20240708190343.png" alt="QQ截图20240708190343" style="zoom:67%;">

<p>TCP报文头部：<br>Source Port：源端口，标识哪个应用程序发送。长度为16比特。<br>Destination Port目：的端口，标识哪个应用程序接收。长度为16比特。<br>Sequence Number：序号字段。TCP链接中传输的数据流每个字节都编上一个序号。序号字段的值指的是本报文段所发送数据的第一个字节的序号。长度为32比特。<br>Acknowledgment Number：确认序列号，是期望收到对方下一个报文段数据的第1个字节的序号，即上次已成功接收到的数据段的最后一个字节数据的序号加1。只有Ack标识为1，此字段有效。长度为32比特。<br>Header Length：头部长度，指出TCP报文头部长度，以32比特（4字节）为计算单位。若无选项内容，则该字段为5，即头部为20字节。<br>Reserved：保留，必须填0。长度为6比特。<br>Control bits：控制位，包含FIN、ACK、SYN等标志位，代表不同状态下的TCP数据段。<br>Window：窗口TCP的流量控制，这个值表明当前接收端可接受的最大的数据总数（以字节为单位）。窗口最大为65535字节。长度为16比特。<br>Checksum：校验字段，是一个强制性的字段，由发端计算和存储，并由收端进行验证。在计算检验和时，要包括TCP头部和TCP数据，同时在TCP报文段的前面加上12字节的伪头部。长度为16比特。</p>
<img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ截图20240708190505.png" alt="QQ截图20240708190505" style="zoom:67%;">

<img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ截图20240708190528.png" alt="QQ截图20240708190528" style="zoom:67%;">

<p><img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ%E6%88%AA%E5%9B%BE20240708192705.png" alt="QQ截图20240708192705"></p>
<p>如拓朴图</p>
<p>R1，R2建立简单的telnet，模式是password，路由配置完成，</p>
<p>R1登录R2（loopback口），抓包</p>
<p><img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ%E6%88%AA%E5%9B%BE20240708192837.png" alt="QQ截图20240708192837"></p>
<p>可以看到ARP包和TCP建立的三次握手</p>
<h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><h4 id="局域网同网段下的ARP流程"><a href="#局域网同网段下的ARP流程" class="headerlink" title="局域网同网段下的ARP流程"></a>局域网同网段下的ARP流程</h4><p>如果主机A要想通过B的IP地址确定其MAC地址并和B进行数据交互，需要按照ARP协议的”广播请求和单播应答”来确定主机B的MAC地址，流程如下：<br>1） A先查看自己的ARP高速缓存表中是否有B主机的MAC地址记录。</p>
<p>2） 如果A的ARP高速缓存表中有B的MAC地址记录，则直接通过这个MAC地址进行数据的传输。</p>
<p>3） 如果A主机的ARP高速缓存中没有B主机的记录，则会向局域网的所有主机广播一个ARP请求，寻找B主机的MAC地址。</p>
<p>4） 当B主机收到A主机广播的ARP请求后，就会直接给A主机回复一个ARP数据包。</p>
<p>5） 当A主机收到B主机发送过来的请求后，将B的MAC地址写入高速缓存中，然后通过该MAC地址，A主机向B主机进行数据的传输。</p>
<h4 id="局域网不同网段下的ARP流程"><a href="#局域网不同网段下的ARP流程" class="headerlink" title="局域网不同网段下的ARP流程"></a>局域网不同网段下的ARP流程</h4><p>对于跨网段的ARP工作我们首先需要知道的是：</p>
<p>ARP请求以广播发送、以单播回应；</p>
<p>路由器隔离广播。每一个网段都是独立的广播域；</p>
<p>跨越网段通信需要使用网关的mac地址。</p>
<img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ截图20240708190924.png" alt="QQ截图20240708190924" style="zoom:67%;">

<p>1、主机A有数据发往主机B，数据封装IP之后发现没有主机B的mac地址；然后查询ARP，ARP回应：“我在192.168.3.0&#x2F;24网段，目标地址在192.168.4.0&#x2F;24,不属于同一网段，需要使用默认网关”；ARP发现默认网关是192.168.3.2，但是没有网关mac地址，需要先进行查询；</p>
<p>2、主机将数据包先放到缓存中，然后发送ARP查询报文：封装自己的mac地址为源mac，目标mac地址写全F的广播地址，请求网关192.168.3.2的mac地址。然后以广播方式发送出去；</p>
<p>3、路由器收到广播数据包，首先将原192.168.3.1添加到自己的mac地址表中，对应mac地址为0800.0222.2222。路由发现是请求自己的mac地址，然后路由回复一个ARP应答：封装自己的IP地址为源IP自己的mac地址为源mac，主机A的IP为目的IP主机A的mac为目的mac，发送一个单播应答“我是192.168.3.2.我的mac地址为0800.0333.2222”；</p>
<p>4、主机收到应答后，将网关mac地址对应192.168.4.2（跨网关通信，其他网段IP地址的mac地址均为网关mac），然后将缓存中的数据包，封装网关mac地址进行发送；</p>
<p>5、路由收到数据包，检查目的IP地址，发现不是给自己的，决定要进行路由，然后查询路由表，需要发往192.168.4.0网段中的192.168.4.2地址。路由准备从相应接口上发出去，然后查询mac地址表，发现没有主机B的映射。路由器发送arp请求查询主机B的mac地址（原理同2、3步，主机B收到请求后首先会添加网关的mac地址，然后单播回复arp请求）；</p>
<p>6、路由器收到主机B的mac地址后，将其添加到路由mac地址表中，然后将缓存中的数据2层帧头去掉，封装自己的mac地址为源mac，主机B的mac地址为目的mac（源和目的IP地址不变），加上二层帧头及校验，发送给主机B；</p>
<p>7、主机B收到数据之后，进行处理，发送过程结束；</p>
<p>8、如果主机B收到数据后进行回复，主机B会进行地址判断，不在同一网段，然后决定将数据发送给网关，主机B查询mac地址表获得网关mac地址，将数据封装后发送（arp地址解析的过程不再需要了，mac地址表条目有一定的有效时间），网关收到数据后直接查询mac表，将二层帧mac地址更改为A的mac发送出去。如此，主机A收到主机B的回复；</p>
<h1 id="VRP系统"><a href="#VRP系统" class="headerlink" title="VRP系统"></a>VRP系统</h1><p>设备系统支持的用户界面有Console用户界面和虚拟类型终端VTY（Virtual Type Terminal）用户界面。</p>
<img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ截图20240708191246.png" alt="QQ截图20240708191246" style="zoom:67%;">

<img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ截图20240708191334.png" alt="QQ截图20240708191334" style="zoom:67%;">

<img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ截图20240708191401.png" alt="QQ截图20240708191401" style="zoom:67%;">

<img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ截图20240708193616.png" alt="QQ截图20240708193616" style="zoom:50%;">

<p>flash目录下有dhcp文件夹</p>
<p>进入dhcp文件夹</p>
<p>dir</p>
<p>发现有 dhcp-duid.txt文件</p>
<img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ截图20240708193928.png" alt="QQ截图20240708193928" style="zoom:50%;">

<p>在flash目录下创建yzy文件夹，</p>
<p>把dhcp-duid.txt 复制到yzy目录</p>
<p><server>copy dhcp-duid.txt yzy</server></p>
<img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ截图20240708194050.png" alt="QQ截图20240708194050" style="zoom:50%;">

<p>dir可以看到</p>
<p>改个名字</p>
<img src="/2024/07/08/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/QQ截图20240708194129.png" alt="QQ截图20240708194129" style="zoom:50%;">

<p>已经改成666</p>
<h1 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h1><p><a href="https://www.yangzhiyu.top/2024/03/24/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/">子网划分 | 沃德发 (yangzhiyu.top)</a></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>数通基础</tag>
        <tag>VRP系统</tag>
        <tag>ARP</tag>
      </tags>
  </entry>
  <entry>
    <title>交换机工作原理</title>
    <url>/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/1jhjgzyl938.png" alt="1jhjgzyl938"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2jhjgzyl0011038.png" alt="2jhjgzyl0011038"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/3jhjgzyl011116.png" alt="3jhjgzyl011116"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/4jhjgzyl135.png" alt="4jhjgzyl135"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/5jhjgzyl330011154.png" alt="5jhjgzyl330011154"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/6jhjgzyl0011208.png" alt="6jhjgzyl0011208"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7jhjgzyl1222.png" alt="7jhjgzyl1222"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/8jhjgzyl240.png" alt="8jhjgzyl240"></p>
<p><img src="/2024/03/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/9jhjadji11254.png" alt="9jhjadji11254"></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>交换机工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title>组播</title>
    <url>/2024/05/10/%E7%BB%84%E6%92%AD/</url>
    <content><![CDATA[<h1 id="组播简介"><a href="#组播简介" class="headerlink" title="组播简介"></a>组播简介</h1><p>组播（Multicast）是在一台源IP主机和多台（一组）IP主机之间进行，中间的网络设备根</p>
<p>据接收者的需要，有选择性地对数据进行复制和转发。</p>
<p>• 组播技术有效地满足了单点发送、多点接收的需求，实现了IP网络中点到多点业务数据的高</p>
<p>效传送，能够大量节约网络带宽、降低网络负载。</p>
<p>• 组播分发树：组播流量的转发路径</p>
<p><strong>组播地址</strong>：224.0.0.0–239.255.255.255</p>
<p><strong>组播MAC：</strong></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/zubomac3553.png" alt="zubomac3553"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/zubokun53926.png" alt="zubokun53926"></p>
<p><strong>RPF检查：</strong></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/rpf4213.png" alt="rpf4213"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/rpf2154343.png" alt="rpf2154343"></p>
<h1 id="IGMPv1"><a href="#IGMPv1" class="headerlink" title="IGMPv1"></a>IGMPv1</h1><p>IGMPv1协议主要基于查询和响应机制完成组播组管理。当一个网段内有多个组播设备时，由于它们都可以接收到主机发送的成员报告报文，因此只需要选取其中一台组播设备发送查询报文，该组播设备称为IGMP查询器（Querier）。在IGMPv1中，由组播路由协议PIM选举出唯一的组播信息转发者（Assert Winner或DR）作为IGMP的查询器，负责该网段的组成员关系查询。</p>
<p>（不具备选举查询器，<strong>依赖PIM协议选举</strong>）</p>
<h2 id="IGMPv1报文"><a href="#IGMPv1报文" class="headerlink" title="IGMPv1报文"></a>IGMPv1报文</h2><p>IGMPv1报文封装在IP报文中，由8个字节组成。IGMPv1包括两种类型的报文：</p>
<ul>
<li><strong>普遍组查询报文</strong>（General Query）：查询器向共享网络上所有主机发送的查询报文，用于了解哪些组播组存在成员。（60s一次）</li>
<li><strong>成员报告报文</strong>（Report）：主机向查询器发送的报告报文，用于申请加入某个组播组或者应答查询报文。</li>
</ul>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/igmpgeshi155029.png" alt="igmpgeshi155029"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Version</td>
<td>IGMP版本，值为1。</td>
</tr>
<tr>
<td>Type</td>
<td>报文类型。该字段有以下两种取值：0x1：表示普遍组查询报文。0x2：表示成员报告报文。</td>
</tr>
<tr>
<td>Unused</td>
<td>在IGMPv1中，该字段在发送时被设为0，并在接收时被忽略。</td>
</tr>
<tr>
<td>Checksum</td>
<td>校验和。</td>
</tr>
<tr>
<td>Group Address</td>
<td>组播组地址。在普遍组查询报文中，该字段设为0；在成员报告报文中，该字段为成员加入的组播组地址。</td>
</tr>
</tbody></table>
<h2 id="查询组播组成员机制"><a href="#查询组播组成员机制" class="headerlink" title="查询组播组成员机制"></a>查询组播组成员机制</h2><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/shiyi5404.png" alt="shiyi5404"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/v1chaxun510155159.png" alt="v1chaxun510155159"></p>
<p>普遍组查询和响应过程如下：</p>
<ol>
<li><p>IGMP查询器发送目的地址为224.0.0.1（表示同一网段内所有主机和设备）的普遍组查询报文；收到该查询报文的组成员启动定时器。</p>
<p>普遍组查询报文是周期性发送的，发送周期可以通过命令配置。HostA和HostB作为组播组G1的成员，收到普遍组查询报文后，在本地启动定时器Timer-G1。</p>
</li>
<li><p>第一个定时器（10s）超时的组成员发送针对该组的报告报文。</p>
<p>假设HostA上的Timer-G1首先超时，HostA向该网段发送目的地址为G1的报告报文。也想加入组G1的HostB收到此报告报文，则停止定时器Timer-G1，不再发送针对G1的报告报文。<strong>这样报告报文被抑制</strong>，可以减少网段上的流量。</p>
</li>
<li><p>IGMP查询器接收到HostA的报告报文后，了解到本网段内存在组播组G1的成员，则由组播路由协议生成（<strong>，G1）组播转发表项，</strong> 代表任意组播源。网络中一旦有组播组G1的数据到达DeviceA，将向该网段转发。</p>
</li>
</ol>
<h2 id="加组机制"><a href="#加组机制" class="headerlink" title="加组机制"></a>加组机制</h2><ol>
<li>主机HostC不等待普遍组查询报文的到来，主动发送针对G2的报告报文以声明加入组播组G2。</li>
<li>IGMP查询器接收到HostC的报告报文后，了解到本网段内出现了组播组G2的成员，则生成组播转发项（*，G2）。网络中一旦有G2的数据到达DeviceA，将向该网段转发。</li>
</ol>
<h2 id="离组机制"><a href="#离组机制" class="headerlink" title="离组机制"></a>离组机制</h2><p>IGMPv1没有专门定义离开组的报文。主机离开组播组后，停止发送成员报告报文。根据主机想要离开的组播组中是否还有其他成员，处理机制有所不同。</p>
<ul>
<li><p>假设HostA想要退出组播组G1</p>
<p>HostA收到IGMP查询器发送的普遍组查询报文时，不再发送针对G1的报告报文。由于网段内还存在G1组成员HostB，HostB会向IGMP查询器发送针对G1的报告报文，因此IGMP查询器感知不到HostA的离开。</p>
</li>
<li><p>假设HostC想要退出组播组G2</p>
<p>HostC收到IGMP查询器发送的普遍组查询报文时，不再发送针对G2的报告报文。由于网段内不存在组G2的其他成员，IGMP查询器不会收到G2组成员的报告报文，则在一定时间（缺省值为130秒）后，删除G2所对应的组播转发表项。</p>
</li>
</ul>
<p>130&#x3D;60×2+10</p>
<h1 id="IGMPv2"><a href="#IGMPv2" class="headerlink" title="IGMPv2"></a>IGMPv2</h1><p>IGMPv2的工作机制与IGMPv1基本相同，最大的不同之处在于IGMPv2增加了查询器选举和离开组机制。IGMPv2可以使IGMP查询器及时了解到网段内哪些组播组已不存在成员，从而及时更新组成员关系，减少网络中冗余的组播流量。</p>
<p>与IGMPv1相比，IGMPv2的变化如下：</p>
<ul>
<li>除了普遍组查询报文和成员报告报文之外，IGMPv2新增了两种报文：<ul>
<li><strong>成员离开报文</strong>（Leave）：成员离开组播组时主动向查询器发送的报文，用于宣告自己离开了某个组播组。</li>
<li><strong>特定组查询报文</strong>（Group-Specific Query）：查询器向共享网段内<strong>指定组播组</strong>发送的查询报文，用于查询该组播组是否存在成员。</li>
</ul>
</li>
<li>IGMPv2对普遍组查询报文格式也做了改进，添加了最大响应时间（Max Response Time）字段。此字段取值可以通过命令配置，用于控制成员对于查询报文的响应速度。</li>
</ul>
<h2 id="IGMPv2报文："><a href="#IGMPv2报文：" class="headerlink" title="IGMPv2报文："></a>IGMPv2报文：</h2><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/QQ%E6%88%AA%E5%9B%BE20240730203138.png" alt="QQ截图20240730203138"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>Type</td>
<td align="left">报文类型。该字段有以下四种取值：0x11：表示查询报文。IGMPv2的查询报文包括普遍组查询报文和特定组查询报文两类。0x12：表示IGMPv1成员报告报文。0x16：表示IGMPv2成员报告报文。0x17：表示成员离开报文。</td>
</tr>
<tr>
<td>Max Response Time</td>
<td align="left">最大响应时间。成员主机在收到IGMP查询器发送的普遍组查询报文后，需要在最大响应时间内做出回应。该字段仅在IGMP查询报文中有效。</td>
</tr>
<tr>
<td>Checksum</td>
<td align="left">校验和。</td>
</tr>
<tr>
<td>Group Address</td>
<td align="left">组播组地址。在普遍组查询报文中，该字段设为0。<strong>在特定组查询报文中，该字段为要查询的组播组地址</strong>。在成员报告报文和离开报文中，该字段为<strong>成员要加入或离开的组播组地址</strong>。</td>
</tr>
</tbody></table>
<img src="/2024/05/10/%E7%BB%84%E6%92%AD/v235.png" alt="v235" style="zoom:80%;">

<h2 id="v2查询器选举机制"><a href="#v2查询器选举机制" class="headerlink" title="v2查询器选举机制"></a>v2查询器选举机制</h2><p>在IGMPv2中，查询器的选举过程如下：</p>
<ol>
<li><p>初始状态下，所有运行IGMPv2的组播设备（DeviceA和DeviceB）都认为自己是查询器，<strong>向本网段内的所有主机和组播设备发送普遍组查询报文。DeviceA和DeviceB在收到对方发送的普遍组查询报文后，将报文的源IP地址与自己的接口地址作比较</strong>。通过比较，IP地址最小的组播设备将成为查询器，其他组播设备成为非查询器。如图所示，DeviceA的接口地址小于DeviceB，则DeviceA当选为查询器，DeviceB为非查询器。</p>
</li>
<li><p>确定查询器后，将由IGMP查询器（DeviceA）向本网段内的所有主机和其他组播设备发送普遍组查询报文，而非查询器（DeviceB）则不再发送普遍组查询报文。</p>
<p>非查询器（DeviceB）上都会启动一个定时器（即其他查询器存在时间定时器Other Querier Present Timer）。在该定时器超时前，如果收到了来自查询器的查询报文，则重置该定时器；否则，就认为原查询器失效，并发起新的查询器选举过程。</p>
<p>（告诉非查询器我是查询器，我还活着）</p>
</li>
</ol>
<h2 id="v2离组机制"><a href="#v2离组机制" class="headerlink" title="v2离组机制"></a>v2离组机制</h2><p>在IGMPv2中，成员离开组播组时可以主动向查询器发送离开报文，宣告自己离开了某个组播组。</p>
<p>主机HostA离开组播组G1的过程如下：</p>
<ol>
<li>HostA向本地网段内的所有组播设备（<strong>目的地址为224.0.0.2</strong>）发送针对组G1的离开报文。</li>
<li>查询器收到离开报文，会发送针对组G1的特定组查询报文。发送间隔和发送次数可以通过命令配置，缺省情况下每隔1秒发送一次，共发送两次。同时查询器启动组成员关系定时器（Timer-Membership&#x3D;发送间隔x发送次数）。</li>
<li>如果该网段内还存在组G1的其他成员（如HostB），这些成员在收到查询器发送的特定组查询报文后，会立即发送针对组G1的报告报文。查询器收到针对组G1的报告报文后将继续维护该组成员关系。如果该网段内不存在组G1的其他成员，查询器将不会收到针对组G1的报告报文。在Timer-Membership超时后，查询器将删除（*，G1）对应的IGMP组表项。当有组G1的组播数据到达查询器时，查询器将不会向下游转发。</li>
</ol>
<h1 id="IGMPv3"><a href="#IGMPv3" class="headerlink" title="IGMPv3"></a>IGMPv3</h1><p>IGMPv3主要是为了配合SSM（Source-Specific Multicast）模型发展起来的，提供了在报文中携带组播源信息的能力，即主机可以对组播源进行选择。</p>
<p>与IGMPv2相比，IGMPv3报文的变化如下：</p>
<ul>
<li>IGMPv3报文包含两大类：查询报文和成员报告报文。<strong>IGMPv3没有定义专门的成员离开报文</strong>，成员离开通过特定类型的报告报文来传达。</li>
<li>查询报文中不仅包含普遍组查询报文和特定组查询报文，还新增了<strong>特定源组查询报文</strong>（Group-and-Source-Specific Query）。该报文由查询器向共享网段内特定组播组成员发送，用于查询该组成员是否愿意接收特定源发送的数据。特定源组查询通过在报文中携带一个或多个组播源地址来达到这一目的。</li>
<li>成员报告报文不仅包含主机想要加入的组播组，而且包含主机想要接收来自哪些组播源的数据。IGMPv3增加了针对组播源的过滤模式（INCLUDE&#x2F;EXCLUDE），将组播组与源列表之间的对应关系简单的表示为（G，INCLUDE，(S1、S2…)），表示只接收来自指定组播源S1、S2……发往组G的数据；或（G，EXCLUDE，(S1、S2…)），表示接收除了组播源S1、S2……之外的组播源发给组G的数据。当组播组与组播源列表的对应关系发生了变化，IGMPv3报告报文会将该关系变化存放于组记录（Group Record）字段，发送给IGMP查询器。</li>
<li>在IGMPv3中一个成员报告报文可以携带多个组播组信息，而之前的版本一个成员报告只能携带一个组播组。这样在IGMPv3中报文数量大大减少。</li>
</ul>
<h2 id="IGMPv3报文"><a href="#IGMPv3报文" class="headerlink" title="IGMPv3报文"></a>IGMPv3报文</h2><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/v3cahx61552.png" alt="v3cahx61552"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Type</td>
<td>报文类型，取值为0x11。</td>
</tr>
<tr>
<td>Max Response Code</td>
<td>最大响应时间。成员主机在收到IGMP查询器发送的普遍组查询报文后，需要在最大响应时间内做出回应。</td>
</tr>
<tr>
<td>Checksum</td>
<td>校验和。</td>
</tr>
<tr>
<td>Group Address</td>
<td>组播组地址。在普遍组查询报文中，该字段设为0；在特定组查询报文和特定源组查询报文中，该字段为要查询的组播组地址。</td>
</tr>
<tr>
<td>Resv</td>
<td>保留字段。发送报文时该字段设为0；接收报文时，对该字段不做处理。</td>
</tr>
<tr>
<td>S</td>
<td>该比特位为1时，所有收到此查询报文的其他设备不启动定时器刷新过程，但是此查询报文并不抑制查询器选举过程和设备的主机侧处理过程。</td>
</tr>
<tr>
<td>QRV</td>
<td>如果该字段非0，则表示查询器的健壮系数（Robustness Variable）。如果该字段为0，则表示查询器的健壮系数大于7。设备接收到查询报文时，如果发现该字段非0，则将自己的健壮系数调整为该字段的值；如果发现该字段为0，则不做处理。</td>
</tr>
<tr>
<td>QQIC</td>
<td>IGMP查询器的查询间隔，单位为秒。非查询器收到查询报文时，如果发现该字段非0，则将自己的查询间隔参数调整为该字段的值；如果发现该字段为0，则不做处理。</td>
</tr>
<tr>
<td>Number of Sources</td>
<td>报文中包含的组播源的数量。对于普遍组查询报文和特定组查询报文，该字段为0；对于特定源组查询报文，该字段非0。此参数的大小受到所在网络MTU大小的限制。</td>
</tr>
<tr>
<td>Source Address</td>
<td>组播源地址，其数量受到Number of Sources字段值大小的限制。</td>
</tr>
</tbody></table>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/v3baog18.png" alt="v3baog18"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Type</td>
<td>报文类型，取值为0x22。</td>
</tr>
<tr>
<td>Reserved</td>
<td>保留字段。发送报文时该字段设为0；接收报文时，对该字段不做处理。</td>
</tr>
<tr>
<td>Checksum</td>
<td>IGMP报文的校验和。校验和是IGMP报文长度（即IP报文的整个有效负载）的16位检测，表示IGMP信息补码之和的补码。Checksum字段在进行校验计算时设为0。当发送报文时，必须计算校验和并插入到Checksum字段中去。当接收报文时，校验和必须在处理该报文之前进行检验。</td>
</tr>
<tr>
<td>Number of Group Records (M)</td>
<td>报文中包含的组记录的数量。</td>
</tr>
<tr>
<td>Group Record</td>
<td>组记录。Group Record字段的格式如<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_igmp_cfg_0006.html#ZH-CN_CONCEPT_0000001130784226__fig_dc_fd_igmp_100803">图3</a>所示，解释如<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_igmp_cfg_0006.html#ZH-CN_CONCEPT_0000001130784226__tab_dc_fd_igmp_100803">表3</a>所示。</td>
</tr>
</tbody></table>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/tusan61812.png" alt="tusan61812"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Record Type</td>
<td>组记录的类型。共分为三大类。当前状态报告。用于对查询报文进行响应，通告自己目前的状态，共两种：MODE_IS_INCLUDE，表示接收源地址列表包含的源发往该组的组播数据。如果指定源地址列表为空，该报文无效。MODE_IS_EXCLUDE，表示不接收源地址列表包含的源发往该组的组播数据。过滤模式改变报告。当组和源的关系在INCLUDE和EXCLUDE之间切换时，会通告过滤模式发生变化，共两种：CHANGE_TO_INCLUDE_MODE，表示过滤模式由EXCLUDE转换到INCLUDE，接收源地址列表包含的新组播源发往该组播组的数据。如果指定源地址列表为空，主机将离开组播组。CHANGE_TO_EXCLUDE_MODE，表示过滤模式由INCLUDE转换到EXCLUDE，拒绝源地址列表包含的新组播源发往该组的组播数据。源列表改变报告。当指定源发生改变时，会通告源列表发生变化，共两种：ALLOW_NEW_SOURCES，表示在现有的基础上，需要接收源地址列表包含的组播源发往该组播组的组播数据。如果当前对应关系为INCLUDE，则向现有源列表中添加这些组播源；如果当前对应关系为EXCLUDE，则从现有阻塞源列表中删除这些组播源。BLOCK_OLD_SOURCES，表示在现有的基础上，不再接收源地址列表包含的组播源发往该组播组的组播数据。如果当前对应关系为INCLUDE，则从现有源列表中删除这些组播源；如果当前对应关系为EXCLUDE，则向现有源列表中添加这些组播源。</td>
</tr>
<tr>
<td>Aux Data Len</td>
<td>辅助数据长度。在IGMPv3的报告报文中，不存在辅助数据字段，该字段设为0。</td>
</tr>
<tr>
<td>Number of Sources (N)</td>
<td>本记录中包含的源地址数量。</td>
</tr>
<tr>
<td>Multicast Address</td>
<td>组播组地址。</td>
</tr>
<tr>
<td>Source Address</td>
<td>组播源地址。</td>
</tr>
<tr>
<td>Auxiliary Data</td>
<td>辅助数据。预留给IGMP后续扩展或后续版本。在IGMPv3的报告报文中，不存在辅助数据。</td>
</tr>
</tbody></table>
<h2 id="IGMPv3工作机制"><a href="#IGMPv3工作机制" class="headerlink" title="IGMPv3工作机制"></a>IGMPv3工作机制</h2><p>在工作机制上，与IGMPv2相比，IGMPv3增加了主机对组播源的选择能力。</p>
<p>IGMPv3大部分工作机制与IGMPv2类似：查询器选举机制一致：IP地址小的为查询器。</p>
<p>使用普遍组查询报文查询组成员加组信息。</p>
<p>使用特定组查询报文查询特定组播的成员存活情况。</p>
<p>IGMPv3需要支持上报组播源信息，与IGMPv2相比IGMPv3的变化如下：</p>
<p>IGMPv3查询报文除了包含普遍组查询报文和特定组查询报文，还新增了特定源组查询报文（Group-and-Source-Specific Query）。</p>
<p>IGMPv3成员关系报告报文不仅包含主机想要加入的组播组，而且包含主机想要接收来自哪些组播源的数据。</p>
<p>由于同个组播组的不同成员可能希望接收来自不同源的组播，<strong>因此IGMPv3无需成员关系报告报文抑制机制</strong>。</p>
<p>IGMPv3<strong>没有定义专门的成员离开报文，成员离开通过特定类型的报告报文来传达。</strong></p>
<p><strong>特定源组加入</strong></p>
<p>IGMPv3的成员报告报文的目的地址<strong>为224.0.0.22</strong>（表示同一网段所有使能IGMPv3的设备）。通过在报告报文中携带组记录，主机在加入组播组的同时，能够明确要求接收或不接收特定组播源发出的组播数据。如<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_igmp_cfg_0006.html#ZH-CN_CONCEPT_0000001130784226__fig_01">图4</a>所示，网络中存在S1和S2两个组播源，均向组播组G发送组播数据，Host仅希望接收从组播源S1发往组播组G的信息。</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/tedingh047.png" alt="tedingh047"></p>
<p>如果Host和组播设备之间运行的是IGMPv1或IGMPv2，Host加入组播组G时无法对组播源进行选择，无论其是否需要，都会同时接收到来自组播源S1和S2的数据。如果采用IGMPv3，成员主机可以发送IGMPv3报告（G，INCLUDE，(S1)），选择仅接收源S1向组播组G发送的数据。</p>
<p><strong>特定源组查询</strong></p>
<p>该报文用于查询该组成员是否愿意接收特定源发送的数据。特定源组查询通过在报文中携带一个或多个组播源地址来达到这一目的。</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/v3jiazu2434.png" alt="v3jiazu2434"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/v3lizu2449.png" alt="v3lizu2449"></p>
<h2 id="各个版本比较"><a href="#各个版本比较" class="headerlink" title="各个版本比较"></a>各个版本比较</h2><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/cahyi540.png" alt="cahyi540"></p>
<h1 id="IGMP-Snooping"><a href="#IGMP-Snooping" class="headerlink" title="IGMP Snooping"></a>IGMP Snooping</h1><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/Snooping5041.png" alt="Snooping5041"></p>
<p>当Router将组播报文转发至Switch以后，Switch负责将组播报文转发给组播用户。由于组</p>
<p>播报文的目的地址为组播组地址，在二层设备上是学习不到这一类MAC表项的，因此组播</p>
<p>报文就会在所有接口进行广播，和它在同一广播域内的组播成员和非组播成员都能收到组</p>
<p>播报文。这样不但浪费了网络带宽，而且影响了网络信息安全。</p>
<p>• IGMP Snooping有效地解决了这个问题。配置IGMP Snooping后，二层组播设备可以侦听</p>
<p>和分析组播用户和上游路由器之间的IGMP报文，根据这些信息建立二层组播转发表项，控</p>
<p>制组播数据报文转发。这样就防止了组播数据在二层网络中的广播。</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/sjies153.png" alt="sjies153"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/jiekou165325.png" alt="jiekou165325"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/zhuafabiao5448.png" alt="zhuafabiao5448"></p>
<p>• 路由器端口形成后会启动老化计时器<strong>（默认180s）</strong>,当路由器端口收到新的普遍组查询后刷</p>
<p>新该计时器。</p>
<p>• 成员端口形成后会启动老化计时器<strong>（默认180s）</strong>,当成员端口收到新的成员关系报告报文后</p>
<p>刷新该计时器。</p>
<p>• IGMP Snooping不再使用成员关系报告报文抑制机制：</p>
<p>▫ 由于IGMP Snooping需要监听IGMP报文才能决定端口角色，进而指导转发，所以所</p>
<p>有组成员都需要发送IGMP组成员关系报告报文。</p>
<p>▫ 当IGMP Snooping设备收到成员关系报告报文后，只将成员关系报告报文从路由器接</p>
<p>口发送出去，从而避免其余组成员收到成员关系报告报文，<strong>不触发成员关系报告报文</strong></p>
<p><strong>抑制机制。</strong></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/weihu65557.png" alt="weihu65557"></p>
<p>• 收到IGMP离开报文后，成员端口的老化定时器 &#x3D; 健壮系数（默认2） x 特定组查询间隔（默认1s）。</p>
<h1 id="IGMP-SSM-Mapping"><a href="#IGMP-SSM-Mapping" class="headerlink" title="IGMP SSM Mapping"></a>IGMP SSM Mapping</h1><p>SSM（Source-Specific Multicast）称为指定源组播，要求设备能了解成员主机加入组播组时所指定的组播源。如果成员主机上运行IGMPv3，可以在IGMPv3报告报文中直接指定组播源地址。但是某些情况下，成员主机只能运行IGMPv1或IGMPv2，为了使其也能够使用SSM服务，设备上需要提供IGMP SSM Mapping功能。</p>
<p>IGMP SSM Mapping的机制是：通过在设备上静态配置SSM地址的映射规则，将IGMPv1和IGMPv2报告报文中的（*, G）信息转化为对应的（G, INCLUDE, (S1, S2…)）信息，以提供SSM组播服务。</p>
<p>配置了SSM Mapping规则后，当IGMP查询器收到来自成员主机的IGMPv1或IGMPv2报告报文时，首先检查该报文中所携带的组播组地址G，然后根据检查结果的不同分别进行处理。</p>
<ul>
<li><strong>如果G在ASM（Any-Source Multicast）范围内，则只提供ASM服务。</strong></li>
<li>如果G在SSM组地址范围内（缺省情况下为232.0.0.0～232.255.255.255）：<ul>
<li>如果设备上没有G对应的SSM Mapping规则，则无法提供SSM服务，丢弃该报文。</li>
<li>如果设备上有G对应的SSM Mapping规则，则依据规则将报告报文中所包含的（*, G）信息映射为（G, INCLUDE, (S1, S2…)）信息，提供SSM服务。</li>
</ul>
</li>
</ul>
<p>SSM网络的用户网段中HostA运行IGMPv3、HostB运行IGMPv2、HostC运行IGMPv1。HostB和HostC无法升级到IGMPv3，如果要为该网段中的所有主机提供SSM服务，需要在IGMP查询器（Device）上使能IGMP SSM Mapping并配置相应的映射规则。</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/mm0923.png" alt="mm0923"></p>
<p>假如在Device上配置如下映射关系：</p>
<table>
<thead>
<tr>
<th>组播组地址</th>
<th>映射的组播源地址</th>
</tr>
</thead>
<tbody><tr>
<td>232.0.0.0&#x2F;8</td>
<td>10.10.1.1</td>
</tr>
<tr>
<td>232.1.0.0&#x2F;16</td>
<td>10.10.2.2</td>
</tr>
<tr>
<td>232.1.0.0&#x2F;16</td>
<td>10.10.3.3</td>
</tr>
<tr>
<td>232.1.1.0&#x2F;24</td>
<td>10.10.4.4</td>
</tr>
</tbody></table>
<p>经过映射后，Device收到HostB和HostC的成员报告报文时，首先判断报文携带的组地址是否在SSM范围内，发现在SSM范围内，则根据配置的映射规则生成如下所示的组播表项。如果一个组地址映射了多个源，则生成多个（S，G）表项。</p>
<p>在映射过程中，一个组播组地址只要能在规则中匹配到，都会生成一条相应的表项。因此232.1.1.1有四条表项，232.1.2.2有三条表项。</p>
<table>
<thead>
<tr>
<th align="left">IGMPv1&#x2F;IGMPv2报告报文中的组地址</th>
<th>生成的组播表项</th>
</tr>
</thead>
<tbody><tr>
<td align="left">232.1.1.1 （来自HostC）</td>
<td>（10.10.1.1，232.1.1.1）（10.10.2.2，232.1.1.1）（10.10.3.3，232.1.1.1）（10.10.4.4，232.1.1.1）</td>
</tr>
<tr>
<td align="left">232.1.2.2 （来自HostB）</td>
<td>（10.10.1.1，232.1.2.2）（10.10.2.2，232.1.2.2）（10.10.3.3，232.1.2.2）</td>
</tr>
</tbody></table>
<h1 id="IGMP-Proxy"><a href="#IGMP-Proxy" class="headerlink" title="IGMP Proxy"></a>IGMP Proxy</h1><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/p1171231.png" alt="p1171231"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/p2171311.png" alt="p2171311"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/p371410.png" alt="p371410"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/plizu10171452.png" alt="plizu10171452"></p>
<h1 id="PIM-DM"><a href="#PIM-DM" class="headerlink" title="PIM DM"></a>PIM DM</h1><p>PIM-DM：密集模式，采用的是“推”模式，适用于成员比较少，相对密集的场景</p>
<p>PIM-SM：稀疏模式  采用的是“拉”模式，适用于成员多，但是成员不集中的场景</p>
<p>PIM（Protocol Independent Multicast，协议无关组播）是域内组播路由协议，利用单播路由信息，对组播消息进行RPF检查，创建组播路由表项。为IP组播提供路由信息的协议可以是任何单播路由协议，比如静态路由、RIP、OSPF、IS-IS、BGP等。组播路由和单播路由协议无关，只是通过单播路由表产生相应组播路由表项。</p>
<p>目前在实际网络中，PIM协议有三种模式：PIM-DM、使用ASM（Any-Source Multicast）模型的PIM-SM，使用SSM（Source-Specific Multicast）模型的PIM-SM。需要注意的是，同一个PIM域中不能同时运行PIM-DM和PIM-SM。</p>
<p><strong>（S，G）和（*,G）</strong></p>
<p>PIM路由器上可能同时存在两种路由表项。当收到源地址为S，组地址为G的组播报文，且RPF检查通过的情况下，按照如下的规则转发：</p>
<ul>
<li>如果存在（S，G）路由表项，则由（S，G）路由表项指导报文转发。</li>
<li>如果不存在（S，G）路由表项，只存在（*，G）路由表项，则先依照（*，G）路由表项创建（S，G）路由表项，再由（S，G）路由表项指导报文转发。</li>
</ul>
<p>理解：<strong>（*，G）在pim dm中由igmp加组创建，当组播源发送数据时，才会由此表创建（S，G）指导转发</strong></p>
<p><strong>PIM-DM域中组播数据转发的实现过程是</strong>：</p>
<ol>
<li>邻居发现Neighbor Discovery）：在PIM-DM域中，PIM设备通过周期性的向所有其他PIM设备发送Hello消息，来发现PIM邻居，维护PIM设备之间的PIM邻居关系。缺省情况下，无论PIM设备是否收到来自邻居的Hello消息，都会接收其他的PIM控制消息或组播报文。但是如果PIM设备配置了邻居检查功能，则只有在PIM设备接收到来自邻居的Hello消息后，才会接收其他的PIM控制消息或组播报文。</li>
<li>扩散Flooding）：PIM-DM假设网络中的每个子网都存在至少一个组播组成员，因此组播数据将被扩散到网络中的所有节点，网络中所有的PIM设备都能接收到组播数据。（<strong>有了状态刷新和嫁接机制的情况下，通常不需要再周期扩散</strong>）</li>
<li>剪枝（Prune）：组播数据扩散到网络中后，PIM-DM对没有组播数据接收者的分支进行剪枝，只保留包含接收者的分支，即确保网络中只有需要组播数据的PIM设备能够接收到组播数据，不需要组播数据的PIM设备接收不到组播数据。</li>
<li>状态刷新（State-Refresh）：如果设备处于剪枝状态，其上游PIM设备会维护一个“剪枝定时器”。当剪枝定时器超时，上游PIM设备恢复对不需要数据的下游PIM设备的数据转发，这样会导致不必要的网络资源浪费。采用状态刷新可使离组播源最近的第一跳设备周期性发送State-Refresh消息，刷新所有设备的剪枝定时器状态，对不需要数据的下游设备始终保持剪枝状态。</li>
<li>嫁接Graft）：当被剪枝分支的节点上出现了组播组成员时，为了减少该节点恢复成转发状态所需的时间，PIM-DM使用嫁接机制主动恢复其对组播数据的转发。</li>
<li>断言（Assert）：如果在一个网段内出现多台PIM设备，则相同的组播报文可能会被重复发送到该网段。通过<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0006.html#ZH-CN_CONCEPT_0000001176663373__section_dc_vrp_multicast_feature_311109">断言</a>可以为网段选定唯一的组播数据转发者，避免冗余的组播数据转发。</li>
</ol>
<h2 id="邻居发现"><a href="#邻居发现" class="headerlink" title="邻居发现"></a>邻居发现</h2><p>PIM设备在每个使能了PIM的接口上，都会对外发送Hello消息。封装<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>的组播报文有如下特点：</p>
<ul>
<li>目的地址是224.0.0.13，表示同一网段中所有PIM设备</li>
<li>源地址为接口的IP地址</li>
<li>TTL数值为1，仅发送给邻居接口</li>
</ul>
<p><a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>具有发现邻居、协商各项协议参数、维持邻居关系的作用。</p>
<p><strong>发现PIM邻居</strong></p>
<p>同一网段中的PIM设备都必须接收目的地址为224.0.0.13的组播报文。这样在收到<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>以后，直接相连的组播设备之间，就可以知道自己的邻居信息。</p>
<p><strong>协商各项协议参数</strong></p>
<p><a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>中携带多项协议参数，邻居之间通过<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>来进行协商，这些参数包括：</p>
<ul>
<li>DR_Priority：表示各设备接口竞选DR的优先级，优先级越高越容易获胜。</li>
<li>Holdtime：表示保持邻居为可达状态的超时时间。</li>
<li>LAN_Delay：表示共享网段内传输Prune消息的延迟时间。</li>
<li>Override-Interval：表示Hello消息]中携带的否决剪枝的时间间隔。</li>
</ul>
<p><strong>维持邻居关系</strong></p>
<p>PIM设备之间周期性地发送Hello消息。如果Holdtime超时还没有收到该PIM邻居发出的新的<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300502">Hello消息</a>，则认为该邻居不可达，将其从邻居列表中清除。</p>
<p>PIM邻居的变化将导致网络中组播拓扑的变化。如果组播分发树上的某上游邻居或下游邻居不可达，将导致组播路由重新收敛，组播分发树迁移。</p>
<p><strong>维护邻居关系  30s  邻居超时时间105s</strong></p>
<h2 id="扩散机制"><a href="#扩散机制" class="headerlink" title="扩散机制"></a>扩散机制</h2><p>全网建立（S，G）路由表项    组播源开始发送组播数据，组播数据全网进行转发，生成（S，G ）表项，表项默认老化时间210s，，超过210s没有组播数据转发，将删除表项，有组播 数据的时候重新建立表项</p>
<p>扩散机制会周期性（默认180s）全网扩散组播数据，周期性扩散的主要目的是探测是否有新成员加组，但是由于全网扩散组播数据会浪费大量带宽，所以现在的组播网络一般使用“状态刷新机制”加上“嫁接机制”来实现周期性全网扩散感知新成员加组的目的。</p>
<h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>如果路由器下游没有组成员，将向上游发起剪枝，剪到最后一个不需要发组播报文的路由器</p>
<p>剪枝接口会有一个计时器，210s，计时器超时，接口将加入下游接口，转发组播报文</p>
<p>当下游接口被剪枝后：</p>
<ul>
<li>如果下游叶子路由器有组成员加入，并且希望在下次“扩散-剪枝”前就恢复组播报文转发，则执行嫁接动作。</li>
<li>如果下游叶子路由器一直没有组成员加入，希望该接口保持抑制转发状态，则执行状态刷新动作。</li>
</ul>
<h2 id="状态刷新机制"><a href="#状态刷新机制" class="headerlink" title="状态刷新机制"></a>状态刷新机制</h2><p>状态刷新报<strong>文60s</strong>发一次</p>
<p>对于剪枝端口而言，收到状态刷新报文，计时器将重置</p>
<p><strong>离组播源最近的第一跳路由器</strong>周期性触发State-Refresh消息。State-Refresh消息在全网扩散，刷新所有设备上的剪枝定时器状态，对不需要数据的下游设备始终保持剪枝状态。</p>
<h2 id="嫁接"><a href="#嫁接" class="headerlink" title="嫁接"></a>嫁接</h2><p>PIM-DM通过嫁接机制，使有新组成员加入的网段快速得到组播报文。叶子路由器通过IGMP了解到与其相连的用户网段上，组播组G有新的组成员加入。随后叶子路由器会向上游发送Graft报文，请求上游路由器恢复相应出接口转发，将其添加在（S，G）表项下游接口列表中。</p>
<p>嫁接过程从叶子路由器开始，到有组播报文到达的路由器结束。</p>
<p>一旦有新成员加入，叶子路由器会基于本地的组播路由表向上游发送Graft报文，请求上游路由器恢复相应出接口转发，将其添加在（S，G）表项下游接口列表中。</p>
<p>下游发送Graft消息，请求上游恢复对应出接口的转发。上游收到Graft消息后，将下游的出接口恢复转发</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在组播网络中，如果出现如下情况，则说明网段上还存在着其他的组播转发者。</p>
<ul>
<li>该组播报文不能通过RPF检查。</li>
<li>接收到该组播报文的接口是本设备上（S，G）表项中的一个下游接口。</li>
</ul>
<p>此时，设备会执行Assert机制。设备从该下游接口发送<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>。同时，该下游接口也接收到了来自该网段上其他组播转发者的<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>。<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>的目的地址为224.0.0.13，源地址为下游接口地址，TTL为1。<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>中携带该PIM设备到组播源或RP的开销、所采用的单播路由协议的优先级和组播组地址G。</p>
<p>设备将自身条件与对方报文中携带的信息进行比较，称为Assert竞选。<strong>规则如下</strong>：</p>
<ol>
<li><strong>单播路由协议优先级较高者获胜。</strong></li>
<li><strong>如果优先级相同，则到组播源或RP的开销较小者获胜。</strong></li>
<li><strong>如果以上都相同，则下游接口IP地址最大者获胜。</strong></li>
</ol>
<p>根据Assert竞选结果，设备将执行不同的操作：</p>
<ul>
<li>如果获胜，则该下游接口保持转发状态，设备负责后续在该网段上的（S，G）转发，该下游接口称为Assert winner。</li>
<li>如果落败，则禁止该下游接口转发组播报文，将其从（S，G）表项下游接口列表中删除。该下游接口称为Assert loser。</li>
</ul>
<p>Assert竞选结束后，该网段上只存在一个有下游接口的上游设备，只传输一份组播报文。Assert winner周期性发送<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>，维持Assert winner的状态。若Assert loser的定时器超时后，Assert loser仍没有收到Assert winner的<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>，则重新添加下游接口转发组播数据。</p>
<p>如图6所示，如果DeviceB和DeviceC都能够接收到组播源Source发出的组播报文，并且均能通过RPF检查，创建（S，G）表项。DeviceB、DeviceC的下游接口连接在同一网段，那么DeviceB和DeviceC就会同时向该网段发送组播数据。Assert机制可以保证一个网段只能存在一个组播数据转发者。Assert过程如下：</p>
<ol>
<li>DeviceB从下游接口接收到DeviceC发来的组播报文，RPF检查失败，报文被丢弃。同时，DeviceB向该网段发送<a href="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZM08013_02_zh/HDXAZM08013_02_zh/resources/vrp_pim_cfg_0004.html#ZH-CN_CONCEPT_0000001130783604__section_dc_vrp_multicast_feature_300507">Assert消息</a>。</li>
<li>DeviceC将自身的路由信息与对方的Assert消息中携带的路由信息进行比较，由于自身到组播源的开销较大而落败。于是禁止该下游接口转发组播报文，将其从DeviceC的（S，G）表项的下游接口列表中删除。</li>
<li>DeviceC从该网段接收到DeviceB发来的组播报文，RPF检查失败，报文被丢弃。Assert过程结束。</li>
</ol>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/duanyan10181610.png" alt="duanyan10181610"></p>
<h1 id="PIM-SM"><a href="#PIM-SM" class="headerlink" title="PIM SM"></a>PIM SM</h1><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/pimsm32.png" alt="pimsm32"></p>
<p><strong>RP介绍</strong>：</p>
<p>汇聚点RP（Rendezvous Point）为网络中一台重要的PIM路由器，用于处理源端DR注册信息及组成员加入</p>
<p>请求，网络中的所有PIM路由器都必须知道RP的地址，类似于一个供求信息的汇聚中心。</p>
<p>• 目前可以通过以下方式配置RP：</p>
<p>▫ 静态RP：在网络中的所有PIM路由器上配置相同的RP地址，静态指定RP的位置。</p>
<p>▫ 动态RP：通过选举机制在多个C-RP（Candidate-RP，候选RP）之间选举出RP。</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/rp1.png" alt="rp1"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/2rp.png" alt="2rp"></p>
<p>• PIM-SM（ASM）模式首次形成组播分发树主要依赖RPT构建机制，组播源注册机制与DR选举机制。</p>
<p>▫ RPT构建机制：组播叶子路由器主动建立到RP的组播分发树（RPT）</p>
<p>▫ 组播源注册机制：通过该机制形成组播源到RP的组播分发树（SPT）</p>
<p>▫ DR选举机制：DR负责源端或组成员端组播报文的收发，避免重复组播报文，同时成员端DR还负责发送Join加组消息。</p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/rpt82833.png" alt="rpt82833"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/zhuce0183042.png" alt="zhuce0183042"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/2zhuce83158.png" alt="2zhuce83158"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/dr3316.png" alt="dr3316"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/dr1.png" alt="dr1"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/rptciyou183410.png" alt="rptciyou183410"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/sptqiehuan3531.png"></p>
<ol>
<li>组成员端DR逐跳向源端DR逐跳发送Join报文并创建（S，G）表项，建立源端DR到组成员DR的SPT。</li>
<li>SPT建立后，组成员端DR会沿着RPT逐跳向RP发送剪枝报文，删除（*，G）表项中相应的下游接口。剪枝结束后，RP不再沿RPT转发组播报文到组成员端。</li>
<li>如果SPT不经过RP，RP会继续向源端DR逐跳发送剪枝报文，删除（S，G）表项中相应的下游接口。剪枝结束后，源端DR不再沿“源端DR-RP”的SPT转发组播报文到RP。</li>
</ol>
<p>• 当组播分发树（SPT或RPT）稳定后，成员端DR会周期性发送Join&#x2F;Prune报文，用于维护组播分发树。</p>
<p>• 如果组播在一段时间后（默认210s）没有流量则SPT树会消失，成员端DR恢复到RP的RPT树。</p>
<h1 id="PIM（SSM）"><a href="#PIM（SSM）" class="headerlink" title="PIM（SSM）"></a>PIM（SSM）</h1><p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/ssm822.png" alt="ssm822"></p>
<p><strong>• PIM-SM（SSM）无需Assert机制</strong></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/Q0183905.png" alt="Q0183905"></p>
<p><img src="/2024/05/10/%E7%BB%84%E6%92%AD/bijiao929.png" alt="bijiao929"></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>IGMP</tag>
        <tag>PIM</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全技术</title>
    <url>/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="端口隔离"><a href="#端口隔离" class="headerlink" title="端口隔离"></a>端口隔离</h1><p>为了实现报文之间的二层隔离，用户可以将不同的端口加入不同的VLAN，但这样会浪费有限的VLAN资源。采用端口隔离功能，可以实现同一VLAN内端口之间的隔离。用户只需要将端口加入到隔离组中，就可以实现隔离组内端口之间二层数据的隔离。端口隔离功能为用户提供了更安全、更灵活的组网方案。</p>
<p>端口隔离分为二层隔离三层互通和二层三层都隔离两种模式：</p>
<ul>
<li>如果用户希望隔离同一VLAN内的广播报文，但是不同端口下的用户还可以进行三层通信，则可以将隔离模式设置为二层隔离三层互通。</li>
<li>如果用户希望同一VLAN不同端口下用户彻底无法通信，则可以将隔离模式配置为二层三层均隔离。</li>
</ul>
<p><img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ%E6%88%AA%E5%9B%BE20240813192115.png" alt="QQ截图20240813192115"></p>
<p><img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ%E6%88%AA%E5%9B%BE20240813214627.png" alt="QQ截图20240813214627"></p>
<p><img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ%E6%88%AA%E5%9B%BE20240813214643.png" alt="QQ截图20240813214643"></p>
<p><img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ%E6%88%AA%E5%9B%BE20240813214648.png" alt="QQ截图20240813214648"></p>
<h1 id="MAC地址表安全"><a href="#MAC地址表安全" class="headerlink" title="MAC地址表安全"></a>MAC地址表安全</h1><p>动态MAC地址表项：由接口通过报文中的源MAC地址学习获得，表项可老化。在系统复位、接口板热插拔或接口板复位后，动态表项会丢失。</p>
<p>静态MAC地址表项：由用户手工配置并下发到各接口板，表项不老化。在系统复位、接口板热插拔或接口板复位后，保存的表项不会丢失。接口和MAC地址静态绑定后，其他接口收到源MAC是该MAC地址的报文将会被丢弃。</p>
<p>黑洞MAC地址表项：由用户手工配置，并下发到各接口板，表项不可老化。配置黑洞MAC地址后，源MAC地址或目的MAC地址是该MAC的报文将会被丢弃。</p>
<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813215022.png" alt="QQ截图20240813215022" style="zoom:67%;">

<h1 id="端口安全"><a href="#端口安全" class="headerlink" title="端口安全"></a>端口安全</h1><p>通过在交换机的特定接口上部署端口安全，可以限制接口的MAC地址学习数量，并且配置出现越限时的惩罚措施。</p>
<p>端口安全通过将接口学习到的动态MAC地址转换为安全MAC地址（包括安全动态MAC，安全静态MAC和Sticky MAC），阻止非法用户通过本接口和交换机通信，从而增强设备的安全性。</p>
<p><img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ%E6%88%AA%E5%9B%BE20240813215328.png" alt="QQ截图20240813215328"></p>
<h1 id="MAC地址漂移"><a href="#MAC地址漂移" class="headerlink" title="MAC地址漂移"></a>MAC地址漂移</h1><p>MAC地址漂移是指交换机上一个VLAN内有两个端口学习到同一个MAC地址，后学习到的MAC地址表项覆盖原MAC地址表项的现象。</p>
<p>当一个MAC地址在两个端口之间频繁发生迁移时，即会产生MAC地址漂移现象。</p>
<p>正常情况下，网络中不会在短时间内出现大量MAC地址漂移的情况。出现这种现象一般都意味着网络中存在环路，或者存在网络攻击行为。</p>
<p>防止mac地址漂移：</p>
<p><img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ%E6%88%AA%E5%9B%BE20240813215508.png" alt="QQ截图20240813215508"></p>
<p>交换机支持MAC地址漂移检测机制，分为以下两种方式：</p>
<p>基于VLAN的MAC地址漂移检测</p>
<p>配置<strong>VLAN的MAC地址漂移</strong>检测功能可以检测指定VLAN下的所有的MAC地址是否发生漂移。当MAC地址发生漂移后，可以配置指定的动作，例如告警、阻断接口或阻断MAC地址。</p>
<p><strong>全局MAC地址漂移检测</strong>该功能可以检测设备上的所有的MAC地址是否发生了漂移。若发生漂移，设备会上报告警到网管系统。用户也可以指定发生漂移后的处理动作，例如将接口关闭或退出VLAN。</p>
<h1 id="MACsec"><a href="#MACsec" class="headerlink" title="MACsec"></a>MACsec</h1><img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813220540.png" alt="QQ截图20240813220540" style="zoom:67%;">

<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813220545.png" alt="QQ截图20240813220545" style="zoom:67%;">

<h1 id="交换机流量控制"><a href="#交换机流量控制" class="headerlink" title="交换机流量控制"></a>交换机流量控制</h1><p>流量抑制：</p>
<p>络中存在的问题：正常情况下，当设备某个二层以太接口收到广播、未知组播或未知单播报文时，会向同一VLAN内的其他二层以太接口转发这些报文，从而导致流量泛洪，降低设备转发性能。</p>
<p>当设备某个以太接口收到已知组播或已知单播报文时，如果某种报文流量过大则可能会对设备造成冲击，影响其他业务的正常处理。</p>
<p>可用的解决方案：流量抑制可以通过配置阈值来限制广播、未知组播、未知单播、已知组播和已知单播报文的速率，防止广播、未知组播报文和未知单播报文产生流量泛洪，阻止已知组播报文和已知单播报文的大流量冲击。</p>
<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813221236.png" alt="QQ截图20240813221236" style="zoom:67%;">

<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813221241.png" alt="QQ截图20240813221241" style="zoom:67%;">

<p>在交换机接口的入方向，例如下图中SW1的GE0&#x2F;0&#x2F;1入方向，通过流量抑制功能可以限制任意报文的发送速率。</p>
<p>在交换机接口出方向，例如下图中SW1的GE0&#x2F;0&#x2F;1出方向，通过流量抑制功能可以阻塞广播，未知组播和未知单播报文。</p>
<p>在交换机的VLAN视图下，通过配置VLAN内流量抑制限制VLAN内广播报文。</p>
<p>风暴控制：</p>
<p>网络中存在的问题：正常情况下，当设备某个二层以太接口收到广播、未知组播或未知单播报文时，会向同一VLAN内的其他二层以太接口转发这些报文，如果网络存在环路，则会导致广播风暴，严重降低设备转发性能。</p>
<p>可用的解决方案：风暴控制可以通过阻塞报文或关闭端口来阻断广播、未知组播和未知单播报文的流量。</p>
<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813221726.png" alt="QQ截图20240813221726" style="zoom:67%;">

<p>风暴控制与流量抑制相比的优势是可以同时监控接口下的广播报文、未知组播报文和未知单播报文各自的包平均速率，并根据阈值对接口采取阻塞相关报文或者关闭物理接口的惩罚动作。</p>
<h1 id="DHCP-Snooping"><a href="#DHCP-Snooping" class="headerlink" title="DHCP Snooping"></a>DHCP Snooping</h1><img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813222210.png" alt="QQ截图20240813222210" style="zoom:67%;">

<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813223518.png" alt="QQ截图20240813223518" style="zoom:67%;">

<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813223721.png" alt="QQ截图20240813223721" style="zoom:67%;">

<p>DHCP Snooping绑定表根据DHCP租期进行老化或根据用户释放IP地址时发出的DHCP Release报文自动删除对应表项。</p>
<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813223730.png" alt="QQ截图20240813223730" style="zoom:67%;">

<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813223736.png" alt="QQ截图20240813223736" style="zoom:67%;">

<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813223741.png" alt="QQ截图20240813223741" style="zoom:67%;">

<p>DHCP饿死攻击是攻击者通过持续大量地向DHCP Server申请IP地址来实现的，其目的是耗尽DHCP Server地址池中的IP地址，导致DHCP Server没有IP地址分配给正常的用户。</p>
<p>DHCP消息中有一个名叫CHADDR（Client Hardware Address）的字段，该字段是由DHCP客户端填写的，表示的是客户端的硬件地址（也就是客户端的MAC地址）。DHCP Server是针对CHADDR来分配IP地址的，对于不同的CHADDR，DHCP Server会分配不同的IP地址；DHCP Server无法区分什么样的CHADDR是合法的，什么样的CHADDR是非法的。利用这个漏洞，攻击者每申请一个IP地址时，就在DHCP消息的CHADDR字段中填写一个不同的值，以此来冒充是不同的用户在申请IP地址</p>
<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813223746.png" alt="QQ截图20240813223746" style="zoom:67%;">

<p>为了弥补上述漏洞，从而阻止饿死攻击，DHCP Snooping技术支持在端口下对DHCP Request报文的源MAC地址与CHADDR进行一致性检查：如果二者相同，则转发报文；如果二者不相同，则丢弃。如果要在某端口下实施源MAC地址与CHADDR的一致性检查，可以在该端口下使用命令dhcp snooping check dhcp-chaddr enable。还可能存在这样一种饿死攻击，就是攻击者不断同时变换MAC地址和CHADDR，并且每一次变换时，都让CHADDR与MAC地址相同，如此一来，便可以躲过上述源MAC地址与CHADDR的一致性检查！</p>
<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813223759.png" alt="QQ截图20240813223759" style="zoom:67%;">

<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813223804.png" alt="QQ截图20240813223804" style="zoom:67%;">

<h1 id="IPSG"><a href="#IPSG" class="headerlink" title="IPSG"></a>IPSG</h1><img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813231402.png" alt="QQ截图20240813231402" style="zoom:67%;">

<img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ截图20240813231407.png" alt="QQ截图20240813231407" style="zoom:67%;">

<h1 id="防火墙双机热备"><a href="#防火墙双机热备" class="headerlink" title="防火墙双机热备"></a>防火墙双机热备</h1><p>在网络中部署防火墙双机时面临的问题</p>
<p><img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ%E6%88%AA%E5%9B%BE20240814185824.png" alt="QQ截图20240814185824"></p>
<p>双机热备需要两台硬件和软件配置均相同的防火墙组成双机热备系统。</p>
<p>防火墙之间通过独立的链路连接（心跳线），通过心跳线了解对端的健康状况，向对端备份配置和表项（如会话表、IPsec SA等）。</p>
<p>当一台防火墙出现故障时，业务流量能平滑地切换到另一台设备上处理，使业务不中断。</p>
<p>部署要求：</p>
<p>目前只支持两台设备进行双机热备。</p>
<p>主备设备的产品型号和版本必须相同。</p>
<p>主备设备业务板和接口卡的位置、类型和数目都须相同，否则会出现主用设备备份过去的信息，与备用设备的物理配置无法兼容，导致主备切换后出现问题</p>
<p><img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ%E6%88%AA%E5%9B%BE20240814190427.png" alt="QQ截图20240814190427"></p>
<p>为了实现主用设备出现故障时备用设备能平滑地接替工作，必须在主用和备用设备之间备份关键配置命令和状态信息。</p>
<p>防火墙能够备份的配置如下：</p>
<p>策略：安全策略、NAT策略（包括NAT地址池）、NAT Server等。对象：地址、地区、服务、应用、用户等。</p>
<p>网络：安全区域、DNS、IPsec、SSL VPN等。</p>
<p>系统：管理员、虚拟系统、日志配置。</p>
<p>防火墙能够备份的状态信息如下：会话表、SeverMap表、黑名单&#x2F;白名单、PAT方式端口映射表、NO-PAT方式地址映射表、二层转发表（静态MAC备份）、AAA用户表（缺省用户admin不备份）、在线用户监控表、PKI证书、IPsec备份等。</p>
<h1 id="防火墙虚拟系统"><a href="#防火墙虚拟系统" class="headerlink" title="防火墙虚拟系统"></a>防火墙虚拟系统</h1><p><img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ%E6%88%AA%E5%9B%BE20240814190623.png" alt="QQ截图20240814190623"></p>
<p><img src="/2024/08/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/QQ%E6%88%AA%E5%9B%BE20240814190730.png" alt="QQ截图20240814190730"></p>
<p>1、创建虚拟系统</p>
<p>[FW1]vsys enable </p>
<p>[FW1]vsys name A</p>
<p>[FW1-vsys-A]assign interface g1&#x2F;0&#x2F;0</p>
<p>2、接口加入安全区域</p>
<p>[FW1]switch vsys A</p>
<p>[FW1-A]firewall zone trust </p>
<p>[FW1-A-zone-trust]add int g1&#x2F;0&#x2F;0</p>
<p>[FW1-A]fir zon untrust </p>
<p>[FW1-A-zone-untrust]add interface Virtual-if 1</p>
<p>3、配置IP地址</p>
<p>4、配置安全策略</p>
<p>进入虚拟系统配置安全策略</p>
<p>se</p>
<p> rule name 111</p>
<p>  source-zone trust</p>
<p>  destination-zone untrust</p>
<p>  source-address 10.1.1.0 mask 255.255.255.0</p>
<p>  destination-address 10.2.2.0 mask 255.255.255.0</p>
<p>  service icmp</p>
<p>  action permit</p>
<p>5、配置路由</p>
<p>每个虚拟系统都只有自己的路由，需要配置虚拟系统之间的互通路由</p>
<p>[FW1]ip route-static vpn-instance A 10.2.2.0 24 vpn-instance B</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>端口隔离</tag>
        <tag>DHCP Snooping</tag>
        <tag>MAC地址漂移</tag>
        <tag>MAC地址表安全</tag>
      </tags>
  </entry>
  <entry>
    <title>vlan间通信</title>
    <url>/2023/11/24/vlan%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="VLAN间通信"><a href="#VLAN间通信" class="headerlink" title="VLAN间通信"></a>VLAN间通信</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>划分VLAN后，不同VLAN的用户间不能二层互访，这样能起到隔离广播的作用。但实际应用中，不同VLAN的用户又常有互访的需求，此时就需要实现不同VLAN的用户互访，简称VLAN间互访。</p>
<span id="more"></span>

<h2 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h2><p><img src="/2023/11/24/vlan%E9%97%B4%E9%80%9A%E4%BF%A1/vlantx001.png" alt="vlantx001"></p>
<p>详解：R2划入vlan2，R3划入vlan3，与交换机之间采用access口，由于交换机g0&#x2F;0&#x2F;1需要通过多个vlan，所以配成trunk口。R2和R3相当于主机，发送和接受的数据都不带标签，交换机g0&#x2F;0&#x2F;2收到R2发送的数据，打上标签vlan2，然后发出去；交换机g0&#x2F;0&#x2F;1收到数据后，发现vlan的标签允许通过，则数据带着vlan2的标签通过；然后交换机g0&#x2F;0&#x2F;3口转发数据时，发现自己的pvid是vlan3，和vlan2不一样，所以不接受，则vlan2和vlan3不能通信。</p>
<p>在某些场景下，需要特定vlan之间通信</p>
<p>方法一：dot1q接口</p>
<p>在r1上配置两个dot1q接口，g0&#x2F;0&#x2F;1.1和g0&#x2F;0&#x2F;1.2，分别对应vlan2和vlan3，作用就是可以终结vlan标签（剥离），vlan2的标签到r1后，被剥离掉vlan2的标签，然后转发时又被g0&#x2F;0&#x2F;1.2打上vlan3的标签，交换机g0&#x2F;0&#x2F;1通过，到g0&#x2F;0&#x2F;3，access口发现和自己的pvid一样，然后剥离掉标签，转发数据帧给r3.</p>
<p>方法二：vlanif接口：交换机上配置vlanif2和vlanif3，ip地址配成192.168.2.254和192.168.3.254</p>
<p>其实就是相当于两个不同网段的网关，然后实现三层的转发</p>
<h2 id="Access接口"><a href="#Access接口" class="headerlink" title="Access接口"></a>Access接口</h2><p>交换机上常用来连接用户PC、服务器等终端设备的接口。Access接口所连接的这些设备的网卡往往只收发无标记帧。Access接口只能加入一个VLAN。只能允许一个VLAN通过。</p>
<p><strong>转发原则</strong></p>
<p>接收原则：</p>
<p>①收到不带标签的数据帧，打上标签，vlan id&#x3D;端口的PVID</p>
<p>②收到带标签的数据帧，检查数据帧vlan id是否和端口的PVID相同，相同直接接收；不同拒绝接收</p>
<p>发送原则：</p>
<p>①数据帧vlan id和端口PVID 相同，剥离标签发送；</p>
<p>②数据帧vlan id和端口PVID 不同，禁止发送。</p>
<h2 id="Trunk接口"><a href="#Trunk接口" class="headerlink" title="Trunk接口"></a>Trunk接口</h2><p>Trunk接口允许多个VLAN的数据帧通过，这些数据帧通过802.1Q Tag实现区分。Trunk接口常用于交换机之间的互联，也用于连接路由器、防火墙等设备的</p>
<p>子接口</p>
<p><strong>转发原则</strong></p>
<p>接收原则：</p>
<p>①收到不带标签的数据帧，打上标签，vlan id&#x3D;端口的PVID，然后查看该vlanid是否在允许列表中，是–接收，不是–拒绝</p>
<p>②收到带标签的数据帧，查看该vlan id是否在允许列表中，是–接收，不是–拒绝</p>
<p>发送原则：</p>
<p>查看vlan id是否在允许列表中，I:不是–拒绝发送；II：是，查看接口的PVID和vlan id是否相同，相同–剥标签发送；不同–直接发送。</p>
<h2 id="Hybrid接口"><a href="#Hybrid接口" class="headerlink" title="Hybrid接口"></a>Hybrid接口</h2><p>Hybrid接口与Trunk接口类似，也允许多个VLAN的数据帧通过，这些数据帧通过802.1Q Tag实现区分。用户可以灵活指定Hybrid接口在发送某个（或某些）VLAN的数据帧时是否携带Tag</p>
<p><strong>转发原则</strong></p>
<p>接收原则：</p>
<p>①收到不带标签的数据帧，打上标签，vlan id&#x3D;端口的PVID，然后查看该vlanid是否在允许列表中，是–接收，不是–拒绝</p>
<p>②收到带标签的数据帧，查看该vlan id是否在允许列表中，是–接收，不是–拒绝发送原则：查看vlan id是否在允许列表中，I:不是–拒绝发送；II：是，是否带标签发送取决于接口的配置。</p>
<h2 id="PVID"><a href="#PVID" class="headerlink" title="PVID"></a>PVID</h2><p>可以手工修改，默认是1，access口的就是本身的vlan号，trunk可以有一个主vlan和多个副vlan，收到的数据和主vlan相同就剥离转发，收到和主vlan不一样的标签，查表，看看是不是在允许通过的列表，如果有，就带着原来的转发，要是没有，就不让过去啦。</p>
<h2 id="实验配置过程"><a href="#实验配置过程" class="headerlink" title="实验配置过程"></a>实验配置过程</h2><p># R2和R3的IP地址及网关配置</p>
<p><R2> system-view</R2></p>
<p>Enter system view, return user view with Ctrl+Z.</p>
<p>[R2]interface GigabitEthernet 0&#x2F;0&#x2F;1</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1]ip address 192.168.2.1 24</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;1]quit	</p>
<p>[R2]ip route-static 0.0.0.0 0 192.168.2.254</p>
<p>配置默认路由，相当于给设备配置了网关。</p>
<p><R3>system-view </R3></p>
<p>Enter system view, return user view with Ctrl+Z.</p>
<p>[R3]interface GigabitEthernet 0&#x2F;0&#x2F;1</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;1]ip address 192.168.3.1 24</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;1]quit</p>
<p>[R3]ip route-static 0.0.0.0 0 192.168.3.254</p>
<p># 在S1上对R2和R3进行VLAN划分</p>
<p>[S1]vlan batch 2 3</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;2</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;2]port link-type access </p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;2]port default vlan 2</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;2]quit</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;3</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;3]port link-type access </p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;3]port default vlan 3</p>
<p>步骤 1 通过Dot1q终结子接口实现VLAN间互访 </p>
<p># 配置S1上的Trunk接口</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;1</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;1]port trunk allow-pass vlan 2 3</p>
<p><em>因为VLAN间<strong>互访数据要</strong>由R1来终结VLAN<strong>，</strong>所以S1和R1之间<strong>的链路要允许</strong>VLAN2和VLAN3通过**。</em></p>
<p># 在R1上创建并配置Dot1q终结子接口</p>
<p>[R1]interface GigabitEthernet 0&#x2F;0&#x2F;1.2 </p>
<p>创建并进入子接口视图。2代表子接口的编号，一般建议子接口编号与VLAN ID相同，方便记忆。</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.2]dot1q termination vid 2 </p>
<p><strong>dot1q termination vid</strong> <em>vlan-id</em>命令用来配置子接口Dot1q终结的VLAN ID。</p>
<p>以此配置为例：当GigabitEthernet0&#x2F;0&#x2F;1接口收到带有VLAN 2标签的数据之后，会交由2号子接口进行VLAN终结操作并做后续处理。从2号子接口发出的数据也会带上VLAN 2的标签。</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.2]arp broadcast enable </p>
<p>终结子接口不能转发广播报文，在收到广播报文后它们直接把该报文丢弃。为了允许终结子接口能转发广播报文，可以通过在子接口上执行命令<strong>arp broadcast enable</strong>使能终结子接口的ARP广播功能。部分设备默认使能该功能，此命令的配置根据设备而定。</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.2]ip address 192.168.2.254 24 </p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.2]quit</p>
<p>[R1]interface GigabitEthernet 0&#x2F;0&#x2F;1.3</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.3]dot1q termination vid 3</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.3]arp broadcast enable</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.3]ip address 192.168.3.254 24</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;1.3]quit</p>
<p># 检测VLAN间互访联通性 </p>
<p><R2>ping 192.168.3.1</R2></p>
<p> PING 192.168.3.1: 56  data bytes, press CTRL_C to break</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;1 ttl&#x3D;254 time&#x3D;60 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;2 ttl&#x3D;254 time&#x3D;40 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;3 ttl&#x3D;254 time&#x3D;110 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;4 ttl&#x3D;254 time&#x3D;70 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;5 ttl&#x3D;254 time&#x3D;100 ms</p>
<p> — 192.168.3.1 ping statistics —</p>
<p>  5 packet(s) transmitted</p>
<p>  5 packet(s) received</p>
<p>  0.00% packet loss</p>
<p>  round-trip min&#x2F;avg&#x2F;max &#x3D; 40&#x2F;76&#x2F;110 ms</p>
<p><R2>tracert 192.168.3.1 </R2></p>
<p> traceroute to  192.168.3.1(192.168.3.1), max hops: 30 ,packet length: 40,press CTRL_C to break </p>
<p> 1 192.168.2.254 30 ms  50 ms  50 ms </p>
<p> 2 192.168.3.1 70 ms  60 ms  60 ms </p>
<p>此时VLAN2和VLAN3之间已经可以正常的互访。</p>
<p>步骤 2 通过VLANIF接口实现VLAN间互访</p>
<p># 清除上一步配置</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;1</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;1]undo port trunk allow-pass vlan 2 3</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;1]undo port link-type</p>
<p>[R1]undo interface GigabitEthernet 0&#x2F;0&#x2F;1.2 </p>
<p>[R1]undo interface GigabitEthernet 0&#x2F;0&#x2F;1.3</p>
<p># 在S1上创建相应的VLANIF接口 </p>
<p>[S1]interface Vlanif 2</p>
<p><strong>interface vlanif</strong> <em>vlan-id</em>命令用来创建VLANIF接口并进入VLANIF接口视图。只有先通过命令创建VLAN后，才能执行interface vlanif命令创建VLANIF接口。</p>
<p>[S1-Vlanif2]ip address 192.168.2.254 24</p>
<p>[S1-Vlanif2]quit</p>
<p>[S1]interface Vlanif 3</p>
<p>[S1-Vlanif3]ip address 192.168.3.254 24 </p>
<p>[S1-Vlanif3]quit</p>
<p># 检测VLAN间互访联通性</p>
<p><R2>ping 192.168.3.1 </R2></p>
<p> PING 192.168.3.1: 56  data bytes, press CTRL_C to break</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;1 ttl&#x3D;254 time&#x3D;100 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;2 ttl&#x3D;254 time&#x3D;50 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;3 ttl&#x3D;254 time&#x3D;50 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;4 ttl&#x3D;254 time&#x3D;60 ms</p>
<p>  Reply from 192.168.3.1: bytes&#x3D;56 Sequence&#x3D;5 ttl&#x3D;254 time&#x3D;70 ms</p>
<p> — 192.168.3.1 ping statistics —</p>
<p>  5 packet(s) transmitted</p>
<p>  5 packet(s) received</p>
<p>  0.00% packet loss</p>
<p>  round-trip min&#x2F;avg&#x2F;max &#x3D; 50&#x2F;66&#x2F;100 ms</p>
<p><R2>tracert 192.168.3.1 </R2></p>
<p> traceroute to  192.168.3.1(192.168.3.1), max hops: 30 ,packet length: 40,press CTRL_C to break </p>
<p> 1 192.168.2.254 40 ms  30 ms  20 ms </p>
<p> 2 192.168.3.1 40 ms  30 ms  40 ms</p>
<p>此时VLAN2和VLAN3之间已经可以正常的互访。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>vlan间通信</tag>
        <tag>dot1q</tag>
        <tag>vlanif</tag>
      </tags>
  </entry>
  <entry>
    <title>路由策略</title>
    <url>/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h1><p>访问控制列表ACL（Access Control List）是由一条或多条规则组成的集合。所谓规则，是指描述报文匹配条件的判断语句，这些条件可以是报文的源地址、目的地址、端口号等。</p>
<p>ACL本质上是一种报文过滤器，规则是过滤器的滤芯。设备基于这些规则进行报文匹配，可以过滤出特定的报文，并根据应用ACL的业务模块的处理策略来允许或阻止该报文通过。</p>
<p>ACL可以实现对网络中报文流的精确识别和控制，达到控制网络访问行为、防止网络攻击和提高网络带宽利用率的目的，从而切实保障网络环境的安全性和网络服务质量的可靠性。</p>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722195623.png" alt="QQ截图20240722195623" style="zoom:67%;">

<h2 id="ACL匹配机制"><a href="#ACL匹配机制" class="headerlink" title="ACL匹配机制"></a>ACL匹配机制</h2><p>设备将报文与ACL规则进行匹配时，遵循“一旦命中即停止匹配”的机制，当找到一条符合匹配条件的规则时，结束查找。</p>
<p>报文与ACL规则匹配后，会产生两种结果：“命中规则”和“未命中规则”。</p>
<ul>
<li>命中规则：指存在ACL，且在ACL中查找到了符合匹配条件的规则</li>
<li>未命中规则：指不存在ACL，或ACL中无规则，再或者在ACL中遍历了所有规则都没有找到符合匹配条件的规则。</li>
</ul>
<p>报文最终是被允许通过还是拒绝通过，实际是ACL规则中的指定动作和应用ACL的各个业务模块来共同决定。不同的业务模块，对命中和未命中规则报文的处理方式也各不相同。</p>
<p>系统按照ACL规则编号从小到大的顺序进行报文匹配，规则编号越小越容易被匹配。</p>
<ul>
<li>如果配置规则时指定了规则编号，则规则编号越小，规则插入位置越靠前，该规则越先被匹配。</li>
<li>如果配置规则时未指定规则编号，则由系统自动为其分配一个编号。该编号是一个大于当前ACL内最大规则编号且是步长整数倍的最小整数，因此该规则会被最后匹配。</li>
</ul>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722195941.png" alt="QQ截图20240722195941" style="zoom:67%;">

<h1 id="IP前缀列表"><a href="#IP前缀列表" class="headerlink" title="IP前缀列表"></a>IP前缀列表</h1><p>IP前缀列表（IP-Prefix List）是将路由条目的网络地址、掩码长度作为匹配条件的过滤器，可在各路由协议发布和接收路由时使用。</p>
<p>不同于ACL，IP-Prefix List能够同时匹配IP地址前缀长度以及掩码长度，增强了匹配的精确度。</p>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722200123.png" alt="QQ截图20240722200123" style="zoom:67%;">

<p>匹配机制和ACL一样</p>
<h1 id="Filter-Policy"><a href="#Filter-Policy" class="headerlink" title="Filter-Policy"></a>Filter-Policy</h1><p>Filter-Policy（过滤-策略）是一个很常用的路由信息过滤工具，能够对接收、发布、引入的路由进行过滤，可应用于IS-IS、OSPF、BGP等协议。</p>
<p>filter-policy在距离矢量路由协议中的应用</p>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722204905.png" alt="QQ截图20240722204905" style="zoom:67%;">

<p>filter-policy在链路状态路由协议中的应用</p>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722205009.png" alt="QQ截图20240722205009" style="zoom:67%;">

<p>在链路状态路由协议中，各路由设备之间传递的是LSA信息，然后设备根据LSA汇总成的LSDB信息计算出路由表。以OSPF为例，filter-policy生效规则如下：</p>
<ul>
<li><p><strong>filter-policy import</strong>命令实际上是对OSPF计算出来的路由进行过滤，不是对发布和接收的LSA进行过滤。filter-policy import命令对接收的路由设置过滤策略，只有通过过滤策略的路由才被添加到路由表中，没有通过过滤策略的路由不会被添加进路由表，<strong>但不影响对外发布出去。</strong>（只影响本地全局路由表）</p>
</li>
<li><p><strong>filter-policy export</strong>命令用来对引入的路由在发布时进行过滤，只将满足条件的外部路由转换为Type5 LSA（AS-external-LSA）并发布出去。这样可以在引入外部路由时进行特定的过滤，防止形成路由环路。</p>
<p>OSPF通过命令import-route引入外部路由后，为了避免路由环路的产生，通过filter-policy export命令对引入的路由在发布时进行过滤，只将满足条件的外部路由转换为Type5 LSA（AS-external-LSA）并发布出去。（影响后边的路由器的ospf路由表和全局路由表）</p>
</li>
</ul>
<p>import示例：</p>
<p>（1）通过filter-policy对OSPF接收的路由过滤（区域内）示例</p>
<p>三台交换机同属于OSPF Area 0区域，SwitchA发布测试网段10.1.1.0&#x2F;24，要求在SwitchB上部署<strong>filter-policy import</strong>，使得SwitchB的路由表中不允许出现10.1.1.0&#x2F;24这条路由。</p>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722211024.png" alt="QQ截图20240722211024" style="zoom:67%;">

<p><strong>配置方法</strong></p>
<ol>
<li><p>在SwitchB上定义一个地址前缀列表，“抓取”符合条件的路由。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SwitchB] ip ip-prefix huawei index 10 deny 10.1.1.0 24           //拒绝这条</span><br><span class="line">[SwitchB] ip ip-prefix huawei index 20 permit 0.0.0.0 0 less-equal 32     //允许所有</span><br></pre></td></tr></table></figure>
</li>
<li><p>在SwitchB的OSPF视图中，部署filter-policy import。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SwitchB] ospf</span><br><span class="line">[SwitchB-ospf-1] filter-policy ip-prefix huawei import</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>结果验证</strong></p>
<p>做完上述配置以后，查看SwitchB和SwitchC的路由表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SwitchB] display ip routing-table</span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 6        Routes : 6        </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">   192.168.12.0/24  Direct  0    0           D   192.168.12.2    Vlanif12</span><br><span class="line">   192.168.12.2/32  Direct  0    0           D   127.0.0.1       Vlanif12</span><br><span class="line">   192.168.23.0/24  Direct  0    0           D   192.168.23.1    Vlanif23</span><br><span class="line">   192.168.23.1/32  Direct  0    0           D   127.0.0.1       Vlanif23</span><br><span class="line">（B的ip路由表中被过滤，但ospf路由表在仍然存在）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[SwitchC] display ip routing-table</span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 6        Routes : 6        </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">       10.1.1.0/24  OSPF    10   3           D   192.168.23.1    Vlanif23</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">   192.168.12.0/24  OSPF    10   2           D   192.168.23.1    Vlanif23</span><br><span class="line">   192.168.23.0/24  Direct  0    0           D   192.168.23.2    Vlanif23</span><br><span class="line">   192.168.23.2/32  Direct  0    0           D   127.0.0.1       Vlanif23</span><br></pre></td></tr></table></figure>

<p>通过SwitchB和SwitchC的路由表可以看到，虽然在SwitchB上10.1.1.0&#x2F;24这条路由已经被过滤掉，但是LSA信息会继续传递给SwitchC，所以SwitchC的路由表中继续存在10.1.1.0&#x2F;24这条路由。这样的结果也验证了一开始在注意事项中给出的结论：在链路状态路由协议中，filter-policy只能过滤路由信息，不能过滤LSA信息。</p>
<p>同时SwitchB和SwitchC的LSDB中仍然存在描述10.1.1.0&#x2F;24这条路由的LSA信息，此处可以通过查看SwitchB和SwitchC的LSA信息进行验证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SwitchB] display ospf lsdb router</span><br><span class="line"></span><br><span class="line">   OSPF Process 1 with Router ID 10.10.10.2</span><br><span class="line">              Area: 0.0.0.0</span><br><span class="line">      Link State Database </span><br><span class="line">………</span><br><span class="line"></span><br><span class="line">  Type      : Router</span><br><span class="line">  Ls id     : 10.10.10.1</span><br><span class="line">  Adv rtr   : 10.10.10.1  </span><br><span class="line">  Ls age    : 139 </span><br><span class="line">  Len       : 48 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000005 </span><br><span class="line">  chksum    : 0x41c4</span><br><span class="line">  Link count: 2</span><br><span class="line">   * Link ID: 10.1.1.0     </span><br><span class="line">     Data   : 255.255.255.0 </span><br><span class="line">     Link Type: StubNet      </span><br><span class="line">     Metric : 1 </span><br><span class="line">     Priority : Low</span><br><span class="line">   * Link ID: 192.168.12.2 </span><br><span class="line">     Data   : 192.168.12.1 </span><br><span class="line">     Link Type: TransNet     </span><br><span class="line">     Metric : 1</span><br><span class="line">[SwitchC] display ospf lsdb router</span><br><span class="line"></span><br><span class="line">   OSPF Process 1 with Router ID 10.10.10.3</span><br><span class="line">             Area: 0.0.0.0</span><br><span class="line">     Link State Database </span><br><span class="line">…………</span><br><span class="line"></span><br><span class="line">  Type      : Router</span><br><span class="line">  Ls id     : 10.10.10.1</span><br><span class="line">  Adv rtr   : 10.10.10.1  </span><br><span class="line">  Ls age    : 81 </span><br><span class="line">  Len       : 48 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000005 </span><br><span class="line">  chksum    : 0x41c4</span><br><span class="line">  Link count: 2</span><br><span class="line">   * Link ID: 10.1.1.0     </span><br><span class="line">     Data   : 255.255.255.0 </span><br><span class="line">     Link Type: StubNet      </span><br><span class="line">     Metric : 1 </span><br><span class="line">     Priority : Low</span><br><span class="line">   * Link ID: 192.168.12.2 </span><br><span class="line">     Data   : 192.168.12.1 </span><br><span class="line">     Link Type: TransNet     </span><br><span class="line">     Metric : 1</span><br></pre></td></tr></table></figure>

<p>可以看到SwitchB和SwitchC的LSDB中仍然存在描述10.1.1.0&#x2F;24这条路由的LSA信息。</p>
<p>（2）通过filter-policy对OSPF接收的路由过滤（区域间）</p>
<p>相对于上一个场景，这个场景的区别之处是划分了两个不同的区域，SwitchB和SwitchC之间传递的是Type3 LSA，这个Type3 LSA是SwitchB上根据区域间路由生成的。配置方法跟上一个场景一样，此处不再赘述。</p>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722211339.png" alt="QQ截图20240722211339" style="zoom:67%;">

<p>在部署路由过滤策略之前，SwitchB和SwitchC的路由表中都有10.1.1.0&#x2F;24这条路由。</p>
<p>在SwitchB上部署filter-policy import以后，查看SwitchB和SwitchC的路由表，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SwitchB] display  ip routing-table</span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 6        Routes : 6        </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">   192.168.12.0/24  Direct  0    0           D   192.168.12.2    Vlanif12</span><br><span class="line">   192.168.12.2/32  Direct  0    0           D   127.0.0.1       Vlanif12</span><br><span class="line">   192.168.23.0/24  Direct  0    0           D   192.168.23.1    Vlanif23</span><br><span class="line">   192.168.23.1/32  Direct  0    0           D   127.0.0.1       Vlanif23</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[SwitchC] display ip routing-table</span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 5        Routes : 5        </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">   192.168.12.0/24  OSPF    10   2           D   192.168.23.1    Vlanif23</span><br><span class="line">   192.168.23.0/24  Direct  0    0           D   192.168.23.2    Vlanif23</span><br><span class="line">   192.168.23.2/32  Direct  0    0           D   127.0.0.1       Vlanif23</span><br></pre></td></tr></table></figure>

<p>由于现在划分不同的区域，SwitchC上的10.1.1.0&#x2F;24这条路由是由SwitchB根据自身学习的路由产生的Type3-LSA描述的，而SwitchB上的这条路由被过滤掉了，因此不能够再产生描述区域间路由的这个Type3-LSA，因此SwitchC上不会再学习到10.1.1.0&#x2F;24这条路由。</p>
<p>export示例：</p>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722213321.png" alt="QQ截图20240722213321" style="zoom:67%;">

<p>在R1上创建四个环回口，IP地址分别为192.168.1.0&#x2F;24，192.168.2.0&#x2F;24、192.168.3.0&#x2F;24、192.168.4.0&#x2F;24，并且全部宣告进OSPF。</p>
<p>引入直连，但是要保证R2和R3上只能收到192.168.1.0这条路由</p>
<p>通过Filter-policy让R2和R3只能收到192.168.1.0这条路由</p>
<p>[R1]ip ip-prefix ly permit 192.168.1.0 24  </p>
<p>[R1]ospf</p>
<p>[R1-ospf-1]filter-policy ip-prefix ly export</p>
<p>【技术要点】</p>
<ul>
<li>OSPF通过命令import-route引入外部路由后，为了避免路由环路的产生，通过filter-policy export命令对引入的路由在发布时进行过滤，只将满足条件的外部路由转换为Type5 LSA（AS-external-LSA）并发布出去。</li>
<li>当网络中同时部署了IS-IS和其他路由协议时，如果已经在边界设备上引入其他路由协议的路由，缺省情况下，该设备将把引入的全部外部路由发布给IS-IS邻居。如果只希望将引入的部分外部路由发布给邻居，可以使用****filter-policy export****命令实现。</li>
</ul>
<h1 id="Route-Policy"><a href="#Route-Policy" class="headerlink" title="Route-Policy"></a>Route-Policy</h1><p>Route-Policy是一个策略工具，用于过滤路由信息，以及为过滤后的路由信息设置路由属性。</p>
<p>一个Route-Policy由一个或多个节点（Node）构成，每个节点都可以是一系列条件语句（匹配条件）以及执行语句（执行动作）的集合，这些集合按照编号从小到大的顺序排列。</p>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722213733.png" alt="QQ截图20240722213733" style="zoom:67%;">



<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722213925.png" alt="QQ截图20240722213925" style="zoom:67%;">

<p><img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ%E6%88%AA%E5%9B%BE20240722214213.png" alt="QQ截图20240722214213"></p>
<p>示例：</p>
<p><img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ%E6%88%AA%E5%9B%BE20240722214325.png" alt="QQ截图20240722214325"></p>
<p><img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ%E6%88%AA%E5%9B%BE20240722214336.png" alt="QQ截图20240722214336"></p>
<h2 id="双点双向路由重发布"><a href="#双点双向路由重发布" class="headerlink" title="双点双向路由重发布"></a>双点双向路由重发布</h2><img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722215733.png" alt="QQ截图20240722215733" style="zoom:67%;">

<p>解决次优路径：</p>
<ol>
<li></li>
</ol>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722221125.png" alt="QQ截图20240722221125" style="zoom:67%;">

<ol start="2">
<li></li>
</ol>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722221200.png" alt="QQ截图20240722221200" style="zoom:67%;">

<p>环路问题：</p>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722221321.png" alt="QQ截图20240722221321" style="zoom:67%;">

<p>解决环路：</p>
<ol>
<li></li>
</ol>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722221447.png" alt="QQ截图20240722221447" style="zoom:67%;">

<ol start="2">
<li></li>
</ol>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722221758.png" alt="QQ截图20240722221758" style="zoom:67%;">

<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722221815.png" alt="QQ截图20240722221815" style="zoom:67%;">

<h1 id="策略路由"><a href="#策略路由" class="headerlink" title="策略路由"></a>策略路由</h1><p>若设备部署了PBR，则被匹配的报文优先根据PBR的策略进行转发，即PBR策略的优先级高于传统路由表。</p>
<p>策略路由PBR（Policy-Based Routing）是一种依据用户制定的策略进行路由选择的机制，分为<strong>本地策略路由</strong>、<strong>接口策略路由</strong>和<strong>智能策略路由</strong>SPR（Smart Policy Routing）。</p>
<p>策略路由与路由策略（Routing Policy）存在以下不同：</p>
<ul>
<li>策略路由的操作对象是数据包，在路由表已经产生的情况下，不按照路由表进行转发，而是根据需要，依照某种策略改变数据包转发路径。</li>
<li>路由策略的操作对象是路由信息。路由策略主要实现了路由过滤和路由属性设置等功能，它通过改变路由属性（包括可达性）来改变网络流量所经过的路径。</li>
</ul>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722222211.png" alt="QQ截图20240722222211" style="zoom:67%;">

<p>语法：</p>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722222345.png" alt="QQ截图20240722222345" style="zoom:67%;">



<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240722222609.png" alt="QQ截图20240722222609" style="zoom:67%;">



<h1 id="MQC"><a href="#MQC" class="headerlink" title="MQC"></a>MQC</h1><p>MQC（Modular QoS Command-Line Interface，模块化QoS命令行）是指通过将具有某类共同特征的数据流划分为一类，并为同一类数据流提供相同的服务，也可以对不同类的数据流提供不同的服务。</p>
<p>MQC包含三个要素：流分类（traffic classifier）、流行为（traffic behavior）和流策略（traffic policy）。MQC的流行为支持重定向报文，因此可以使用MQC实现IP单播策略路由。</p>
<h2 id="流分类"><a href="#流分类" class="headerlink" title="流分类"></a>流分类</h2><p>流分类用来定义一组流量匹配规则，以对报文进行分类。流分类规则:</p>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240723230643.png" alt="QQ截图20240723230643" style="zoom:67%;">



<p>流分类中各规则之间的关系分为：and或or，<strong>缺省情况下的关系为or</strong>。</p>
<ul>
<li>and：当流分类中包含ACL规则时，报文必须匹配其中一条ACL规则以及所有非ACL规则才属于该类；当流分类中没有ACL规则时，报文必须匹配所有非ACL规则才属于该类。</li>
<li>or：报文只要匹配了流分类中的一个规则，设备就认为报文属于此类。</li>
</ul>
<h2 id="流行为"><a href="#流行为" class="headerlink" title="流行为"></a>流行为</h2><img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240723230739.png" alt="QQ截图20240723230739" style="zoom:67%;">

<h2 id="流策略"><a href="#流策略" class="headerlink" title="流策略"></a>流策略</h2><p>绑定流分类与流行为</p>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240723230856.png" alt="QQ截图20240723230856" style="zoom:67%;">

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240723231034.png" alt="QQ截图20240723231034" style="zoom:67%;">

<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240723231041.png" alt="QQ截图20240723231041" style="zoom:67%;">

<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240723231048.png" alt="QQ截图20240723231048" style="zoom:67%;">

<h1 id="Traffic-Filter"><a href="#Traffic-Filter" class="headerlink" title="Traffic-Filter"></a>Traffic-Filter</h1><p>使用Traffic-Filter过滤流量可以灵活地选择部署位置，在流量进入设备或者离开设备的接口上执行过滤动作，双向访问的业务禁止其中一个方向即可实现阻断业务的需求。</p>
<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240723231340.png" alt="QQ截图20240723231340" style="zoom:67%;">

<img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/QQ截图20240723231408.png" alt="QQ截图20240723231408" style="zoom:67%;">





<h1 id="实验手册实验"><a href="#实验手册实验" class="headerlink" title="实验手册实验"></a>实验手册实验</h1><p><img src="/2023/11/26/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/luyouceltuopu126203917.png" alt="luyouceltuopu126203917"></p>
<p>设备互联方式、互联地址如图所示，所有设备均创建Loopback0，其IP地址为10.0.x.x&#x2F;32，其中x为设备编号，R1、R2、R3在互联接口、Loopback0接口上激活OSPF。</p>
<p>R3、R4属于IS-IS Area 49.0001，两者都是Level-1路由器，R3、R4的系统ID采用0000.0000.000x格式，其中x为设备编号。</p>
<span id="more"></span>

<p>R1上存在三个业务网段A、B、C（使用Loopback1、2、3接口路由模拟），在R1上将直连路由引入到OSPF，但是OSPF域内的路由器上不需要C业务的路由，为此在R1上引入直连路由时通过Route-Policy过滤引入的路由。</p>
<p>R2上不需要A业务网段的路由，但是R3上需要A、B业务网段的路由，为此在R2上配置Filter-Policy对OSPF接收的路由进行过滤。</p>
<p>IS-IS域内的路由器需要访问A业务，因此需要在R3上执行路由重分发，将OSPF路由引入到IS-IS，但是IS-IS域内的路由器不需要访问B业务，为此在R1上引入直连路由时为A、B业务网段路由打上不同的路由标记，R3上执行重分发时根据路由标记过滤B业务网段路由。</p>
<h2 id="任务思路"><a href="#任务思路" class="headerlink" title="任务思路"></a>任务思路</h2><ol>
<li>设备基础IP地址配置。</li>
<li>配置R1、R2、R3之间的OSPF，在互联接口、Loopback0接口上激活OSPF。在R3、R4之间配置IS-IS。</li>
<li>在R1上将直连路由引入到OSPF中，同时配置路由策略不引入C业务网段的路由，将A、B业务网段路由分别打上路由标记10、20。</li>
<li>在R2上配置Filter-Policy对接收的OSPF路由进行过滤，只接收B业务网段的路由。</li>
<li>在R3上将OSPF路由引入到IS-IS中，通过Route-Policy匹配路由标记，只引入A业务网段的OSPF外部路由。</li>
</ol>
<h2 id="1-配置ip"><a href="#1-配置ip" class="headerlink" title="1.配置ip"></a>1.配置ip</h2><p>#配置R1的GE0&#x2F;0&#x2F;2、Loopback0接口IP地址</p>
<p>[R1]interface GigabitEthernet0&#x2F;0&#x2F;2</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;2] ip address 10.0.12.1 255.255.255.0</p>
<p>[R1-GigabitEthernet0&#x2F;0&#x2F;2] quit</p>
<p>[R1]interface LoopBack0</p>
<p>[R1-LoopBack0] ip address 10.0.1.1 255.255.255.255</p>
<p>[R1-LoopBack0] quit</p>
<p>#在R1上创建多个环回口，用于模拟业务网段A、B、C</p>
<p>[R1]interface LoopBack1</p>
<p>[R1-LoopBack1] ip address 172.16.1.1 255.255.255.0</p>
<p>[R1-LoopBack1] quit</p>
<p>[R1]interface LoopBack2</p>
<p>[R1-LoopBack2] ip address 172.16.2.1 255.255.255.0</p>
<p>[R1-LoopBack2] quit</p>
<p>[R1]interface LoopBack3</p>
<p>[R1-LoopBack3] ip address 172.16.3.1 255.255.255.0</p>
<p>[R1-LoopBack3] quit</p>
<p>#配置R2的GE0&#x2F;0&#x2F;2、GE0&#x2F;0&#x2F;3、Loopback0接口IP地址</p>
<p>[R2]interface LoopBack0</p>
<p>[R2-LoopBack0] ip address 10.0.2.2 255.255.255.255</p>
<p>[R2-LoopBack0] quit</p>
<p>[R2]interface GigabitEthernet0&#x2F;0&#x2F;2</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;2] ip address 10.0.23.2 255.255.255.0</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;2] quit</p>
<p>[R2]interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;3] ip address 10.0.12.2 255.255.255.0</p>
<p>[R2-GigabitEthernet0&#x2F;0&#x2F;3] quit</p>
<p>#配置R3的GE0&#x2F;0&#x2F;2、GE0&#x2F;0&#x2F;3、Loopback0接口IP地址</p>
<p>[R3]interface LoopBack0</p>
<p>[R3-LoopBack0] ip address 10.0.3.3 255.255.255.255</p>
<p>[R3-LoopBack0] quit</p>
<p>[R3]interface GigabitEthernet0&#x2F;0&#x2F;2</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;2] ip address 10.0.34.3 255.255.255.0</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;2] quit</p>
<p>[R3]interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;3] ip address 10.0.23.3 255.255.255.0</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;3] quit</p>
<p>#配置R4的GE0&#x2F;0&#x2F;3、Loopback0接口IP地址</p>
<p>[R4]interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;3] ip address 10.0.34.4 255.255.255.0</p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;3] quit</p>
<p>[R4]interface LoopBack0</p>
<p>[R4-LoopBack0] ip address 10.0.4.4 255.255.255.255</p>
<p>[R4-LoopBack0] quit</p>
<p>#在R2、R4上检查IP地址连通性</p>
<h2 id="配置ospf和isis"><a href="#配置ospf和isis" class="headerlink" title="配置ospf和isis"></a>配置ospf和isis</h2><p>#配置R1</p>
<p>[R1]ospf 1 router-id 10.0.1.1</p>
<p>[R1-ospf-1] area 0</p>
<p>[R1-ospf-1-area-0.0.0.0] network 10.0.1.1 0.0.0.0</p>
<p>[R1-ospf-1-area-0.0.0.0] network 10.0.12.1 0.0.0.0</p>
<p>[R1-ospf-1-area-0.0.0.0] quit</p>
<p>[R1-ospf-1] quit</p>
<p>#配置R2</p>
<p>[R2]ospf 1 router-id 10.0.2.2</p>
<p>[R2-ospf-1] area 0.0.0.0</p>
<p>[R2-ospf-1-area-0.0.0.0] network 10.0.2.2 0.0.0.0</p>
<p>[R2-ospf-1-area-0.0.0.0] network 10.0.12.2 0.0.0.0</p>
<p>[R2-ospf-1-area-0.0.0.0] network 10.0.23.2 0.0.0.0</p>
<p>[R2-ospf-1-area-0.0.0.0] quit</p>
<p>[R2-ospf-1] quit</p>
<p>#配置R3</p>
<p>[R3]ospf 1 router-id 10.0.3.3</p>
<p>[R3-ospf-1] area 0.0.0.0</p>
<p>[R3-ospf-1-area-0.0.0.0] network 10.0.3.3 0.0.0.0</p>
<p>[R3-ospf-1-area-0.0.0.0] network 10.0.23.3 0.0.0.0</p>
<p>[R3-ospf-1-area-0.0.0.0] quit</p>
<p>[R3-ospf-1] quit</p>
<p>#在R2上检查OSPF邻居的概要信息</p>
<p>R3、R4上配置IS-IS，区域为49.0001，系统ID采用0000.0000.000x格式（x为设备编号），两台设备都为Level-1路由器，在互联接口、R4的Loopback0接口上激活IS-IS。</p>
<p>#配置R3</p>
<p>[R3]isis 1</p>
<p>[R3-isis-1] is-level level-1</p>
<p>[R3-isis-1] network-entity 49.0001.0000.0000.0003.00</p>
<p>[R3-isis-1] quit</p>
<p>[R3]interface GigabitEthernet0&#x2F;0&#x2F;2</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;2] isis enable 1</p>
<p>[R3-GigabitEthernet0&#x2F;0&#x2F;2] quit</p>
<p>#配置R4</p>
<p>[R4]isis 1</p>
<p>[R4-isis-1] is-level level-1</p>
<p>[R4-isis-1] network-entity 49.0001.0000.0000.0004.00</p>
<p>[R4-isis-1] quit</p>
<p>[R4]interface GigabitEthernet0&#x2F;0&#x2F;3</p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;3] isis enable 1</p>
<p>[R4-GigabitEthernet0&#x2F;0&#x2F;3] quit</p>
<p>[R4]interface LoopBack 0</p>
<p>[R4-LoopBack0] isis enable 1</p>
<p>[R4-LoopBack0] quit</p>
<p>#在R3上检查IS-IS邻居状态</p>
<h2 id="在R1上引入直连路由"><a href="#在R1上引入直连路由" class="headerlink" title="在R1上引入直连路由"></a>在R1上引入直连路由</h2><p>在R1上将直连路由引入到OSPF中，同时配置路由策略过滤C业务网段，将A、B业务网段路由分别打上路由标记10、20。</p>
<p>#创建IP前缀列表1，匹配Loopback1接口路由（A业务网段）</p>
<p>[R1]ip ip-prefix 1 index 10 permit 172.16.1.0 24 greater-equal 24 less-equal 24</p>
<p>#创建IP前缀列表2，匹配Loopback2接口路由（B业务网段）</p>
<p>[R1]ip ip-prefix 2 index 10 permit 172.16.2.0 24 greater-equal 24 less-equal 24</p>
<p>#创建Route-Policy hcip，并创建节点10、20，分别调用IP前缀列表1、2，打上路由标记</p>
<p>[R1]route-policy hcip permit node 10</p>
<p>[R1-route-policy] if-match ip-prefix 1</p>
<p>[R1-route-policy] apply tag 10</p>
<p>[R1-route-policy] quit</p>
<p>[R1]route-policy hcip permit node 20</p>
<p>[R1-route-policy] if-match ip-prefix 2</p>
<p>[R1-route-policy] apply tag 20 </p>
<p>[R1-route-policy] quit</p>
<p>#在R1的OSPF中引入直连路由，调用Route-Policy hcip</p>
<p>[R1]ospf 1</p>
<p>[R1-ospf-1] import-route direct route-policy hcip</p>
<p>r1上查看ospf lsdb，Loopback1、2接口路由已经被成功引入OSPF中。</p>
<p>#在R1上查看OSPF LSDB中AS-external LSA 172.16.1.0的相关信息</p>
<p>[R1]display ospf lsdb ase 172.16.1.0 </p>
<p>​	 OSPF Process 1 with Router ID 10.0.1.1</p>
<p>​		 Link State Database</p>
<p> Type    : External</p>
<p> Ls id   : 172.16.1.0</p>
<p> Adv rtr  : 10.0.1.1  </p>
<p> Ls age   : 165 </p>
<p> Len    : 36 </p>
<p> Options  :  E  </p>
<p> seq#    : 80000001 </p>
<p> chksum   : 0xa954</p>
<p> Net mask  : 255.255.255.0 </p>
<p> TOS 0  Metric: 1 </p>
<p> E type   : 2</p>
<p> Forwarding Address : 0.0.0.0 </p>
<p> Tag    : 10 </p>
<p> Priority  : Low</p>
<p>外部路由172.16.1.0&#x2F;24已经被打上Tag 10。</p>
<p>#在R1上查看OSPF LSDB中AS-external LSA 172.16.2.0的相关信息</p>
<p>[R1]display ospf lsdb ase 172.16.2.0</p>
<p>​	 OSPF Process 1 with Router ID 10.0.1.1</p>
<p>​		 Link State Database</p>
<p> Type    : External</p>
<p> Ls id   : 172.16.2.0</p>
<p> Adv rtr  : 10.0.1.1  </p>
<p> Ls age   : 355 </p>
<p> Len    : 36 </p>
<p> Options  :  E  </p>
<p> seq#    : 80000001 </p>
<p> chksum   : 0x539f</p>
<p> Net mask  : 255.255.255.0 </p>
<p> TOS 0  Metric: 1 </p>
<p> E type   : 2</p>
<p> Forwarding Address : 0.0.0.0 </p>
<p> Tag    : 20 </p>
<p> Priority  : Low</p>
<p>外部路由172.16.2.0&#x2F;24已经被打上Tag 20。</p>
<h2 id="在R2上配置过滤策略"><a href="#在R2上配置过滤策略" class="headerlink" title="在R2上配置过滤策略"></a>在R2上配置过滤策略</h2><p>在R2上配置Filter-Policy对接收的OSPF路由进行过滤，只接收B业务网段的路由。</p>
<p>#查看配置Filter-Policy前的OSPF路由表</p>
<p><R2>display ospf routing</R2></p>
<p>#查看配置Filter-Policy前的IP路由表中的OSPF路由</p>
<p><R2>display ip routing-table protocol ospf	</R2></p>
<p>在OSPF路由表以及IP路由表中<strong>都可以看到</strong>OSPF外部路由172.16.1.0&#x2F;24、172.16.2.0&#x2F;24。</p>
<p>#配置基础ACL </p>
<p>[R2]acl number 2000</p>
<p>[R2-acl-basic-2000] rule 5 deny source 172.16.1.0 0.0.0.255</p>
<p>[R2-acl-basic-2000] rule 10 permit</p>
<p>#在OSPF中部署入方向的Filter-Policy，调用ACL 2000</p>
<p>[R2]ospf 1</p>
<p>[R2-ospf-1] filter-policy 2000 import</p>
<p>#查看配置Filter-Policy后的OSPF路由表</p>
<p>dis ospf routing</p>
<p>发现两条外部路由都还存在</p>
<p>#查看配置Filter-Policy后的IP路由表中的OSPF路由</p>
<p><R2>display ip routing-table protocol ospf	</R2></p>
<p>在IP路由表中路由172.16.2.0&#x2F;24已经不存在，但是在OSPF路由表中依旧存在。这验证了对于OSPF，Filter-Policy只是限制路由加入IP路由表，不影响本地的LSDB以及LSA的传递。</p>
<p>#在R3上查看IP路由表中的OSPF路由</p>
<p><R3>display ip routing-table protocol ospf </R3></p>
<p>R3的IP路由表中OSPF外部路由172.16.1.0&#x2F;24、172.16.2.0&#x2F;24依旧存在。</p>
<h2 id="在R3上将OSPF路由引入到IS-IS"><a href="#在R3上将OSPF路由引入到IS-IS" class="headerlink" title="在R3上将OSPF路由引入到IS-IS"></a>在R3上将OSPF路由引入到IS-IS</h2><p>在R3上将OSPF路由引入到IS-IS中，通过Route-Policy匹配路由标记，只引入A业务网段的OSPF外部路由。</p>
<p>#创建Route-Policy hcip</p>
<p>[R3]route-policy hcip permit node 10</p>
<p>[R3-route-policy] if-match tag 10</p>
<p>[R3-route-policy] quit</p>
<p>#在IS-IS中引入OSPF路由，调用Route-Policy hcip只引入A业务网段的OSPF外部路由</p>
<p>[R3]isis 1</p>
<p>[R3-isis-1] import-route ospf 1 <strong>level-1</strong> route-policy hcip</p>
<p>（注意指定level）</p>
<p>#查看R3的IS-IS路由表</p>
<p><R3>display isis route </R3></p>
<p>Level-1的路由重分发表中只有172.16.1.0&#x2F;24。</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>路由策略</tag>
      </tags>
  </entry>
  <entry>
    <title>防火墙</title>
    <url>/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<h1 id="包过滤防火墙"><a href="#包过滤防火墙" class="headerlink" title="包过滤防火墙"></a>包过滤防火墙</h1><p>包过滤是指基于五元组对每个数据包进行检测，根据配置的安全策略转发或丢弃数据包。</p>
<p>包过滤防火墙的基本原理是：通过配置访问控制列表（Access Control List，ACL）实施数据包的过滤。</p>
<p>包过滤防火墙的缺点主要表现以下几点：<br>随着ACL复杂度和长度的增加，其过滤性能呈指数下降；<br>静态的ACL规则难以适应动态的安全要求；<br>包过滤不检查会话状态也不分析数据，这很容易让黑客蒙混过关。例如，攻击者可以使用假冒地址进行欺骗，通过把自己主机IP地址设成一个合法主机IP地址，就能很轻易地通过报文过滤器。</p>
<h1 id="状态检测防火墙"><a href="#状态检测防火墙" class="headerlink" title="状态检测防火墙"></a>状态检测防火墙</h1><img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ截图20240805195156.png" alt="QQ截图20240805195156" style="zoom:67%;">

<h1 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h1><p><img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ%E6%88%AA%E5%9B%BE20240805195322.png" alt="QQ截图20240805195322"></p>
<p>防火墙本身的接口默认时local区域，用户可以自己创建区域（优先级不能和默认四个区域优先级一样）</p>
<p><img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ%E6%88%AA%E5%9B%BE20240805195530.png" alt="QQ截图20240805195530"></p>
<h1 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h1><p>当防火墙收到流量后，对流量的属性（五元组、用户、时间段等）进行识别，然后与安全策略的条件进行匹配。</p>
<p>如果条件匹配，则此流量被执行对应的动作。</p>
<p>当配置多条安全策略规则时，安全策略的匹配按照策略列表的顺序执行，即从策略列表顶端开始逐条向下匹配。</p>
<p><strong>如果流量匹配了某个安全策略，将不再进行下一个策略的匹配</strong>。安全策略的配置顺序很重要，需要先配置条件精确的策略，再配置宽泛的策略。</p>
<p><img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ%E6%88%AA%E5%9B%BE20240805195758.png" alt="QQ截图20240805195758"></p>
<h1 id="会话表"><a href="#会话表" class="headerlink" title="会话表"></a>会话表</h1><img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ截图20240805200035.png" alt="QQ截图20240805200035" style="zoom:67%;">



<p><img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ%E6%88%AA%E5%9B%BE20240805195940.png" alt="QQ截图20240805195940"></p>
<p>通过会话中的五元组（源ip，目的ip，源端口，目的端口，协议）信息可以唯一确定通信双方的一条连接。</p>
<p>防火墙将要删除会话的时间称为会话的老化时间。</p>
<p><strong>一条会话表示通信双方的一个连接</strong>。多条会话的集合叫做会话表。</p>
<p>会话建立和包处理流程：</p>
<p><img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ%E6%88%AA%E5%9B%BE20240805200215.png" alt="QQ截图20240805200215"></p>
<p>防火墙为各种协议设定了会话老化机制。当一条会话在老化时间内没有被任何报文匹配，则会被从会话表中删除。这种机制可以避免防火墙的设备资源被大量无用、陈旧的会话表项消耗。</p>
<h1 id="ASPF和Server-map"><a href="#ASPF和Server-map" class="headerlink" title="ASPF和Server-map"></a>ASPF和Server-map</h1><p><img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ%E6%88%AA%E5%9B%BE20240805200438.png" alt="QQ截图20240805200438"></p>
<p><img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ%E6%88%AA%E5%9B%BE20240805200610.png" alt="QQ截图20240805200610"></p>
<p>由于某些特殊应用会在通信过程中临时协商端口号等信息，所以需要设备通过检测报文的应用层数据，自动获取相关信息并创建相应的会话表项，以保证这些应用的正常通信。这个功能称为ASPF（Application Specific Packet Filter），所创建的会话表项叫做Server-map表。</p>
<p>对于多通道协议，例如FTP，ASPF功能可以检查控制通道和数据通道的连接建立过程，通过生成server-map表项，确保FTP协议能够穿越设备，同时不影响设备的安全检查功能。</p>
<p>Server-map表相当于在防火墙上开通了“隐形通道”，使得像FTP这样的特殊应用的报文可以正常转发。当然这个通道不是随意开的，是防火墙分析了报文的应用层信息之后，提前预测到后面报文的行为方式，所以才打开了这样的一个通道。</p>
<p>Server-map通常只是用检查首个报文，通道建立后的报文还是根据会话表来转发。<br>Server-map表在防火墙转发中非常重要，不只是ASPF会生成，NAT Server等特性也会生成Server-map表。</p>
<p>如图所示：<br>Server-map表中记录了FTP服务器向FTP客户端的2071端口号发起的数据连接，服务器向客户端发起数据连接时将匹配这个Server-map表转发，而无需再配置反向安全策略。<br>数据连接的第一个报文匹配Server-map表转发后，防火墙将生成这条数据连接的会话，<strong>该数据连接的后续报文匹配会话表转发，不再需要重新匹配Server-map表项。</strong><br>Server-map表项由于一直没有报文匹配，经过一定老化时间后就会被删除。这种机制保证了Server-map表项这种较为宽松的通道能够及时被删除，保证了网络的安全性。当后续发起新的数据连接时会重新触发建立Server-map表项。</p>
<p><strong>示例：</strong></p>
<img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ截图20240805200939.png" alt="QQ截图20240805200939" style="zoom:67%;">

<p>Server-map表与会话表的关系如下：<br>Server-map表记录了应用层数据中的关键信息，报文命中该表后，不再受安全策略的控制；<br>会话表是通信双方连接状态的具体体现；<br>Server-map表不是当前的连接信息，而是防火墙对当前连接分析后得到的即将到来报文的预测；<br>防火墙收到报文先检查是否命中会话表；<br>如果没有命中则检查是否命中Server-map表；<br>命中Server-map表的报文不受安全策略控制；<br>防火墙最后为命中Server-map表的数据创建会话表。</p>
<h1 id="防火墙nat"><a href="#防火墙nat" class="headerlink" title="防火墙nat"></a>防火墙nat</h1><p><img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ%E6%88%AA%E5%9B%BE20240805202117.png" alt="QQ截图20240805202117"></p>
<p><img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ%E6%88%AA%E5%9B%BE20240805202123.png" alt="QQ截图20240805202123"></p>
<p>当公网用户主动访问Nat地址池中的地址，FW收到此报文后，无法匹配到会话表，根据缺省路由转发给路由器。路由器收到报文后，查找路由表又发送给FW。报文就在路由器和FW之间循环转发，造成路由环路。</p>
<p>黑洞路由的目的是：将目的地址使Nat地址池中地址的报文丢弃</p>
<p><strong>nat server</strong></p>
<p><img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ%E6%88%AA%E5%9B%BE20240805202312.png" alt="QQ截图20240805202312"></p>
<p><img src="/2024/08/05/%E9%98%B2%E7%81%AB%E5%A2%99/QQ%E6%88%AA%E5%9B%BE20240805202257.png" alt="QQ截图20240805202257"></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>防火墙</tag>
        <tag>server-map</tag>
      </tags>
  </entry>
  <entry>
    <title>链路聚合</title>
    <url>/2023/12/07/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="什么是链路聚合"><a href="#什么是链路聚合" class="headerlink" title="什么是链路聚合"></a>什么是链路聚合</h2><p>在现网中，设备间如果通过一条链路连接，<strong>如果这条链路故障了，那么设备两端的终端就不能够通信了</strong>。有什么办法可以解决该问题呢？答案是——<strong>链路聚合</strong>。</p>
<p><strong>从端口的角度定义：</strong></p>
<p><strong>链路聚合（Link Aggregation）</strong>是指将<strong>多个物理端口</strong>汇聚在一起，形成一个<strong>逻辑端口</strong>，以实现出&#x2F;入流量吞吐量在各<strong>成员端口</strong>的负荷分担，交换机根据用户配置的端口负载分担方式决定数据包从哪个成员端口发送到对端的交换机。</p>
<p><strong>从链路的角度定义：</strong></p>
<p>链路聚合（Link Aggregation）是把两台设备之间的<strong>多条物理链路聚</strong>合在一起，当做一条<strong>逻辑链路</strong>来使用。这两台设备可以是一对路由器，一对交换机，或者是一台路由器和一台交换机。一条聚合链路可以包含多条成员链路，默认最多为<strong>8</strong>条。</p>
<h2 id="链路聚合的作用"><a href="#链路聚合的作用" class="headerlink" title="链路聚合的作用"></a>链路聚合的作用</h2><ul>
<li>链路聚合能够<strong>提高链路带宽</strong>。理论上，通过聚合几条链路，一个聚合口的带宽可以扩展为所有成员口带宽的总和，这样就有效地增加了逻辑链路的带宽。</li>
<li>链路聚合<strong>为网络提供了高可靠性</strong>。配置了链路聚合之后，如果一个成员接口发生故障，该成员口的物理链路会把流量切换到另一条成员链路上。</li>
<li>链路聚合<strong>在一个聚合口上实现负载均衡。</strong>一个聚合口可以把流量分散到多个不同的成员口上，通过成员链路把流量发送到同一个目的地，将网络产生拥塞的可能性降到最低。</li>
</ul>
<h2 id="三-链路聚合的工作原理："><a href="#三-链路聚合的工作原理：" class="headerlink" title="三. 链路聚合的工作原理："></a><strong>三. 链路聚合的工作原理：</strong></h2><p><strong>应用场景：</strong></p>
<p>链路聚合一般部署在核心结点，以便提升整个网络的数据吞吐量。</p>
<p>链路聚合能够提高链路带宽，增强网络可靠、可用性，支持负载分担。</p>
<p><strong>链路聚合模式:</strong></p>
<p>链路聚合包含两种模式：<strong>手动负载均衡模式</strong>和<strong>静态LACP（Link Aggregation Control Protocol）模式。</strong></p>
<ol>
<li><strong>手工负载分担模式：</strong></li>
</ol>
<ul>
<li>手工负载分担模式下，Eth-Trunk的建立、<strong>成员接口</strong>的加入由<strong>手工配置</strong>，没有链路聚合控制协议的参与。</li>
<li>该模式下所有<strong>活动链路</strong>都参与数据的转发，平均分担流量，因此称为<strong>负载分担模式</strong>。如果某条活动链路故障，链路聚合组自动在剩余的活动链路中平均分担流量。</li>
</ul>
<p><strong>使用场景：</strong></p>
<p>当需要在两个直连设备间提供<strong>一个较大的链路带宽而设备又不支持LACP协议</strong>时，可以使用手工负载分担模式。</p>
<p><strong>2. 静态LACP模式：</strong></p>
<ul>
<li>在静态LACP模式中，链路两端的设备相互发送<strong>LACP报文，协商聚合参数</strong>。协商完成后，两台设备确定活动接口和非活动接口。</li>
<li>在静态LACP模式中，需要手动创建一个Eth-Trunk口，并添加成员口。</li>
<li>静态LACP模式也叫<strong>M:N模式</strong>。M代表<strong>活动成员链路</strong>，用于在负载均衡模式中转发数据。N代表<strong>非活动链路</strong>，用于冗余备份。</li>
<li>如果一条活动链路发生故障，该链路传输的数据被切换到一条优先级最高的备份链路上，这条备份链路转变为活动状态。</li>
</ul>
<p><strong>两种链路聚合模式的主要区别：</strong></p>
<ul>
<li>在<strong>静态LACP模式中</strong>，一些链路充当备份链路。</li>
<li>在<strong>手动负载均衡模式</strong>中，所有的成员口都处于转发状态。</li>
</ul>
<table>
<thead>
<tr>
<th>维度</th>
<th>手工模式</th>
<th>LACP模式</th>
</tr>
</thead>
<tbody><tr>
<td>Eth-Trunk的建立方式</td>
<td>Eth-Trunk接口的创建、成员接口的加入由手工配置，没有链路聚合控制协议的参与。</td>
<td>Eth-Trunk接口的创建、成员接口的加入由手工配置，LACP协议参与链路动态调整，负责链路状态维护。在聚合条件发生变化时，自动调整或解散链路聚合。</td>
</tr>
<tr>
<td>设备是否需要支持LACP协议</td>
<td>不需要</td>
<td>需要</td>
</tr>
<tr>
<td>数据转发</td>
<td>正常情况下，所有链路都是活动链路。所有活动链路均参与数据转发。如果某条活动链路故障，链路聚合组自动在剩余的活动链路中分担流量。</td>
<td>正常情况下，部分链路是活动链路。所有活动链路均参与数据转发。如果某条活动链路故障，链路聚合组自动在非活动链路中选择一条链路作为活动链路，参与数据转发的链路数目不变。</td>
</tr>
<tr>
<td>检测故障</td>
<td>只能检测到同一聚合组内的成员链路有断路等故障，无法检测到链路断连、错连等故障。</td>
<td>不仅能够检测到同一聚合组内的成员链路有断路等故障，还可以检测到链路故障、链路错连等故障。</td>
</tr>
</tbody></table>
<p><strong>数据流控制:</strong></p>
<p>Eth-trunk链路两端相连的物理接口的数量、速率、双工方式、流控方式必须一致。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>系统优先级：</p>
<p>0-65535 </p>
<p>默认32768</p>
<p>小的优先</p>
<p>优先级一样，看mac，mac小的优先</p>
<p>接口优先级：</p>
<p>也是0-65535</p>
<p>小的优</p>
<p>默认32768</p>
<h1 id="LACPDU报文"><a href="#LACPDU报文" class="headerlink" title="LACPDU报文"></a>LACPDU报文</h1><p>基于IEEE802.3ad标准的LACP是一种实现链路动态聚合与解聚合的协议。LACP通过链路聚合控制协议数据单元LACPDU（Link Aggregation Control Protocol Data Unit）与对端交互信息。</p>
<p>在LACP模式的Eth-Trunk中加入成员接口后，这些接口将通过发送LACPDU向对端通告自己的系统<strong>优先级、MAC地址、接口优先级、接口号和操作Key等</strong>信息。对端接收到这些信息后，将这些信息与自身接口所保存的信息比较，用以选择能够聚合的接口，双方对哪些接口能够成为活动接口达成一致，确定活动链路。</p>
<p>LACPDU 帧基于 IEEE 802.3ad 标准，是一种慢协议（平均每秒发送的协议报文不超过 5 个），其目的 MAC 地址是一个特殊的组播地址 <strong>0x01-80-c2-00-00-02。</strong></p>
<p>如果接口板收到报文的目的 MAC 是该组播地址，且二层协议类型字段为 0x8809、协议子类型为 0x01，则说明此数据报文为 LACPDU 帧。</p>
<p>报文格式：</p>
<p>LACPDU（Link Aggregation Control Protocol Data Unit，链路聚合控制协议数据单元）的报文格式如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度（字节）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Destination Address（目的MAC地址）</td>
<td>6</td>
<td>是一个组播地址，固定为01-80-c2-00-00-02</td>
</tr>
<tr>
<td>Source Address（源MAC地址）</td>
<td>6</td>
<td>发送端口的MAC地址</td>
</tr>
<tr>
<td>Length&#x2F;Type（长度&#x2F;类型）</td>
<td>2</td>
<td>协议类型：0x8809</td>
</tr>
<tr>
<td>Subtype（报文子类型）</td>
<td>1</td>
<td>取值为0x01，代表是LACP报文</td>
</tr>
<tr>
<td>Version Number（协议版本号）</td>
<td>1</td>
<td>固定为0x01</td>
</tr>
<tr>
<td>TLV_Type&#x3D;Actor Information（TLV类型&#x3D;Actor信息）</td>
<td>1</td>
<td>标识TLV的类型，值为0x01代表Actor字段</td>
</tr>
<tr>
<td>Actor_Information_Length（Actor信息字段长度）</td>
<td>1</td>
<td>取值为20（即0x14），以字节为单位</td>
</tr>
<tr>
<td>Actor_System_Priority（本端系统优先级）</td>
<td>2</td>
<td>可以设置，默认情况下为32768（即0x8000）</td>
</tr>
<tr>
<td>Actor_System（本端系统ID）</td>
<td>6</td>
<td>本端系统的MAC地址</td>
</tr>
<tr>
<td>Actor_Key（端口Key值）</td>
<td>2</td>
<td>系统根据端口的配置生成，是端口能否成为聚合组成员的关键因素，影响Key值的因素有Trunk ID、接口的速率和双工模式</td>
</tr>
<tr>
<td>Actor_Port_Priority（本端接口优先级）</td>
<td>2</td>
<td>可以配置，默认为0x8000</td>
</tr>
<tr>
<td>Actor_Port（本端端口号）</td>
<td>2</td>
<td>由接口所在的槽位号、子卡号和端口号决定</td>
</tr>
<tr>
<td>Actor_State（本端状态信息）</td>
<td>1</td>
<td>8位比特的含义分别为： Bit0：lacp_activity，代表链路所在的聚合组参与LACP协商的方式。主动的LACP被编码为1，即主动方式下会主动发送LACPDU报文给对方，被动方式不会主动发送协商报文，除非收到协商报文才会参与； Bit1：lacp_timeout，代表链路接收LACPDU报文的周期，有两种，快周期1秒和慢周期30秒，超时时间为周期的3倍。短超时被编码为1，长超时被编码为0； Bit2：aggregation，标识该链路能否被聚合组聚合。如果编码为0，该链路被认为是独立的，不能被聚合，即这个链路只能作为一个个体链路运行； Bit3：synchronization，代表该链路是否已被分配到一个正确的链路聚合组，如果该链路已经关联了一个兼容的聚合器，那么该链路聚合组的识别与系统ID和被发送的运行Key信息是一致的。编码为0，代表链路当前不在正确的聚合里； Bit4：collecting，帧的收集使能位，假如编码为1，表示在这个链路上进来的帧的收集是明确使能的，即收集当前被使能，并且不期望在没有管理变化或接收协议信息变化的情况下被禁止。其它情况下这个值编码为0； Bit5：distributing，帧的分配使能位，假如编码为0，意味着在这个链路上的外出帧的分配被明确禁止，并且不期望在没有管理变化或接收协议信息变化的情况下被使能。其它情况下这个值编码为1； Bit6-7：default和expired，用于诊断调试，default编码为1代表接收到的对端的信息是管理配置的。假如编码为0，正在使用的运行伙伴信息在接收到的LACPDU里。expired编码为1代表本端的接收机是处于expired超时状态；假如编码为0，本端接收状态机处于正常状态。这两值不被正常LACP协议使用，仅用于诊断协议问题</td>
</tr>
<tr>
<td>Reserved（保留字段）</td>
<td>3</td>
<td>可用于功能调试以及扩展</td>
</tr>
<tr>
<td>TLV_Type&#x3D;Partner Information（TLV类型&#x3D;Partner信息）</td>
<td>1</td>
<td>标识TLV的类型，值为0x02代表Partner字段</td>
</tr>
<tr>
<td>Partner_Information_Length（Partner信息字段长度）</td>
<td>1</td>
<td>取值为20（即0x14），以字节为单位</td>
</tr>
<tr>
<td>Partner_System_Priority（对端系统优先级）</td>
<td>2</td>
<td>对端系统优先级</td>
</tr>
<tr>
<td>Partner_System（对端系统ID）</td>
<td>6</td>
<td>对端系统的MAC地址</td>
</tr>
<tr>
<td>Partner_Key（对端端口Key值）</td>
<td>2</td>
<td>对端端口Key值</td>
</tr>
<tr>
<td>Partner_Port_Priority（对端接口优先级）</td>
<td>2</td>
<td>对端接口优先级</td>
</tr>
<tr>
<td>Partner_Port（对端端口号）</td>
<td>2</td>
<td>对端端口号</td>
</tr>
<tr>
<td>Partner_State（对端状态信息）</td>
<td>2</td>
<td>对端状态信息，与Actor_State字段含义一致</td>
</tr>
<tr>
<td>Reserved（保留字段）</td>
<td>3</td>
<td>可用于功能调试以及扩展</td>
</tr>
<tr>
<td>TLV_Type&#x3D;Collector Information（TLV类型&#x3D;Collector信息）</td>
<td>1</td>
<td>标识TLV的类型，值为0x03代表Collector字段</td>
</tr>
<tr>
<td>Collector_Information_Length（Collector信息字段长度）</td>
<td>1</td>
<td>取值为16（即0x10），以字节为单位</td>
</tr>
<tr>
<td>CollectorMaxDelay（最大延时）</td>
<td>2</td>
<td>以10微秒为单位</td>
</tr>
<tr>
<td>Reserved（保留字段）</td>
<td>12</td>
<td>可用于功能调试以及扩展</td>
</tr>
<tr>
<td>TLV_Type&#x3D;Terminator Information（TLV类型&#x3D;Terminator信息）</td>
<td>1</td>
<td>标识TLV的类型，值为0x00代表Terminator字段</td>
</tr>
<tr>
<td>Terminator_Length（Terminator信息字段长度）</td>
<td>1</td>
<td>取值为0（即0x00）</td>
</tr>
<tr>
<td>Reserved（保留字段）</td>
<td>50</td>
<td>全置0，接收端忽略此字段</td>
</tr>
<tr>
<td>FCS（帧校验序列）</td>
<td>4</td>
<td>用于帧内后续字节差错的循环</td>
</tr>
</tbody></table>
<p>1.两端互相发送LACPDU报文</p>
<p>在DeviceA和DeviceB上创建Eth-Trunk并配置为LACP模式，然后向Eth-Trunk中手工加入成员接口。此时成员接口上便启用了LACP协议，两端互发LACPDU报文。</p>
<p><img src="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZH05262_14_zh/HDXAZH05262_14_zh/resources/dc/images/fig_dc_fd_eth-trunk_000704ar.gif" alt="img"></p>
<p>以DeviceB为例，当DeviceB收到DeviceA发送的报文时，DeviceB会查看并记录对端信息，然后比较系统优先级字段，如果DeviceA的系统优先级高于本端的系统优先级，则确定DeviceA为LACP主动端。如果DeviceA和DeviceB的系统优先级相同，比较两端设备的MAC地址，确定MAC地址小的一端为LACP主动端。</p>
<p>选出主动端后，两端都会<strong>以主动端的接口优先级来选择活动接口</strong>，两端设备选择了一致的活动接口，活动链路组便可以建立起来，从这些活动链路中以负载分担的方式转发数据。</p>
<p>2.确定主动端(基于系统优先级和MAC)和活动链路（基于接口优先级）</p>
<p>两端设备均会收到对端发来的LACPDU报文。以DeviceB为例，当DeviceB收到DeviceA发送的报文时，DeviceB会查看并记录对端信息，然后比较<strong>系统优先级</strong>字段，如果DeviceA的系统优先级高于本端的系统优先级，则确定DeviceA为LACP主动端。如果DeviceA和DeviceB的系统优先级相同，比较两端设备的MAC地址，确定MAC地址小的一端为LACP主动端。</p>
<p>选出主动端后，两端都会以主动端的<strong>接口优先级</strong>来选择活动接口，两端设备选择了一致的活动接口，活动链路组便可以建立起来，从这些活动链路中以负载分担的方式转发数据。</p>
<p><img src="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZH05262_14_zh/HDXAZH05262_14_zh/resources/dc/images/fig_dc_fd_eth-trunk_000705ar.gif" alt="img"></p>
<p>3.LACP抢占（缺省不抢占）</p>
<p>使能LACP抢占功能后，聚合组会<strong>始终保持高优先级</strong>的接口作为活动接口的状态。</p>
<p>接口Port1、Port2和Port3为Eth-Trunk的成员接口，DeviceA为主动端，活动接口数上限阈值为2，三个接口的LACP优先级分别为10、20、30。当通过LACP协议协商完毕后，接口Port1和Port2因为优先级较高被选作活动接口，Port3成为备份接口。</p>
<p><img src="http://127.0.0.1:51299/icslite/hdx/pages/HDXAZH05262_14_zh/HDXAZH05262_14_zh/resources/dc/images/fig_dc_fd_eth-trunk_000706ar.gif" alt="img"></p>
<ul>
<li><p>以下两种情况需要使能LACP的抢占功能。</p>
<ul>
<li>Port1接口出现故障而后又恢复了正常。当接口Port1出现故障时被Port3所取代，如果在Eth-Trunk接口下未使能LACP抢占功能，则故障恢复时Port1将处于备份状态；如果使能了LACP抢占功能，当Port1故障恢复时，由于接口优先级比Port3高，将重新成为活动接口，Port3再次成为备份接口。</li>
<li>如果希望Port3接口替换Port1、Port2中的一个接口成为活动接口，可以使能了LACP抢占功能，并配置Port3的接口LACP优先级较高。如果没有使能LACP抢占功能，即使将备份接口的优先级调整为高于当前活动接口的优先级，系统也不会进行重新选择活动接口的过程，不切换活动接口。</li>
</ul>
</li>
<li><p>LACP抢占延时（默认30s，10-180）</p>
<p>抢占延时是LACP抢占发生时，处于备用状态的链路将会等待一段时间后再切换到转发状态。配置抢占延时是为了避免由于某些链路状态频繁变化而导致Eth-Trunk数据传输不稳定的情况。</p>
<p>Port1由于链路故障切换为非活动接口，此后该链路又恢复了正常。若系统使能了LACP抢占功能并配置了抢占延时，Port1重新切换回活动状态就需要经过抢占延时的时间。</p>
<p>LACP 抢占延时的取值范围通常是<strong>10～180</strong>秒。</p>
<p>LACP 抢占延时是指在启用 LACP 抢占功能后，当高优先级的链路恢复正常，且当前活动链路数已达到上限阈值时，等待多久后高优先级链路才会取代低优先级链路成为活动链路。</p>
<p>默认情况下，LACP 抢占等待时间通常为<strong>30秒</strong>。但这个时间可以根据具体需求进行配置，通过在Eth-Trunk接口视图下使用“<strong>lacp preempt delay delay-time”</strong>命令来设置，其中“delay-time”为具体的时间值，单位是秒。</p>
<p>配置抢占延时功能可以避免由于链路状态频繁变化而导致的数据传输不稳定。<strong>但需注意，配置抢占延时需要确保当前的Eth-Trunk工作模式为LACP模式，并且已经使能了优先级抢占，否则配置不生效</strong>。要使能优先级抢占，可在Eth-Trunk接口视图下执行“lacp preempt enable”命令。</p>
</li>
<li><p>活动链路与非活动链路切换</p>
<p>LACP模式链路聚合组两端设备中任何一端检测到以下事件，都会触发聚合组的链路切换：</p>
<ul>
<li>链路Down事件。</li>
<li>以太网OAM检测到链路失效。</li>
<li>LACP协议发现链路故障。</li>
<li>接口不可用。</li>
<li>在使能了LACP抢占功能的前提下，更改备份接口的优先级高于当前活动接口的优先级。</li>
</ul>
<p>当满足上述切换条件其中之一时，按照如下步骤进行切换：</p>
<ol>
<li>关闭故障链路。</li>
<li>从N条备份链路中选择优先级最高的链路接替活动链路中的故障链路。</li>
<li>优先级最高的备份链路转为活动状态并转发数据，完成切换。</li>
</ol>
</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><img src="/2023/12/07/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/juhetuopu31207160429.png" alt="juhetuopu31207160429"></p>
<h2 id="配置手工链路聚合"><a href="#配置手工链路聚合" class="headerlink" title="配置手工链路聚合"></a>配置手工链路聚合</h2><p># 创建Eth-Trunk接口</p>
<p>[S1]interface Eth-Trunk 1 </p>
<p><strong>interface eth-trunk</strong>命令用来进入已经存在的Eth-Trunk接口，或创建并进入Eth-Trunk接口。数字“1”代表接口编号，编号范围根据设备情况有所不同。</p>
<p>[S2]interface Eth-Trunk 1</p>
<p># 设置Eth-Trunk接口的聚合模式 </p>
<p>[S1-Eth-Trunk1]mode manual load-balance</p>
<p><strong>mode</strong>命令用来配置Eth-Trunk的工作模式，有LACP模式和手工负载分担模式（手工模式）两种，缺省情况下，Eth-Trunk的工作模式为手工负载分担模式。此处S1上的模式配置仅为示范目的，实际操作时不需要。</p>
<p># 将成员接口加入聚合组</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;10 </p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;10]eth-trunk 1 </p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;10]quit</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;11</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11]eth-trunk 1</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11]quit</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;12</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12]eth-trunk 1</p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12]quit</p>
<p>可进入到成员接口的接口视图下，逐一添加到Eth-Trunk接口。也可以在Eth-Trunk接口视图下通过<strong>trunkport</strong>命令批量添加接口。</p>
<p>[S2]interface Eth-Trunk 1</p>
<p>[S2-Eth-Trunk1]trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12 </p>
<p>Info: This operation may take a few seconds. Please wait for a moment…done.</p>
<p>将成员接口加入Eth-Trunk时，需要注意以下问题：</p>
<p>• 每个Eth-Trunk接口下最多可以包含8个成员接口。</p>
<p>• Eth-Trunk接口不能嵌套，即Eth-Trunk接口的成员接口不能是Eth-Trunk接口。</p>
<p>• 一个以太网接口只能加入到一个Eth-Trunk接口，如果需要加入其它Eth-Trunk接口，必须先退出原来的Eth-Trunk接口。</p>
<p>• 如果本地设备使用了Eth-Trunk，与成员接口直连的对端接口也必须捆绑为Eth-Trunk接口，两端才能正常通信。</p>
<p>Eth-Trunk链路两端相连的物理接口的数量、速率、双工方式等必须一致。</p>
<p>#查看Eth-Trunk接口状态</p>
<p>dis eth-trunk 1</p>
<h2 id="配置LACP模式"><a href="#配置LACP模式" class="headerlink" title="配置LACP模式"></a>配置LACP模式</h2><p># 删除现有Eth-Trunk接口下的成员接口</p>
<p>[S1]interface Eth-Trunk 1</p>
<p>[S1-Eth-Trunk1]undo trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12</p>
<p>[S2]interface Eth-Trunk 1</p>
<p>[S2-Eth-Trunk1]undo trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12</p>
<p><strong>在修改Eth-Trunk接口的聚合模式之前，需要确保Eth-Trunk中没有任何成员接口。</strong></p>
<p># 修改聚合模式</p>
<p>[S1]interface Eth-Trunk 1</p>
<p>[S1-Eth-Trunk1]mode lacp</p>
<p><strong>mode</strong> <strong>lacp</strong> 指定Eth-Trunk工作模式为LACP模式。</p>
<p>注：部分版本的设备命令为 mode lacp-static</p>
<p>[S2]interface Eth-Trunk 1</p>
<p>[S2-Eth-Trunk1]mode lacp</p>
<p># 将成员接口加入聚合组</p>
<p>[S1]interface Eth-Trunk 1</p>
<p>[S1-Eth-Trunk1]trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12</p>
<p>[S2]interface Eth-Trunk 1</p>
<p>[S2-Eth-Trunk1]trunkport GigabitEthernet 0&#x2F;0&#x2F;10 to 0&#x2F;0&#x2F;12</p>
<p>查看</p>
<p><img src="/2023/12/07/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/1chakan1207160903.png" alt="1chakan1207160903"></p>
<p>注意此时三个接口都是Select的状态</p>
<h2 id="选择接口"><a href="#选择接口" class="headerlink" title="选择接口"></a>选择接口</h2><p>​	考虑到网络流量情况，当网络正常时，只需要GigabitEthernet0&#x2F;0&#x2F;11和GigabitEthernet0&#x2F;0&#x2F;12接口处于转发状态，GigabitEthernet0&#x2F;0&#x2F;10接口作为备份。但当活动接口数量少于2时，直接关闭整个Eth-Trunk接口。</p>
<p>全局配置优先级选举主动方，主动方设备的端口上配置接口优先级选举活动端口</p>
<p># 配置设备S1的LACP优先级，使其成为主动端设备</p>
<p>[S1]lacp priority 100 </p>
<p># 配置接口优先级，优选GigabitEthernet0&#x2F;0&#x2F;11和GigabitEthernet0&#x2F;0&#x2F;12接口</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;10 </p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;10]lacp priority 40000</p>
<p># 配置接口优先级，优选GigabitEthernet0&#x2F;0&#x2F;11和GigabitEthernet0&#x2F;0&#x2F;12接口</p>
<p>[S1]interface GigabitEthernet 0&#x2F;0&#x2F;10 </p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;10]lacp priority 40000</p>
<p>g0&#x2F;0&#x2F;10配置了大于32768的优先级4000，所以变为备份端口</p>
<p>之后，g0&#x2F;0&#x2F;11和g0&#x2F;0&#x2F;12为活动端口</p>
<p>使能了LACP模式链路聚合的两端设备均会收发的LACPDU报文。</p>
<p>首先<strong>选举主动端设备</strong>：</p>
<ol>
<li>比较系统优先级字段，如果对端的系统优先级高于本端的系统优先级（默认为32768，越小越优），则确定对端为LACP主动端。</li>
<li>如果系统优先级相同，比较两端设备的MAC地址，MAC地址小的一端为LACP主动端。</li>
</ol>
<p>选出主动端后，两端都会以主动端的接口优先级来选择活动接口，接口优先级越小越优，默认为32768。</p>
<p># 配置Eth-trunk活动接口数上限阈值和下限阈值</p>
<p>[S1]interface Eth-Trunk 1</p>
<p>[S1-Eth-Trunk1]max active-linknumber 2</p>
<p>[S1-Eth-Trunk1]least active-linknumber 2</p>
<p>在一个Eth-Trunk接口内，活动接口数可以影响到Eth-Trunk接口的状态和带宽。Eth-Trunk接口的带宽是所有处于Up状态的成员口带宽之和。为保证Eth-Trunk接口的状态和带宽，可以设置以下两个阈值，以减小成员链路状态的变化带来的影响。</p>
<p>• 活动接口数下限阈值：当活动接口数小于配置的下限阈值时，Eth-Trunk接口的状态转为Down。设置活动接口数下限阈值的目的是为了保证最小带宽。<strong>least active-linknumber</strong>命令用来配置链路聚合组活动接口数目的下限阈值。</p>
<p>• 活动接口数上限阈值：当活动接口数达到上限阈值后，之后再发生成员链路状态变为Up都不会使Eth-Trunk接口的带宽增加。设置活动接口数上限阈值的目的是在保证了带宽的情况下提高网络的可靠性。<strong>max active-linknumber</strong>命令用来配置链路聚合组活动接口数目的上限阈值。</p>
<p># 开启抢占功能</p>
<p>[S1]interface Eth-Trunk 1</p>
<p>[S1-Eth-Trunk1]lacp preempt enable</p>
<p>在LACP模式下，当活动链路中出现故障链路时，系统会从备用链路中选择优先级最高的链路替代故障链路；如果被替代的故障链路恢复了正常，而且该链路的优先级又高于替代自己的链路。这种情况下，如果使能了LACP优先级抢占功能，高优先级链路会抢占低优先级链路，<strong>回切</strong>到活动状态。<strong>lacp preempt enable</strong>命令用来使能LACP模式下LACP优先级抢占的功能，缺省情况下，优先级抢占处于禁止状态。</p>
<p># 查看当前 Eth-Trunk接口状态</p>
<p><img src="/2023/12/07/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/2chakan2207161758.png" alt="2chakan2207161758"></p>
<p>shutdown接口g0&#x2F;0&#x2F;11和g0&#x2F;0&#x2F;12</p>
<p>查看状态，发现都变为unselect状态</p>
<p>由于设置了Eth-Trunk的活动链路下限阈值为2，所以聚合组中可用活动接口数量少于2时，整个聚合组对应的接口将会被关闭。尽管此时GigabitEthernet0&#x2F;0&#x2F;10处于UP状态，但是仍处于Unselect状态。</p>
<h2 id="修改负载分担模式"><a href="#修改负载分担模式" class="headerlink" title="修改负载分担模式"></a>修改负载分担模式</h2><p># 开启上一步中关闭的接口 </p>
<p>[S1]inter GigabitEthernet 0&#x2F;0&#x2F;11</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11]undo shutdown </p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;11]quit</p>
<p>[S1]inter GigabitEthernet 0&#x2F;0&#x2F;12</p>
<p>[S1-GigabitEthernet0&#x2F;0&#x2F;12]undo shutdown</p>
<p># 大约30秒后，查看当前Eth-Trunk1的接口状态</p>
<p>由于使能了Eth-Trunk接口的抢占功能，所以当GigabitEthernet0&#x2F;0&#x2F;11和GigabitEthernet0&#x2F;0&#x2F;12接口进入UP状态之后，这两个接口的接口的优先级高于GigabitEthernet0&#x2F;0&#x2F;10，所以GigabitEthernet0&#x2F;0&#x2F;10会进入unselect状态。同时因为系统为了保证链路的稳定性，默认的抢占延时为30秒，所以要在30秒后才会发生抢占。</p>
<p># 修改Eth-Trunk接口的负载分担模式为基于目的IP地址</p>
<p>[S1]interface Eth-Trunk 1</p>
<p>[S1-Eth-Trunk1]load-balance dst-ip</p>
<p>当需要将Eth-Trunk接口的流量分散到不同的链路上，最后能到达统一目的地时，使用load-balance命令配置Eth-Trunk接口负载分担模式，以确保出方向的流量在各物理链路间进行合理的负载分担，避免链路阻塞。由于负载分担只对出方向的流量有效，因此链路两端接口的负载分担模式可以不一致，两端互不影响</p>
]]></content>
      <categories>
        <category>ip实验</category>
      </categories>
      <tags>
        <tag>链路聚合</tag>
        <tag>lacp</tag>
        <tag>eth-trunk</tag>
      </tags>
  </entry>
</search>
